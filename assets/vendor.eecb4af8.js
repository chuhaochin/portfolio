var OE = Object.defineProperty;
var i_ = Object.getOwnPropertySymbols;
var NE = Object.prototype.hasOwnProperty,
  BE = Object.prototype.propertyIsEnumerable;
var r_ = (a, t, e) =>
    t in a
      ? OE(a, t, { enumerable: !0, configurable: !0, writable: !0, value: e })
      : (a[t] = e),
  s_ = (a, t) => {
    for (var e in t || (t = {})) NE.call(t, e) && r_(a, e, t[e]);
    if (i_) for (var e of i_(t)) BE.call(t, e) && r_(a, e, t[e]);
    return a;
  };
var Bs =
  typeof globalThis != "undefined"
    ? globalThis
    : typeof window != "undefined"
    ? window
    : typeof global != "undefined"
    ? global
    : typeof self != "undefined"
    ? self
    : {};
function zE(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default")
    ? a.default
    : a;
}
var mf = { exports: {} },
  yo = typeof Reflect == "object" ? Reflect : null,
  o_ =
    yo && typeof yo.apply == "function"
      ? yo.apply
      : function (t, e, n) {
          return Function.prototype.apply.call(t, e, n);
        },
  Lc;
yo && typeof yo.ownKeys == "function"
  ? (Lc = yo.ownKeys)
  : Object.getOwnPropertySymbols
  ? (Lc = function (t) {
      return Object.getOwnPropertyNames(t).concat(
        Object.getOwnPropertySymbols(t)
      );
    })
  : (Lc = function (t) {
      return Object.getOwnPropertyNames(t);
    });
function UE(a) {
  console && console.warn && console.warn(a);
}
var a_ =
  Number.isNaN ||
  function (t) {
    return t !== t;
  };
function Ae() {
  Ae.init.call(this);
}
mf.exports = Ae;
mf.exports.once = VE;
Ae.EventEmitter = Ae;
Ae.prototype._events = void 0;
Ae.prototype._eventsCount = 0;
Ae.prototype._maxListeners = void 0;
var l_ = 10;
function Cc(a) {
  if (typeof a != "function")
    throw new TypeError(
      'The "listener" argument must be of type Function. Received type ' +
        typeof a
    );
}
Object.defineProperty(Ae, "defaultMaxListeners", {
  enumerable: !0,
  get: function () {
    return l_;
  },
  set: function (a) {
    if (typeof a != "number" || a < 0 || a_(a))
      throw new RangeError(
        'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
          a +
          "."
      );
    l_ = a;
  },
});
Ae.init = function () {
  (this._events === void 0 ||
    this._events === Object.getPrototypeOf(this)._events) &&
    ((this._events = Object.create(null)), (this._eventsCount = 0)),
    (this._maxListeners = this._maxListeners || void 0);
};
Ae.prototype.setMaxListeners = function (t) {
  if (typeof t != "number" || t < 0 || a_(t))
    throw new RangeError(
      'The value of "n" is out of range. It must be a non-negative number. Received ' +
        t +
        "."
    );
  return (this._maxListeners = t), this;
};
function c_(a) {
  return a._maxListeners === void 0 ? Ae.defaultMaxListeners : a._maxListeners;
}
Ae.prototype.getMaxListeners = function () {
  return c_(this);
};
Ae.prototype.emit = function (t) {
  for (var e = [], n = 1; n < arguments.length; n++) e.push(arguments[n]);
  var i = t === "error",
    r = this._events;
  if (r !== void 0) i = i && r.error === void 0;
  else if (!i) return !1;
  if (i) {
    var o;
    if ((e.length > 0 && (o = e[0]), o instanceof Error)) throw o;
    var l = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw ((l.context = o), l);
  }
  var u = r[t];
  if (u === void 0) return !1;
  if (typeof u == "function") o_(u, this, e);
  else
    for (var h = u.length, f = p_(u, h), n = 0; n < h; ++n) o_(f[n], this, e);
  return !0;
};
function u_(a, t, e, n) {
  var i, r, o;
  if (
    (Cc(e),
    (r = a._events),
    r === void 0
      ? ((r = a._events = Object.create(null)), (a._eventsCount = 0))
      : (r.newListener !== void 0 &&
          (a.emit("newListener", t, e.listener ? e.listener : e),
          (r = a._events)),
        (o = r[t])),
    o === void 0)
  )
    (o = r[t] = e), ++a._eventsCount;
  else if (
    (typeof o == "function"
      ? (o = r[t] = n ? [e, o] : [o, e])
      : n
      ? o.unshift(e)
      : o.push(e),
    (i = c_(a)),
    i > 0 && o.length > i && !o.warned)
  ) {
    o.warned = !0;
    var l = new Error(
      "Possible EventEmitter memory leak detected. " +
        o.length +
        " " +
        String(t) +
        " listeners added. Use emitter.setMaxListeners() to increase limit"
    );
    (l.name = "MaxListenersExceededWarning"),
      (l.emitter = a),
      (l.type = t),
      (l.count = o.length),
      UE(l);
  }
  return a;
}
Ae.prototype.addListener = function (t, e) {
  return u_(this, t, e, !1);
};
Ae.prototype.on = Ae.prototype.addListener;
Ae.prototype.prependListener = function (t, e) {
  return u_(this, t, e, !0);
};
function kE() {
  if (!this.fired)
    return (
      this.target.removeListener(this.type, this.wrapFn),
      (this.fired = !0),
      arguments.length === 0
        ? this.listener.call(this.target)
        : this.listener.apply(this.target, arguments)
    );
}
function h_(a, t, e) {
  var n = { fired: !1, wrapFn: void 0, target: a, type: t, listener: e },
    i = kE.bind(n);
  return (i.listener = e), (n.wrapFn = i), i;
}
Ae.prototype.once = function (t, e) {
  return Cc(e), this.on(t, h_(this, t, e)), this;
};
Ae.prototype.prependOnceListener = function (t, e) {
  return Cc(e), this.prependListener(t, h_(this, t, e)), this;
};
Ae.prototype.removeListener = function (t, e) {
  var n, i, r, o, l;
  if ((Cc(e), (i = this._events), i === void 0)) return this;
  if (((n = i[t]), n === void 0)) return this;
  if (n === e || n.listener === e)
    --this._eventsCount == 0
      ? (this._events = Object.create(null))
      : (delete i[t],
        i.removeListener && this.emit("removeListener", t, n.listener || e));
  else if (typeof n != "function") {
    for (r = -1, o = n.length - 1; o >= 0; o--)
      if (n[o] === e || n[o].listener === e) {
        (l = n[o].listener), (r = o);
        break;
      }
    if (r < 0) return this;
    r === 0 ? n.shift() : GE(n, r),
      n.length === 1 && (i[t] = n[0]),
      i.removeListener !== void 0 && this.emit("removeListener", t, l || e);
  }
  return this;
};
Ae.prototype.off = Ae.prototype.removeListener;
Ae.prototype.removeAllListeners = function (t) {
  var e, n, i;
  if (((n = this._events), n === void 0)) return this;
  if (n.removeListener === void 0)
    return (
      arguments.length === 0
        ? ((this._events = Object.create(null)), (this._eventsCount = 0))
        : n[t] !== void 0 &&
          (--this._eventsCount == 0
            ? (this._events = Object.create(null))
            : delete n[t]),
      this
    );
  if (arguments.length === 0) {
    var r = Object.keys(n),
      o;
    for (i = 0; i < r.length; ++i)
      (o = r[i]), o !== "removeListener" && this.removeAllListeners(o);
    return (
      this.removeAllListeners("removeListener"),
      (this._events = Object.create(null)),
      (this._eventsCount = 0),
      this
    );
  }
  if (((e = n[t]), typeof e == "function")) this.removeListener(t, e);
  else if (e !== void 0)
    for (i = e.length - 1; i >= 0; i--) this.removeListener(t, e[i]);
  return this;
};
function f_(a, t, e) {
  var n = a._events;
  if (n === void 0) return [];
  var i = n[t];
  return i === void 0
    ? []
    : typeof i == "function"
    ? e
      ? [i.listener || i]
      : [i]
    : e
    ? HE(i)
    : p_(i, i.length);
}
Ae.prototype.listeners = function (t) {
  return f_(this, t, !0);
};
Ae.prototype.rawListeners = function (t) {
  return f_(this, t, !1);
};
Ae.listenerCount = function (a, t) {
  return typeof a.listenerCount == "function"
    ? a.listenerCount(t)
    : d_.call(a, t);
};
Ae.prototype.listenerCount = d_;
function d_(a) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[a];
    if (typeof e == "function") return 1;
    if (e !== void 0) return e.length;
  }
  return 0;
}
Ae.prototype.eventNames = function () {
  return this._eventsCount > 0 ? Lc(this._events) : [];
};
function p_(a, t) {
  for (var e = new Array(t), n = 0; n < t; ++n) e[n] = a[n];
  return e;
}
function GE(a, t) {
  for (; t + 1 < a.length; t++) a[t] = a[t + 1];
  a.pop();
}
function HE(a) {
  for (var t = new Array(a.length), e = 0; e < t.length; ++e)
    t[e] = a[e].listener || a[e];
  return t;
}
function VE(a, t) {
  return new Promise(function (e, n) {
    function i(o) {
      a.removeListener(t, r), n(o);
    }
    function r() {
      typeof a.removeListener == "function" && a.removeListener("error", i),
        e([].slice.call(arguments));
    }
    m_(a, t, r, { once: !0 }), t !== "error" && WE(a, i, { once: !0 });
  });
}
function WE(a, t, e) {
  typeof a.on == "function" && m_(a, "error", t, e);
}
function m_(a, t, e, n) {
  if (typeof a.on == "function") n.once ? a.once(t, e) : a.on(t, e);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(t, function i(r) {
      n.once && a.removeEventListener(t, i), e(r);
    });
  else
    throw new TypeError(
      'The "emitter" argument must be of type EventEmitter. Received type ' +
        typeof a
    );
}
var aF = mf.exports,
  g_ = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ (function (a, t) {
  (function () {
    var e,
      n = "4.17.21",
      i = 200,
      r = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
      o = "Expected a function",
      l = "Invalid `variable` option passed into `_.template`",
      u = "__lodash_hash_undefined__",
      h = 500,
      f = "__lodash_placeholder__",
      m = 1,
      g = 2,
      p = 4,
      v = 1,
      x = 2,
      b = 1,
      _ = 2,
      y = 4,
      E = 8,
      M = 16,
      A = 32,
      R = 64,
      T = 128,
      B = 256,
      X = 512,
      H = 30,
      O = "...",
      it = 800,
      W = 16,
      q = 1,
      tt = 2,
      V = 3,
      Q = 1 / 0,
      st = 9007199254740991,
      Lt = 17976931348623157e292,
      J = 0 / 0,
      vt = 4294967295,
      zt = vt - 1,
      ft = vt >>> 1,
      Mt = [
        ["ary", T],
        ["bind", b],
        ["bindKey", _],
        ["curry", E],
        ["curryRight", M],
        ["flip", X],
        ["partial", A],
        ["partialRight", R],
        ["rearg", B],
      ],
      Tt = "[object Arguments]",
      z = "[object Array]",
      F = "[object AsyncFunction]",
      U = "[object Boolean]",
      et = "[object Date]",
      dt = "[object DOMException]",
      gt = "[object Error]",
      j = "[object Function]",
      ot = "[object GeneratorFunction]",
      ct = "[object Map]",
      St = "[object Number]",
      xt = "[object Null]",
      I = "[object Object]",
      P = "[object Promise]",
      lt = "[object Proxy]",
      yt = "[object RegExp]",
      wt = "[object Set]",
      At = "[object String]",
      Ht = "[object Symbol]",
      Ut = "[object Undefined]",
      Vt = "[object WeakMap]",
      Nt = "[object WeakSet]",
      Y = "[object ArrayBuffer]",
      Ct = "[object DataView]",
      _t = "[object Float32Array]",
      Bt = "[object Float64Array]",
      Ft = "[object Int8Array]",
      ee = "[object Int16Array]",
      Be = "[object Int32Array]",
      He = "[object Uint8Array]",
      Te = "[object Uint8ClampedArray]",
      ve = "[object Uint16Array]",
      je = "[object Uint32Array]",
      rn = /\b__p \+= '';/g,
      hr = /\b(__p \+=) '' \+/g,
      Zi = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
      fr = /&(?:amp|lt|gt|quot|#39);/g,
      Hn = /[&<>"']/g,
      As = RegExp(fr.source),
      ro = RegExp(Hn.source),
      me = /<%-([\s\S]+?)%>/g,
      fe = /<%([\s\S]+?)%>/g,
      ge = /<%=([\s\S]+?)%>/g,
      de = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      _n = /^\w*$/,
      Kt =
        /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
      Ce = /[\\^$.*+?()[\]{}|]/g,
      Re = RegExp(Ce.source),
      D = /^\s+/,
      K = /\s/,
      at = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      nt = /\{\n\/\* \[wrapped with (.+)\] \*/,
      ut = /,? & /,
      Ot = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
      It = /[()=,{}\[\]\/\s]/,
      Gt = /\\(\\)?/g,
      $t = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
      Yt = /\w*$/,
      Wt = /^[-+]0x[0-9a-f]+$/i,
      Qt = /^0b[01]+$/i,
      Ee = /^\[object .+?Constructor\]$/,
      _i = /^0o[0-7]+$/i,
      oe = /^(?:0|[1-9]\d*)$/,
      dr = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
      xe = /($^)/,
      pr = /['\n\r\u2028\u2029\\]/g,
      vi = "\\ud800-\\udfff",
      mr = "\\u0300-\\u036f",
      ji = "\\ufe20-\\ufe2f",
      Ve = "\\u20d0-\\u20ff",
      Ur = mr + ji + Ve,
      Vn = "\\u2700-\\u27bf",
      Fp = "a-z\\xdf-\\xf6\\xf8-\\xff",
      Py = "\\xac\\xb1\\xd7\\xf7",
      Iy = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
      Dy = "\\u2000-\\u206f",
      Fy =
        " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
      Op = "A-Z\\xc0-\\xd6\\xd8-\\xde",
      Np = "\\ufe0e\\ufe0f",
      Bp = Py + Iy + Dy + Fy,
      rh = "['\u2019]",
      Oy = "[" + vi + "]",
      zp = "[" + Bp + "]",
      Hl = "[" + Ur + "]",
      Up = "\\d+",
      Ny = "[" + Vn + "]",
      kp = "[" + Fp + "]",
      Gp = "[^" + vi + Bp + Up + Vn + Fp + Op + "]",
      sh = "\\ud83c[\\udffb-\\udfff]",
      By = "(?:" + Hl + "|" + sh + ")",
      Hp = "[^" + vi + "]",
      oh = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      ah = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      so = "[" + Op + "]",
      Vp = "\\u200d",
      Wp = "(?:" + kp + "|" + Gp + ")",
      zy = "(?:" + so + "|" + Gp + ")",
      Xp = "(?:" + rh + "(?:d|ll|m|re|s|t|ve))?",
      Yp = "(?:" + rh + "(?:D|LL|M|RE|S|T|VE))?",
      qp = By + "?",
      Zp = "[" + Np + "]?",
      Uy = "(?:" + Vp + "(?:" + [Hp, oh, ah].join("|") + ")" + Zp + qp + ")*",
      ky = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
      Gy = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
      jp = Zp + qp + Uy,
      Hy = "(?:" + [Ny, oh, ah].join("|") + ")" + jp,
      Vy = "(?:" + [Hp + Hl + "?", Hl, oh, ah, Oy].join("|") + ")",
      Wy = RegExp(rh, "g"),
      Xy = RegExp(Hl, "g"),
      lh = RegExp(sh + "(?=" + sh + ")|" + Vy + jp, "g"),
      Yy = RegExp(
        [
          so + "?" + kp + "+" + Xp + "(?=" + [zp, so, "$"].join("|") + ")",
          zy + "+" + Yp + "(?=" + [zp, so + Wp, "$"].join("|") + ")",
          so + "?" + Wp + "+" + Xp,
          so + "+" + Yp,
          Gy,
          ky,
          Up,
          Hy,
        ].join("|"),
        "g"
      ),
      qy = RegExp("[" + Vp + vi + Ur + Np + "]"),
      Zy = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
      jy = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout",
      ],
      Jy = -1,
      ze = {};
    (ze[_t] =
      ze[Bt] =
      ze[Ft] =
      ze[ee] =
      ze[Be] =
      ze[He] =
      ze[Te] =
      ze[ve] =
      ze[je] =
        !0),
      (ze[Tt] =
        ze[z] =
        ze[Y] =
        ze[U] =
        ze[Ct] =
        ze[et] =
        ze[gt] =
        ze[j] =
        ze[ct] =
        ze[St] =
        ze[I] =
        ze[yt] =
        ze[wt] =
        ze[At] =
        ze[Vt] =
          !1);
    var Oe = {};
    (Oe[Tt] =
      Oe[z] =
      Oe[Y] =
      Oe[Ct] =
      Oe[U] =
      Oe[et] =
      Oe[_t] =
      Oe[Bt] =
      Oe[Ft] =
      Oe[ee] =
      Oe[Be] =
      Oe[ct] =
      Oe[St] =
      Oe[I] =
      Oe[yt] =
      Oe[wt] =
      Oe[At] =
      Oe[Ht] =
      Oe[He] =
      Oe[Te] =
      Oe[ve] =
      Oe[je] =
        !0),
      (Oe[gt] = Oe[j] = Oe[Vt] = !1);
    var $y = {
        À: "A",
        Á: "A",
        Â: "A",
        Ã: "A",
        Ä: "A",
        Å: "A",
        à: "a",
        á: "a",
        â: "a",
        ã: "a",
        ä: "a",
        å: "a",
        Ç: "C",
        ç: "c",
        Ð: "D",
        ð: "d",
        È: "E",
        É: "E",
        Ê: "E",
        Ë: "E",
        è: "e",
        é: "e",
        ê: "e",
        ë: "e",
        Ì: "I",
        Í: "I",
        Î: "I",
        Ï: "I",
        ì: "i",
        í: "i",
        î: "i",
        ï: "i",
        Ñ: "N",
        ñ: "n",
        Ò: "O",
        Ó: "O",
        Ô: "O",
        Õ: "O",
        Ö: "O",
        Ø: "O",
        ò: "o",
        ó: "o",
        ô: "o",
        õ: "o",
        ö: "o",
        ø: "o",
        Ù: "U",
        Ú: "U",
        Û: "U",
        Ü: "U",
        ù: "u",
        ú: "u",
        û: "u",
        ü: "u",
        Ý: "Y",
        ý: "y",
        ÿ: "y",
        Æ: "Ae",
        æ: "ae",
        Þ: "Th",
        þ: "th",
        ß: "ss",
        Ā: "A",
        Ă: "A",
        Ą: "A",
        ā: "a",
        ă: "a",
        ą: "a",
        Ć: "C",
        Ĉ: "C",
        Ċ: "C",
        Č: "C",
        ć: "c",
        ĉ: "c",
        ċ: "c",
        č: "c",
        Ď: "D",
        Đ: "D",
        ď: "d",
        đ: "d",
        Ē: "E",
        Ĕ: "E",
        Ė: "E",
        Ę: "E",
        Ě: "E",
        ē: "e",
        ĕ: "e",
        ė: "e",
        ę: "e",
        ě: "e",
        Ĝ: "G",
        Ğ: "G",
        Ġ: "G",
        Ģ: "G",
        ĝ: "g",
        ğ: "g",
        ġ: "g",
        ģ: "g",
        Ĥ: "H",
        Ħ: "H",
        ĥ: "h",
        ħ: "h",
        Ĩ: "I",
        Ī: "I",
        Ĭ: "I",
        Į: "I",
        İ: "I",
        ĩ: "i",
        ī: "i",
        ĭ: "i",
        į: "i",
        ı: "i",
        Ĵ: "J",
        ĵ: "j",
        Ķ: "K",
        ķ: "k",
        ĸ: "k",
        Ĺ: "L",
        Ļ: "L",
        Ľ: "L",
        Ŀ: "L",
        Ł: "L",
        ĺ: "l",
        ļ: "l",
        ľ: "l",
        ŀ: "l",
        ł: "l",
        Ń: "N",
        Ņ: "N",
        Ň: "N",
        Ŋ: "N",
        ń: "n",
        ņ: "n",
        ň: "n",
        ŋ: "n",
        Ō: "O",
        Ŏ: "O",
        Ő: "O",
        ō: "o",
        ŏ: "o",
        ő: "o",
        Ŕ: "R",
        Ŗ: "R",
        Ř: "R",
        ŕ: "r",
        ŗ: "r",
        ř: "r",
        Ś: "S",
        Ŝ: "S",
        Ş: "S",
        Š: "S",
        ś: "s",
        ŝ: "s",
        ş: "s",
        š: "s",
        Ţ: "T",
        Ť: "T",
        Ŧ: "T",
        ţ: "t",
        ť: "t",
        ŧ: "t",
        Ũ: "U",
        Ū: "U",
        Ŭ: "U",
        Ů: "U",
        Ű: "U",
        Ų: "U",
        ũ: "u",
        ū: "u",
        ŭ: "u",
        ů: "u",
        ű: "u",
        ų: "u",
        Ŵ: "W",
        ŵ: "w",
        Ŷ: "Y",
        ŷ: "y",
        Ÿ: "Y",
        Ź: "Z",
        Ż: "Z",
        Ž: "Z",
        ź: "z",
        ż: "z",
        ž: "z",
        Ĳ: "IJ",
        ĳ: "ij",
        Œ: "Oe",
        œ: "oe",
        ŉ: "'n",
        ſ: "s",
      },
      Ky = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
      },
      Qy = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'",
      },
      tw = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029",
      },
      ew = parseFloat,
      nw = parseInt,
      Jp = typeof Bs == "object" && Bs && Bs.Object === Object && Bs,
      iw = typeof self == "object" && self && self.Object === Object && self,
      vn = Jp || iw || Function("return this")(),
      ch = t && !t.nodeType && t,
      Ls = ch && !0 && a && !a.nodeType && a,
      $p = Ls && Ls.exports === ch,
      uh = $p && Jp.process,
      xi = (function () {
        try {
          var Z = Ls && Ls.require && Ls.require("util").types;
          return Z || (uh && uh.binding && uh.binding("util"));
        } catch {}
      })(),
      Kp = xi && xi.isArrayBuffer,
      Qp = xi && xi.isDate,
      tm = xi && xi.isMap,
      em = xi && xi.isRegExp,
      nm = xi && xi.isSet,
      im = xi && xi.isTypedArray;
    function ni(Z, ht, rt) {
      switch (rt.length) {
        case 0:
          return Z.call(ht);
        case 1:
          return Z.call(ht, rt[0]);
        case 2:
          return Z.call(ht, rt[0], rt[1]);
        case 3:
          return Z.call(ht, rt[0], rt[1], rt[2]);
      }
      return Z.apply(ht, rt);
    }
    function rw(Z, ht, rt, Dt) {
      for (var te = -1, _e = Z == null ? 0 : Z.length; ++te < _e; ) {
        var ln = Z[te];
        ht(Dt, ln, rt(ln), Z);
      }
      return Dt;
    }
    function yi(Z, ht) {
      for (
        var rt = -1, Dt = Z == null ? 0 : Z.length;
        ++rt < Dt && ht(Z[rt], rt, Z) !== !1;

      );
      return Z;
    }
    function sw(Z, ht) {
      for (
        var rt = Z == null ? 0 : Z.length;
        rt-- && ht(Z[rt], rt, Z) !== !1;

      );
      return Z;
    }
    function rm(Z, ht) {
      for (var rt = -1, Dt = Z == null ? 0 : Z.length; ++rt < Dt; )
        if (!ht(Z[rt], rt, Z)) return !1;
      return !0;
    }
    function kr(Z, ht) {
      for (
        var rt = -1, Dt = Z == null ? 0 : Z.length, te = 0, _e = [];
        ++rt < Dt;

      ) {
        var ln = Z[rt];
        ht(ln, rt, Z) && (_e[te++] = ln);
      }
      return _e;
    }
    function Vl(Z, ht) {
      var rt = Z == null ? 0 : Z.length;
      return !!rt && oo(Z, ht, 0) > -1;
    }
    function hh(Z, ht, rt) {
      for (var Dt = -1, te = Z == null ? 0 : Z.length; ++Dt < te; )
        if (rt(ht, Z[Dt])) return !0;
      return !1;
    }
    function We(Z, ht) {
      for (
        var rt = -1, Dt = Z == null ? 0 : Z.length, te = Array(Dt);
        ++rt < Dt;

      )
        te[rt] = ht(Z[rt], rt, Z);
      return te;
    }
    function Gr(Z, ht) {
      for (var rt = -1, Dt = ht.length, te = Z.length; ++rt < Dt; )
        Z[te + rt] = ht[rt];
      return Z;
    }
    function fh(Z, ht, rt, Dt) {
      var te = -1,
        _e = Z == null ? 0 : Z.length;
      for (Dt && _e && (rt = Z[++te]); ++te < _e; ) rt = ht(rt, Z[te], te, Z);
      return rt;
    }
    function ow(Z, ht, rt, Dt) {
      var te = Z == null ? 0 : Z.length;
      for (Dt && te && (rt = Z[--te]); te--; ) rt = ht(rt, Z[te], te, Z);
      return rt;
    }
    function dh(Z, ht) {
      for (var rt = -1, Dt = Z == null ? 0 : Z.length; ++rt < Dt; )
        if (ht(Z[rt], rt, Z)) return !0;
      return !1;
    }
    var aw = ph("length");
    function lw(Z) {
      return Z.split("");
    }
    function cw(Z) {
      return Z.match(Ot) || [];
    }
    function sm(Z, ht, rt) {
      var Dt;
      return (
        rt(Z, function (te, _e, ln) {
          if (ht(te, _e, ln)) return (Dt = _e), !1;
        }),
        Dt
      );
    }
    function Wl(Z, ht, rt, Dt) {
      for (var te = Z.length, _e = rt + (Dt ? 1 : -1); Dt ? _e-- : ++_e < te; )
        if (ht(Z[_e], _e, Z)) return _e;
      return -1;
    }
    function oo(Z, ht, rt) {
      return ht === ht ? ww(Z, ht, rt) : Wl(Z, om, rt);
    }
    function uw(Z, ht, rt, Dt) {
      for (var te = rt - 1, _e = Z.length; ++te < _e; )
        if (Dt(Z[te], ht)) return te;
      return -1;
    }
    function om(Z) {
      return Z !== Z;
    }
    function am(Z, ht) {
      var rt = Z == null ? 0 : Z.length;
      return rt ? gh(Z, ht) / rt : J;
    }
    function ph(Z) {
      return function (ht) {
        return ht == null ? e : ht[Z];
      };
    }
    function mh(Z) {
      return function (ht) {
        return Z == null ? e : Z[ht];
      };
    }
    function lm(Z, ht, rt, Dt, te) {
      return (
        te(Z, function (_e, ln, Pe) {
          rt = Dt ? ((Dt = !1), _e) : ht(rt, _e, ln, Pe);
        }),
        rt
      );
    }
    function hw(Z, ht) {
      var rt = Z.length;
      for (Z.sort(ht); rt--; ) Z[rt] = Z[rt].value;
      return Z;
    }
    function gh(Z, ht) {
      for (var rt, Dt = -1, te = Z.length; ++Dt < te; ) {
        var _e = ht(Z[Dt]);
        _e !== e && (rt = rt === e ? _e : rt + _e);
      }
      return rt;
    }
    function _h(Z, ht) {
      for (var rt = -1, Dt = Array(Z); ++rt < Z; ) Dt[rt] = ht(rt);
      return Dt;
    }
    function fw(Z, ht) {
      return We(ht, function (rt) {
        return [rt, Z[rt]];
      });
    }
    function cm(Z) {
      return Z && Z.slice(0, dm(Z) + 1).replace(D, "");
    }
    function ii(Z) {
      return function (ht) {
        return Z(ht);
      };
    }
    function vh(Z, ht) {
      return We(ht, function (rt) {
        return Z[rt];
      });
    }
    function Ra(Z, ht) {
      return Z.has(ht);
    }
    function um(Z, ht) {
      for (var rt = -1, Dt = Z.length; ++rt < Dt && oo(ht, Z[rt], 0) > -1; );
      return rt;
    }
    function hm(Z, ht) {
      for (var rt = Z.length; rt-- && oo(ht, Z[rt], 0) > -1; );
      return rt;
    }
    function dw(Z, ht) {
      for (var rt = Z.length, Dt = 0; rt--; ) Z[rt] === ht && ++Dt;
      return Dt;
    }
    var pw = mh($y),
      mw = mh(Ky);
    function gw(Z) {
      return "\\" + tw[Z];
    }
    function _w(Z, ht) {
      return Z == null ? e : Z[ht];
    }
    function ao(Z) {
      return qy.test(Z);
    }
    function vw(Z) {
      return Zy.test(Z);
    }
    function xw(Z) {
      for (var ht, rt = []; !(ht = Z.next()).done; ) rt.push(ht.value);
      return rt;
    }
    function xh(Z) {
      var ht = -1,
        rt = Array(Z.size);
      return (
        Z.forEach(function (Dt, te) {
          rt[++ht] = [te, Dt];
        }),
        rt
      );
    }
    function fm(Z, ht) {
      return function (rt) {
        return Z(ht(rt));
      };
    }
    function Hr(Z, ht) {
      for (var rt = -1, Dt = Z.length, te = 0, _e = []; ++rt < Dt; ) {
        var ln = Z[rt];
        (ln === ht || ln === f) && ((Z[rt] = f), (_e[te++] = rt));
      }
      return _e;
    }
    function Xl(Z) {
      var ht = -1,
        rt = Array(Z.size);
      return (
        Z.forEach(function (Dt) {
          rt[++ht] = Dt;
        }),
        rt
      );
    }
    function yw(Z) {
      var ht = -1,
        rt = Array(Z.size);
      return (
        Z.forEach(function (Dt) {
          rt[++ht] = [Dt, Dt];
        }),
        rt
      );
    }
    function ww(Z, ht, rt) {
      for (var Dt = rt - 1, te = Z.length; ++Dt < te; )
        if (Z[Dt] === ht) return Dt;
      return -1;
    }
    function bw(Z, ht, rt) {
      for (var Dt = rt + 1; Dt--; ) if (Z[Dt] === ht) return Dt;
      return Dt;
    }
    function lo(Z) {
      return ao(Z) ? Sw(Z) : aw(Z);
    }
    function zi(Z) {
      return ao(Z) ? Tw(Z) : lw(Z);
    }
    function dm(Z) {
      for (var ht = Z.length; ht-- && K.test(Z.charAt(ht)); );
      return ht;
    }
    var Mw = mh(Qy);
    function Sw(Z) {
      for (var ht = (lh.lastIndex = 0); lh.test(Z); ) ++ht;
      return ht;
    }
    function Tw(Z) {
      return Z.match(lh) || [];
    }
    function Ew(Z) {
      return Z.match(Yy) || [];
    }
    var Aw = function Z(ht) {
        ht = ht == null ? vn : co.defaults(vn.Object(), ht, co.pick(vn, jy));
        var rt = ht.Array,
          Dt = ht.Date,
          te = ht.Error,
          _e = ht.Function,
          ln = ht.Math,
          Pe = ht.Object,
          yh = ht.RegExp,
          Lw = ht.String,
          wi = ht.TypeError,
          Yl = rt.prototype,
          Cw = _e.prototype,
          uo = Pe.prototype,
          ql = ht["__core-js_shared__"],
          Zl = Cw.toString,
          be = uo.hasOwnProperty,
          Rw = 0,
          pm = (function () {
            var s = /[^.]+$/.exec((ql && ql.keys && ql.keys.IE_PROTO) || "");
            return s ? "Symbol(src)_1." + s : "";
          })(),
          jl = uo.toString,
          Pw = Zl.call(Pe),
          Iw = vn._,
          Dw = yh(
            "^" +
              Zl.call(be)
                .replace(Ce, "\\$&")
                .replace(
                  /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                  "$1.*?"
                ) +
              "$"
          ),
          Jl = $p ? ht.Buffer : e,
          Vr = ht.Symbol,
          $l = ht.Uint8Array,
          mm = Jl ? Jl.allocUnsafe : e,
          Kl = fm(Pe.getPrototypeOf, Pe),
          gm = Pe.create,
          _m = uo.propertyIsEnumerable,
          Ql = Yl.splice,
          vm = Vr ? Vr.isConcatSpreadable : e,
          Pa = Vr ? Vr.iterator : e,
          Cs = Vr ? Vr.toStringTag : e,
          tc = (function () {
            try {
              var s = Fs(Pe, "defineProperty");
              return s({}, "", {}), s;
            } catch {}
          })(),
          Fw = ht.clearTimeout !== vn.clearTimeout && ht.clearTimeout,
          Ow = Dt && Dt.now !== vn.Date.now && Dt.now,
          Nw = ht.setTimeout !== vn.setTimeout && ht.setTimeout,
          ec = ln.ceil,
          nc = ln.floor,
          wh = Pe.getOwnPropertySymbols,
          Bw = Jl ? Jl.isBuffer : e,
          xm = ht.isFinite,
          zw = Yl.join,
          Uw = fm(Pe.keys, Pe),
          cn = ln.max,
          Tn = ln.min,
          kw = Dt.now,
          Gw = ht.parseInt,
          ym = ln.random,
          Hw = Yl.reverse,
          bh = Fs(ht, "DataView"),
          Ia = Fs(ht, "Map"),
          Mh = Fs(ht, "Promise"),
          ho = Fs(ht, "Set"),
          Da = Fs(ht, "WeakMap"),
          Fa = Fs(Pe, "create"),
          ic = Da && new Da(),
          fo = {},
          Vw = Os(bh),
          Ww = Os(Ia),
          Xw = Os(Mh),
          Yw = Os(ho),
          qw = Os(Da),
          rc = Vr ? Vr.prototype : e,
          Oa = rc ? rc.valueOf : e,
          wm = rc ? rc.toString : e;
        function L(s) {
          if (Je(s) && !ne(s) && !(s instanceof ue)) {
            if (s instanceof bi) return s;
            if (be.call(s, "__wrapped__")) return bg(s);
          }
          return new bi(s);
        }
        var po = (function () {
          function s() {}
          return function (c) {
            if (!Ye(c)) return {};
            if (gm) return gm(c);
            s.prototype = c;
            var d = new s();
            return (s.prototype = e), d;
          };
        })();
        function sc() {}
        function bi(s, c) {
          (this.__wrapped__ = s),
            (this.__actions__ = []),
            (this.__chain__ = !!c),
            (this.__index__ = 0),
            (this.__values__ = e);
        }
        (L.templateSettings = {
          escape: me,
          evaluate: fe,
          interpolate: ge,
          variable: "",
          imports: { _: L },
        }),
          (L.prototype = sc.prototype),
          (L.prototype.constructor = L),
          (bi.prototype = po(sc.prototype)),
          (bi.prototype.constructor = bi);
        function ue(s) {
          (this.__wrapped__ = s),
            (this.__actions__ = []),
            (this.__dir__ = 1),
            (this.__filtered__ = !1),
            (this.__iteratees__ = []),
            (this.__takeCount__ = vt),
            (this.__views__ = []);
        }
        function Zw() {
          var s = new ue(this.__wrapped__);
          return (
            (s.__actions__ = Wn(this.__actions__)),
            (s.__dir__ = this.__dir__),
            (s.__filtered__ = this.__filtered__),
            (s.__iteratees__ = Wn(this.__iteratees__)),
            (s.__takeCount__ = this.__takeCount__),
            (s.__views__ = Wn(this.__views__)),
            s
          );
        }
        function jw() {
          if (this.__filtered__) {
            var s = new ue(this);
            (s.__dir__ = -1), (s.__filtered__ = !0);
          } else (s = this.clone()), (s.__dir__ *= -1);
          return s;
        }
        function Jw() {
          var s = this.__wrapped__.value(),
            c = this.__dir__,
            d = ne(s),
            w = c < 0,
            S = d ? s.length : 0,
            C = lM(0, S, this.__views__),
            N = C.start,
            G = C.end,
            $ = G - N,
            pt = w ? G : N - 1,
            mt = this.__iteratees__,
            bt = mt.length,
            Rt = 0,
            kt = Tn($, this.__takeCount__);
          if (!d || (!w && S == $ && kt == $)) return Xm(s, this.__actions__);
          var Zt = [];
          t: for (; $-- && Rt < kt; ) {
            pt += c;
            for (var se = -1, jt = s[pt]; ++se < bt; ) {
              var le = mt[se],
                he = le.iteratee,
                oi = le.type,
                On = he(jt);
              if (oi == tt) jt = On;
              else if (!On) {
                if (oi == q) continue t;
                break t;
              }
            }
            Zt[Rt++] = jt;
          }
          return Zt;
        }
        (ue.prototype = po(sc.prototype)), (ue.prototype.constructor = ue);
        function Rs(s) {
          var c = -1,
            d = s == null ? 0 : s.length;
          for (this.clear(); ++c < d; ) {
            var w = s[c];
            this.set(w[0], w[1]);
          }
        }
        function $w() {
          (this.__data__ = Fa ? Fa(null) : {}), (this.size = 0);
        }
        function Kw(s) {
          var c = this.has(s) && delete this.__data__[s];
          return (this.size -= c ? 1 : 0), c;
        }
        function Qw(s) {
          var c = this.__data__;
          if (Fa) {
            var d = c[s];
            return d === u ? e : d;
          }
          return be.call(c, s) ? c[s] : e;
        }
        function tb(s) {
          var c = this.__data__;
          return Fa ? c[s] !== e : be.call(c, s);
        }
        function eb(s, c) {
          var d = this.__data__;
          return (
            (this.size += this.has(s) ? 0 : 1),
            (d[s] = Fa && c === e ? u : c),
            this
          );
        }
        (Rs.prototype.clear = $w),
          (Rs.prototype.delete = Kw),
          (Rs.prototype.get = Qw),
          (Rs.prototype.has = tb),
          (Rs.prototype.set = eb);
        function gr(s) {
          var c = -1,
            d = s == null ? 0 : s.length;
          for (this.clear(); ++c < d; ) {
            var w = s[c];
            this.set(w[0], w[1]);
          }
        }
        function nb() {
          (this.__data__ = []), (this.size = 0);
        }
        function ib(s) {
          var c = this.__data__,
            d = oc(c, s);
          if (d < 0) return !1;
          var w = c.length - 1;
          return d == w ? c.pop() : Ql.call(c, d, 1), --this.size, !0;
        }
        function rb(s) {
          var c = this.__data__,
            d = oc(c, s);
          return d < 0 ? e : c[d][1];
        }
        function sb(s) {
          return oc(this.__data__, s) > -1;
        }
        function ob(s, c) {
          var d = this.__data__,
            w = oc(d, s);
          return w < 0 ? (++this.size, d.push([s, c])) : (d[w][1] = c), this;
        }
        (gr.prototype.clear = nb),
          (gr.prototype.delete = ib),
          (gr.prototype.get = rb),
          (gr.prototype.has = sb),
          (gr.prototype.set = ob);
        function _r(s) {
          var c = -1,
            d = s == null ? 0 : s.length;
          for (this.clear(); ++c < d; ) {
            var w = s[c];
            this.set(w[0], w[1]);
          }
        }
        function ab() {
          (this.size = 0),
            (this.__data__ = {
              hash: new Rs(),
              map: new (Ia || gr)(),
              string: new Rs(),
            });
        }
        function lb(s) {
          var c = vc(this, s).delete(s);
          return (this.size -= c ? 1 : 0), c;
        }
        function cb(s) {
          return vc(this, s).get(s);
        }
        function ub(s) {
          return vc(this, s).has(s);
        }
        function hb(s, c) {
          var d = vc(this, s),
            w = d.size;
          return d.set(s, c), (this.size += d.size == w ? 0 : 1), this;
        }
        (_r.prototype.clear = ab),
          (_r.prototype.delete = lb),
          (_r.prototype.get = cb),
          (_r.prototype.has = ub),
          (_r.prototype.set = hb);
        function Ps(s) {
          var c = -1,
            d = s == null ? 0 : s.length;
          for (this.__data__ = new _r(); ++c < d; ) this.add(s[c]);
        }
        function fb(s) {
          return this.__data__.set(s, u), this;
        }
        function db(s) {
          return this.__data__.has(s);
        }
        (Ps.prototype.add = Ps.prototype.push = fb), (Ps.prototype.has = db);
        function Ui(s) {
          var c = (this.__data__ = new gr(s));
          this.size = c.size;
        }
        function pb() {
          (this.__data__ = new gr()), (this.size = 0);
        }
        function mb(s) {
          var c = this.__data__,
            d = c.delete(s);
          return (this.size = c.size), d;
        }
        function gb(s) {
          return this.__data__.get(s);
        }
        function _b(s) {
          return this.__data__.has(s);
        }
        function vb(s, c) {
          var d = this.__data__;
          if (d instanceof gr) {
            var w = d.__data__;
            if (!Ia || w.length < i - 1)
              return w.push([s, c]), (this.size = ++d.size), this;
            d = this.__data__ = new _r(w);
          }
          return d.set(s, c), (this.size = d.size), this;
        }
        (Ui.prototype.clear = pb),
          (Ui.prototype.delete = mb),
          (Ui.prototype.get = gb),
          (Ui.prototype.has = _b),
          (Ui.prototype.set = vb);
        function bm(s, c) {
          var d = ne(s),
            w = !d && Ns(s),
            S = !d && !w && Zr(s),
            C = !d && !w && !S && vo(s),
            N = d || w || S || C,
            G = N ? _h(s.length, Lw) : [],
            $ = G.length;
          for (var pt in s)
            (c || be.call(s, pt)) &&
              !(
                N &&
                (pt == "length" ||
                  (S && (pt == "offset" || pt == "parent")) ||
                  (C &&
                    (pt == "buffer" ||
                      pt == "byteLength" ||
                      pt == "byteOffset")) ||
                  wr(pt, $))
              ) &&
              G.push(pt);
          return G;
        }
        function Mm(s) {
          var c = s.length;
          return c ? s[Fh(0, c - 1)] : e;
        }
        function xb(s, c) {
          return xc(Wn(s), Is(c, 0, s.length));
        }
        function yb(s) {
          return xc(Wn(s));
        }
        function Sh(s, c, d) {
          ((d !== e && !ki(s[c], d)) || (d === e && !(c in s))) && vr(s, c, d);
        }
        function Na(s, c, d) {
          var w = s[c];
          (!(be.call(s, c) && ki(w, d)) || (d === e && !(c in s))) &&
            vr(s, c, d);
        }
        function oc(s, c) {
          for (var d = s.length; d--; ) if (ki(s[d][0], c)) return d;
          return -1;
        }
        function wb(s, c, d, w) {
          return (
            Wr(s, function (S, C, N) {
              c(w, S, d(S), N);
            }),
            w
          );
        }
        function Sm(s, c) {
          return s && $i(c, fn(c), s);
        }
        function bb(s, c) {
          return s && $i(c, Yn(c), s);
        }
        function vr(s, c, d) {
          c == "__proto__" && tc
            ? tc(s, c, {
                configurable: !0,
                enumerable: !0,
                value: d,
                writable: !0,
              })
            : (s[c] = d);
        }
        function Th(s, c) {
          for (var d = -1, w = c.length, S = rt(w), C = s == null; ++d < w; )
            S[d] = C ? e : of(s, c[d]);
          return S;
        }
        function Is(s, c, d) {
          return (
            s === s &&
              (d !== e && (s = s <= d ? s : d),
              c !== e && (s = s >= c ? s : c)),
            s
          );
        }
        function Mi(s, c, d, w, S, C) {
          var N,
            G = c & m,
            $ = c & g,
            pt = c & p;
          if ((d && (N = S ? d(s, w, S, C) : d(s)), N !== e)) return N;
          if (!Ye(s)) return s;
          var mt = ne(s);
          if (mt) {
            if (((N = uM(s)), !G)) return Wn(s, N);
          } else {
            var bt = En(s),
              Rt = bt == j || bt == ot;
            if (Zr(s)) return Zm(s, G);
            if (bt == I || bt == Tt || (Rt && !S)) {
              if (((N = $ || Rt ? {} : dg(s)), !G))
                return $ ? Qb(s, bb(N, s)) : Kb(s, Sm(N, s));
            } else {
              if (!Oe[bt]) return S ? s : {};
              N = hM(s, bt, G);
            }
          }
          C || (C = new Ui());
          var kt = C.get(s);
          if (kt) return kt;
          C.set(s, N),
            Hg(s)
              ? s.forEach(function (jt) {
                  N.add(Mi(jt, c, d, jt, s, C));
                })
              : kg(s) &&
                s.forEach(function (jt, le) {
                  N.set(le, Mi(jt, c, d, le, s, C));
                });
          var Zt = pt ? ($ ? Xh : Wh) : $ ? Yn : fn,
            se = mt ? e : Zt(s);
          return (
            yi(se || s, function (jt, le) {
              se && ((le = jt), (jt = s[le])),
                Na(N, le, Mi(jt, c, d, le, s, C));
            }),
            N
          );
        }
        function Mb(s) {
          var c = fn(s);
          return function (d) {
            return Tm(d, s, c);
          };
        }
        function Tm(s, c, d) {
          var w = d.length;
          if (s == null) return !w;
          for (s = Pe(s); w--; ) {
            var S = d[w],
              C = c[S],
              N = s[S];
            if ((N === e && !(S in s)) || !C(N)) return !1;
          }
          return !0;
        }
        function Em(s, c, d) {
          if (typeof s != "function") throw new wi(o);
          return Va(function () {
            s.apply(e, d);
          }, c);
        }
        function Ba(s, c, d, w) {
          var S = -1,
            C = Vl,
            N = !0,
            G = s.length,
            $ = [],
            pt = c.length;
          if (!G) return $;
          d && (c = We(c, ii(d))),
            w
              ? ((C = hh), (N = !1))
              : c.length >= i && ((C = Ra), (N = !1), (c = new Ps(c)));
          t: for (; ++S < G; ) {
            var mt = s[S],
              bt = d == null ? mt : d(mt);
            if (((mt = w || mt !== 0 ? mt : 0), N && bt === bt)) {
              for (var Rt = pt; Rt--; ) if (c[Rt] === bt) continue t;
              $.push(mt);
            } else C(c, bt, w) || $.push(mt);
          }
          return $;
        }
        var Wr = Qm(Ji),
          Am = Qm(Ah, !0);
        function Sb(s, c) {
          var d = !0;
          return (
            Wr(s, function (w, S, C) {
              return (d = !!c(w, S, C)), d;
            }),
            d
          );
        }
        function ac(s, c, d) {
          for (var w = -1, S = s.length; ++w < S; ) {
            var C = s[w],
              N = c(C);
            if (N != null && (G === e ? N === N && !si(N) : d(N, G)))
              var G = N,
                $ = C;
          }
          return $;
        }
        function Tb(s, c, d, w) {
          var S = s.length;
          for (
            d = ie(d),
              d < 0 && (d = -d > S ? 0 : S + d),
              w = w === e || w > S ? S : ie(w),
              w < 0 && (w += S),
              w = d > w ? 0 : Wg(w);
            d < w;

          )
            s[d++] = c;
          return s;
        }
        function Lm(s, c) {
          var d = [];
          return (
            Wr(s, function (w, S, C) {
              c(w, S, C) && d.push(w);
            }),
            d
          );
        }
        function xn(s, c, d, w, S) {
          var C = -1,
            N = s.length;
          for (d || (d = dM), S || (S = []); ++C < N; ) {
            var G = s[C];
            c > 0 && d(G)
              ? c > 1
                ? xn(G, c - 1, d, w, S)
                : Gr(S, G)
              : w || (S[S.length] = G);
          }
          return S;
        }
        var Eh = tg(),
          Cm = tg(!0);
        function Ji(s, c) {
          return s && Eh(s, c, fn);
        }
        function Ah(s, c) {
          return s && Cm(s, c, fn);
        }
        function lc(s, c) {
          return kr(c, function (d) {
            return br(s[d]);
          });
        }
        function Ds(s, c) {
          c = Yr(c, s);
          for (var d = 0, w = c.length; s != null && d < w; ) s = s[Ki(c[d++])];
          return d && d == w ? s : e;
        }
        function Rm(s, c, d) {
          var w = c(s);
          return ne(s) ? w : Gr(w, d(s));
        }
        function Dn(s) {
          return s == null
            ? s === e
              ? Ut
              : xt
            : Cs && Cs in Pe(s)
            ? aM(s)
            : yM(s);
        }
        function Lh(s, c) {
          return s > c;
        }
        function Eb(s, c) {
          return s != null && be.call(s, c);
        }
        function Ab(s, c) {
          return s != null && c in Pe(s);
        }
        function Lb(s, c, d) {
          return s >= Tn(c, d) && s < cn(c, d);
        }
        function Ch(s, c, d) {
          for (
            var w = d ? hh : Vl,
              S = s[0].length,
              C = s.length,
              N = C,
              G = rt(C),
              $ = 1 / 0,
              pt = [];
            N--;

          ) {
            var mt = s[N];
            N && c && (mt = We(mt, ii(c))),
              ($ = Tn(mt.length, $)),
              (G[N] =
                !d && (c || (S >= 120 && mt.length >= 120))
                  ? new Ps(N && mt)
                  : e);
          }
          mt = s[0];
          var bt = -1,
            Rt = G[0];
          t: for (; ++bt < S && pt.length < $; ) {
            var kt = mt[bt],
              Zt = c ? c(kt) : kt;
            if (
              ((kt = d || kt !== 0 ? kt : 0), !(Rt ? Ra(Rt, Zt) : w(pt, Zt, d)))
            ) {
              for (N = C; --N; ) {
                var se = G[N];
                if (!(se ? Ra(se, Zt) : w(s[N], Zt, d))) continue t;
              }
              Rt && Rt.push(Zt), pt.push(kt);
            }
          }
          return pt;
        }
        function Cb(s, c, d, w) {
          return (
            Ji(s, function (S, C, N) {
              c(w, d(S), C, N);
            }),
            w
          );
        }
        function za(s, c, d) {
          (c = Yr(c, s)), (s = _g(s, c));
          var w = s == null ? s : s[Ki(Ti(c))];
          return w == null ? e : ni(w, s, d);
        }
        function Pm(s) {
          return Je(s) && Dn(s) == Tt;
        }
        function Rb(s) {
          return Je(s) && Dn(s) == Y;
        }
        function Pb(s) {
          return Je(s) && Dn(s) == et;
        }
        function Ua(s, c, d, w, S) {
          return s === c
            ? !0
            : s == null || c == null || (!Je(s) && !Je(c))
            ? s !== s && c !== c
            : Ib(s, c, d, w, Ua, S);
        }
        function Ib(s, c, d, w, S, C) {
          var N = ne(s),
            G = ne(c),
            $ = N ? z : En(s),
            pt = G ? z : En(c);
          ($ = $ == Tt ? I : $), (pt = pt == Tt ? I : pt);
          var mt = $ == I,
            bt = pt == I,
            Rt = $ == pt;
          if (Rt && Zr(s)) {
            if (!Zr(c)) return !1;
            (N = !0), (mt = !1);
          }
          if (Rt && !mt)
            return (
              C || (C = new Ui()),
              N || vo(s) ? ug(s, c, d, w, S, C) : sM(s, c, $, d, w, S, C)
            );
          if (!(d & v)) {
            var kt = mt && be.call(s, "__wrapped__"),
              Zt = bt && be.call(c, "__wrapped__");
            if (kt || Zt) {
              var se = kt ? s.value() : s,
                jt = Zt ? c.value() : c;
              return C || (C = new Ui()), S(se, jt, d, w, C);
            }
          }
          return Rt ? (C || (C = new Ui()), oM(s, c, d, w, S, C)) : !1;
        }
        function Db(s) {
          return Je(s) && En(s) == ct;
        }
        function Rh(s, c, d, w) {
          var S = d.length,
            C = S,
            N = !w;
          if (s == null) return !C;
          for (s = Pe(s); S--; ) {
            var G = d[S];
            if (N && G[2] ? G[1] !== s[G[0]] : !(G[0] in s)) return !1;
          }
          for (; ++S < C; ) {
            G = d[S];
            var $ = G[0],
              pt = s[$],
              mt = G[1];
            if (N && G[2]) {
              if (pt === e && !($ in s)) return !1;
            } else {
              var bt = new Ui();
              if (w) var Rt = w(pt, mt, $, s, c, bt);
              if (!(Rt === e ? Ua(mt, pt, v | x, w, bt) : Rt)) return !1;
            }
          }
          return !0;
        }
        function Im(s) {
          if (!Ye(s) || mM(s)) return !1;
          var c = br(s) ? Dw : Ee;
          return c.test(Os(s));
        }
        function Fb(s) {
          return Je(s) && Dn(s) == yt;
        }
        function Ob(s) {
          return Je(s) && En(s) == wt;
        }
        function Nb(s) {
          return Je(s) && Tc(s.length) && !!ze[Dn(s)];
        }
        function Dm(s) {
          return typeof s == "function"
            ? s
            : s == null
            ? qn
            : typeof s == "object"
            ? ne(s)
              ? Nm(s[0], s[1])
              : Om(s)
            : e_(s);
        }
        function Ph(s) {
          if (!Ha(s)) return Uw(s);
          var c = [];
          for (var d in Pe(s)) be.call(s, d) && d != "constructor" && c.push(d);
          return c;
        }
        function Bb(s) {
          if (!Ye(s)) return xM(s);
          var c = Ha(s),
            d = [];
          for (var w in s)
            (w == "constructor" && (c || !be.call(s, w))) || d.push(w);
          return d;
        }
        function Ih(s, c) {
          return s < c;
        }
        function Fm(s, c) {
          var d = -1,
            w = Xn(s) ? rt(s.length) : [];
          return (
            Wr(s, function (S, C, N) {
              w[++d] = c(S, C, N);
            }),
            w
          );
        }
        function Om(s) {
          var c = qh(s);
          return c.length == 1 && c[0][2]
            ? mg(c[0][0], c[0][1])
            : function (d) {
                return d === s || Rh(d, s, c);
              };
        }
        function Nm(s, c) {
          return jh(s) && pg(c)
            ? mg(Ki(s), c)
            : function (d) {
                var w = of(d, s);
                return w === e && w === c ? af(d, s) : Ua(c, w, v | x);
              };
        }
        function cc(s, c, d, w, S) {
          s !== c &&
            Eh(
              c,
              function (C, N) {
                if ((S || (S = new Ui()), Ye(C))) zb(s, c, N, d, cc, w, S);
                else {
                  var G = w ? w($h(s, N), C, N + "", s, c, S) : e;
                  G === e && (G = C), Sh(s, N, G);
                }
              },
              Yn
            );
        }
        function zb(s, c, d, w, S, C, N) {
          var G = $h(s, d),
            $ = $h(c, d),
            pt = N.get($);
          if (pt) {
            Sh(s, d, pt);
            return;
          }
          var mt = C ? C(G, $, d + "", s, c, N) : e,
            bt = mt === e;
          if (bt) {
            var Rt = ne($),
              kt = !Rt && Zr($),
              Zt = !Rt && !kt && vo($);
            (mt = $),
              Rt || kt || Zt
                ? ne(G)
                  ? (mt = G)
                  : Ke(G)
                  ? (mt = Wn(G))
                  : kt
                  ? ((bt = !1), (mt = Zm($, !0)))
                  : Zt
                  ? ((bt = !1), (mt = jm($, !0)))
                  : (mt = [])
                : Wa($) || Ns($)
                ? ((mt = G),
                  Ns(G) ? (mt = Xg(G)) : (!Ye(G) || br(G)) && (mt = dg($)))
                : (bt = !1);
          }
          bt && (N.set($, mt), S(mt, $, w, C, N), N.delete($)), Sh(s, d, mt);
        }
        function Bm(s, c) {
          var d = s.length;
          if (!!d) return (c += c < 0 ? d : 0), wr(c, d) ? s[c] : e;
        }
        function zm(s, c, d) {
          c.length
            ? (c = We(c, function (C) {
                return ne(C)
                  ? function (N) {
                      return Ds(N, C.length === 1 ? C[0] : C);
                    }
                  : C;
              }))
            : (c = [qn]);
          var w = -1;
          c = We(c, ii(qt()));
          var S = Fm(s, function (C, N, G) {
            var $ = We(c, function (pt) {
              return pt(C);
            });
            return { criteria: $, index: ++w, value: C };
          });
          return hw(S, function (C, N) {
            return $b(C, N, d);
          });
        }
        function Ub(s, c) {
          return Um(s, c, function (d, w) {
            return af(s, w);
          });
        }
        function Um(s, c, d) {
          for (var w = -1, S = c.length, C = {}; ++w < S; ) {
            var N = c[w],
              G = Ds(s, N);
            d(G, N) && ka(C, Yr(N, s), G);
          }
          return C;
        }
        function kb(s) {
          return function (c) {
            return Ds(c, s);
          };
        }
        function Dh(s, c, d, w) {
          var S = w ? uw : oo,
            C = -1,
            N = c.length,
            G = s;
          for (s === c && (c = Wn(c)), d && (G = We(s, ii(d))); ++C < N; )
            for (
              var $ = 0, pt = c[C], mt = d ? d(pt) : pt;
              ($ = S(G, mt, $, w)) > -1;

            )
              G !== s && Ql.call(G, $, 1), Ql.call(s, $, 1);
          return s;
        }
        function km(s, c) {
          for (var d = s ? c.length : 0, w = d - 1; d--; ) {
            var S = c[d];
            if (d == w || S !== C) {
              var C = S;
              wr(S) ? Ql.call(s, S, 1) : Bh(s, S);
            }
          }
          return s;
        }
        function Fh(s, c) {
          return s + nc(ym() * (c - s + 1));
        }
        function Gb(s, c, d, w) {
          for (var S = -1, C = cn(ec((c - s) / (d || 1)), 0), N = rt(C); C--; )
            (N[w ? C : ++S] = s), (s += d);
          return N;
        }
        function Oh(s, c) {
          var d = "";
          if (!s || c < 1 || c > st) return d;
          do c % 2 && (d += s), (c = nc(c / 2)), c && (s += s);
          while (c);
          return d;
        }
        function ae(s, c) {
          return Kh(gg(s, c, qn), s + "");
        }
        function Hb(s) {
          return Mm(xo(s));
        }
        function Vb(s, c) {
          var d = xo(s);
          return xc(d, Is(c, 0, d.length));
        }
        function ka(s, c, d, w) {
          if (!Ye(s)) return s;
          c = Yr(c, s);
          for (
            var S = -1, C = c.length, N = C - 1, G = s;
            G != null && ++S < C;

          ) {
            var $ = Ki(c[S]),
              pt = d;
            if ($ === "__proto__" || $ === "constructor" || $ === "prototype")
              return s;
            if (S != N) {
              var mt = G[$];
              (pt = w ? w(mt, $, G) : e),
                pt === e && (pt = Ye(mt) ? mt : wr(c[S + 1]) ? [] : {});
            }
            Na(G, $, pt), (G = G[$]);
          }
          return s;
        }
        var Gm = ic
            ? function (s, c) {
                return ic.set(s, c), s;
              }
            : qn,
          Wb = tc
            ? function (s, c) {
                return tc(s, "toString", {
                  configurable: !0,
                  enumerable: !1,
                  value: cf(c),
                  writable: !0,
                });
              }
            : qn;
        function Xb(s) {
          return xc(xo(s));
        }
        function Si(s, c, d) {
          var w = -1,
            S = s.length;
          c < 0 && (c = -c > S ? 0 : S + c),
            (d = d > S ? S : d),
            d < 0 && (d += S),
            (S = c > d ? 0 : (d - c) >>> 0),
            (c >>>= 0);
          for (var C = rt(S); ++w < S; ) C[w] = s[w + c];
          return C;
        }
        function Yb(s, c) {
          var d;
          return (
            Wr(s, function (w, S, C) {
              return (d = c(w, S, C)), !d;
            }),
            !!d
          );
        }
        function uc(s, c, d) {
          var w = 0,
            S = s == null ? w : s.length;
          if (typeof c == "number" && c === c && S <= ft) {
            for (; w < S; ) {
              var C = (w + S) >>> 1,
                N = s[C];
              N !== null && !si(N) && (d ? N <= c : N < c)
                ? (w = C + 1)
                : (S = C);
            }
            return S;
          }
          return Nh(s, c, qn, d);
        }
        function Nh(s, c, d, w) {
          var S = 0,
            C = s == null ? 0 : s.length;
          if (C === 0) return 0;
          c = d(c);
          for (
            var N = c !== c, G = c === null, $ = si(c), pt = c === e;
            S < C;

          ) {
            var mt = nc((S + C) / 2),
              bt = d(s[mt]),
              Rt = bt !== e,
              kt = bt === null,
              Zt = bt === bt,
              se = si(bt);
            if (N) var jt = w || Zt;
            else
              pt
                ? (jt = Zt && (w || Rt))
                : G
                ? (jt = Zt && Rt && (w || !kt))
                : $
                ? (jt = Zt && Rt && !kt && (w || !se))
                : kt || se
                ? (jt = !1)
                : (jt = w ? bt <= c : bt < c);
            jt ? (S = mt + 1) : (C = mt);
          }
          return Tn(C, zt);
        }
        function Hm(s, c) {
          for (var d = -1, w = s.length, S = 0, C = []; ++d < w; ) {
            var N = s[d],
              G = c ? c(N) : N;
            if (!d || !ki(G, $)) {
              var $ = G;
              C[S++] = N === 0 ? 0 : N;
            }
          }
          return C;
        }
        function Vm(s) {
          return typeof s == "number" ? s : si(s) ? J : +s;
        }
        function ri(s) {
          if (typeof s == "string") return s;
          if (ne(s)) return We(s, ri) + "";
          if (si(s)) return wm ? wm.call(s) : "";
          var c = s + "";
          return c == "0" && 1 / s == -Q ? "-0" : c;
        }
        function Xr(s, c, d) {
          var w = -1,
            S = Vl,
            C = s.length,
            N = !0,
            G = [],
            $ = G;
          if (d) (N = !1), (S = hh);
          else if (C >= i) {
            var pt = c ? null : iM(s);
            if (pt) return Xl(pt);
            (N = !1), (S = Ra), ($ = new Ps());
          } else $ = c ? [] : G;
          t: for (; ++w < C; ) {
            var mt = s[w],
              bt = c ? c(mt) : mt;
            if (((mt = d || mt !== 0 ? mt : 0), N && bt === bt)) {
              for (var Rt = $.length; Rt--; ) if ($[Rt] === bt) continue t;
              c && $.push(bt), G.push(mt);
            } else S($, bt, d) || ($ !== G && $.push(bt), G.push(mt));
          }
          return G;
        }
        function Bh(s, c) {
          return (
            (c = Yr(c, s)), (s = _g(s, c)), s == null || delete s[Ki(Ti(c))]
          );
        }
        function Wm(s, c, d, w) {
          return ka(s, c, d(Ds(s, c)), w);
        }
        function hc(s, c, d, w) {
          for (
            var S = s.length, C = w ? S : -1;
            (w ? C-- : ++C < S) && c(s[C], C, s);

          );
          return d
            ? Si(s, w ? 0 : C, w ? C + 1 : S)
            : Si(s, w ? C + 1 : 0, w ? S : C);
        }
        function Xm(s, c) {
          var d = s;
          return (
            d instanceof ue && (d = d.value()),
            fh(
              c,
              function (w, S) {
                return S.func.apply(S.thisArg, Gr([w], S.args));
              },
              d
            )
          );
        }
        function zh(s, c, d) {
          var w = s.length;
          if (w < 2) return w ? Xr(s[0]) : [];
          for (var S = -1, C = rt(w); ++S < w; )
            for (var N = s[S], G = -1; ++G < w; )
              G != S && (C[S] = Ba(C[S] || N, s[G], c, d));
          return Xr(xn(C, 1), c, d);
        }
        function Ym(s, c, d) {
          for (var w = -1, S = s.length, C = c.length, N = {}; ++w < S; ) {
            var G = w < C ? c[w] : e;
            d(N, s[w], G);
          }
          return N;
        }
        function Uh(s) {
          return Ke(s) ? s : [];
        }
        function kh(s) {
          return typeof s == "function" ? s : qn;
        }
        function Yr(s, c) {
          return ne(s) ? s : jh(s, c) ? [s] : wg(ye(s));
        }
        var qb = ae;
        function qr(s, c, d) {
          var w = s.length;
          return (d = d === e ? w : d), !c && d >= w ? s : Si(s, c, d);
        }
        var qm =
          Fw ||
          function (s) {
            return vn.clearTimeout(s);
          };
        function Zm(s, c) {
          if (c) return s.slice();
          var d = s.length,
            w = mm ? mm(d) : new s.constructor(d);
          return s.copy(w), w;
        }
        function Gh(s) {
          var c = new s.constructor(s.byteLength);
          return new $l(c).set(new $l(s)), c;
        }
        function Zb(s, c) {
          var d = c ? Gh(s.buffer) : s.buffer;
          return new s.constructor(d, s.byteOffset, s.byteLength);
        }
        function jb(s) {
          var c = new s.constructor(s.source, Yt.exec(s));
          return (c.lastIndex = s.lastIndex), c;
        }
        function Jb(s) {
          return Oa ? Pe(Oa.call(s)) : {};
        }
        function jm(s, c) {
          var d = c ? Gh(s.buffer) : s.buffer;
          return new s.constructor(d, s.byteOffset, s.length);
        }
        function Jm(s, c) {
          if (s !== c) {
            var d = s !== e,
              w = s === null,
              S = s === s,
              C = si(s),
              N = c !== e,
              G = c === null,
              $ = c === c,
              pt = si(c);
            if (
              (!G && !pt && !C && s > c) ||
              (C && N && $ && !G && !pt) ||
              (w && N && $) ||
              (!d && $) ||
              !S
            )
              return 1;
            if (
              (!w && !C && !pt && s < c) ||
              (pt && d && S && !w && !C) ||
              (G && d && S) ||
              (!N && S) ||
              !$
            )
              return -1;
          }
          return 0;
        }
        function $b(s, c, d) {
          for (
            var w = -1,
              S = s.criteria,
              C = c.criteria,
              N = S.length,
              G = d.length;
            ++w < N;

          ) {
            var $ = Jm(S[w], C[w]);
            if ($) {
              if (w >= G) return $;
              var pt = d[w];
              return $ * (pt == "desc" ? -1 : 1);
            }
          }
          return s.index - c.index;
        }
        function $m(s, c, d, w) {
          for (
            var S = -1,
              C = s.length,
              N = d.length,
              G = -1,
              $ = c.length,
              pt = cn(C - N, 0),
              mt = rt($ + pt),
              bt = !w;
            ++G < $;

          )
            mt[G] = c[G];
          for (; ++S < N; ) (bt || S < C) && (mt[d[S]] = s[S]);
          for (; pt--; ) mt[G++] = s[S++];
          return mt;
        }
        function Km(s, c, d, w) {
          for (
            var S = -1,
              C = s.length,
              N = -1,
              G = d.length,
              $ = -1,
              pt = c.length,
              mt = cn(C - G, 0),
              bt = rt(mt + pt),
              Rt = !w;
            ++S < mt;

          )
            bt[S] = s[S];
          for (var kt = S; ++$ < pt; ) bt[kt + $] = c[$];
          for (; ++N < G; ) (Rt || S < C) && (bt[kt + d[N]] = s[S++]);
          return bt;
        }
        function Wn(s, c) {
          var d = -1,
            w = s.length;
          for (c || (c = rt(w)); ++d < w; ) c[d] = s[d];
          return c;
        }
        function $i(s, c, d, w) {
          var S = !d;
          d || (d = {});
          for (var C = -1, N = c.length; ++C < N; ) {
            var G = c[C],
              $ = w ? w(d[G], s[G], G, d, s) : e;
            $ === e && ($ = s[G]), S ? vr(d, G, $) : Na(d, G, $);
          }
          return d;
        }
        function Kb(s, c) {
          return $i(s, Zh(s), c);
        }
        function Qb(s, c) {
          return $i(s, hg(s), c);
        }
        function fc(s, c) {
          return function (d, w) {
            var S = ne(d) ? rw : wb,
              C = c ? c() : {};
            return S(d, s, qt(w, 2), C);
          };
        }
        function mo(s) {
          return ae(function (c, d) {
            var w = -1,
              S = d.length,
              C = S > 1 ? d[S - 1] : e,
              N = S > 2 ? d[2] : e;
            for (
              C = s.length > 3 && typeof C == "function" ? (S--, C) : e,
                N && Fn(d[0], d[1], N) && ((C = S < 3 ? e : C), (S = 1)),
                c = Pe(c);
              ++w < S;

            ) {
              var G = d[w];
              G && s(c, G, w, C);
            }
            return c;
          });
        }
        function Qm(s, c) {
          return function (d, w) {
            if (d == null) return d;
            if (!Xn(d)) return s(d, w);
            for (
              var S = d.length, C = c ? S : -1, N = Pe(d);
              (c ? C-- : ++C < S) && w(N[C], C, N) !== !1;

            );
            return d;
          };
        }
        function tg(s) {
          return function (c, d, w) {
            for (var S = -1, C = Pe(c), N = w(c), G = N.length; G--; ) {
              var $ = N[s ? G : ++S];
              if (d(C[$], $, C) === !1) break;
            }
            return c;
          };
        }
        function tM(s, c, d) {
          var w = c & b,
            S = Ga(s);
          function C() {
            var N = this && this !== vn && this instanceof C ? S : s;
            return N.apply(w ? d : this, arguments);
          }
          return C;
        }
        function eg(s) {
          return function (c) {
            c = ye(c);
            var d = ao(c) ? zi(c) : e,
              w = d ? d[0] : c.charAt(0),
              S = d ? qr(d, 1).join("") : c.slice(1);
            return w[s]() + S;
          };
        }
        function go(s) {
          return function (c) {
            return fh(Qg(Kg(c).replace(Wy, "")), s, "");
          };
        }
        function Ga(s) {
          return function () {
            var c = arguments;
            switch (c.length) {
              case 0:
                return new s();
              case 1:
                return new s(c[0]);
              case 2:
                return new s(c[0], c[1]);
              case 3:
                return new s(c[0], c[1], c[2]);
              case 4:
                return new s(c[0], c[1], c[2], c[3]);
              case 5:
                return new s(c[0], c[1], c[2], c[3], c[4]);
              case 6:
                return new s(c[0], c[1], c[2], c[3], c[4], c[5]);
              case 7:
                return new s(c[0], c[1], c[2], c[3], c[4], c[5], c[6]);
            }
            var d = po(s.prototype),
              w = s.apply(d, c);
            return Ye(w) ? w : d;
          };
        }
        function eM(s, c, d) {
          var w = Ga(s);
          function S() {
            for (var C = arguments.length, N = rt(C), G = C, $ = _o(S); G--; )
              N[G] = arguments[G];
            var pt = C < 3 && N[0] !== $ && N[C - 1] !== $ ? [] : Hr(N, $);
            if (((C -= pt.length), C < d))
              return og(s, c, dc, S.placeholder, e, N, pt, e, e, d - C);
            var mt = this && this !== vn && this instanceof S ? w : s;
            return ni(mt, this, N);
          }
          return S;
        }
        function ng(s) {
          return function (c, d, w) {
            var S = Pe(c);
            if (!Xn(c)) {
              var C = qt(d, 3);
              (c = fn(c)),
                (d = function (G) {
                  return C(S[G], G, S);
                });
            }
            var N = s(c, d, w);
            return N > -1 ? S[C ? c[N] : N] : e;
          };
        }
        function ig(s) {
          return yr(function (c) {
            var d = c.length,
              w = d,
              S = bi.prototype.thru;
            for (s && c.reverse(); w--; ) {
              var C = c[w];
              if (typeof C != "function") throw new wi(o);
              if (S && !N && _c(C) == "wrapper") var N = new bi([], !0);
            }
            for (w = N ? w : d; ++w < d; ) {
              C = c[w];
              var G = _c(C),
                $ = G == "wrapper" ? Yh(C) : e;
              $ &&
              Jh($[0]) &&
              $[1] == (T | E | A | B) &&
              !$[4].length &&
              $[9] == 1
                ? (N = N[_c($[0])].apply(N, $[3]))
                : (N = C.length == 1 && Jh(C) ? N[G]() : N.thru(C));
            }
            return function () {
              var pt = arguments,
                mt = pt[0];
              if (N && pt.length == 1 && ne(mt)) return N.plant(mt).value();
              for (var bt = 0, Rt = d ? c[bt].apply(this, pt) : mt; ++bt < d; )
                Rt = c[bt].call(this, Rt);
              return Rt;
            };
          });
        }
        function dc(s, c, d, w, S, C, N, G, $, pt) {
          var mt = c & T,
            bt = c & b,
            Rt = c & _,
            kt = c & (E | M),
            Zt = c & X,
            se = Rt ? e : Ga(s);
          function jt() {
            for (var le = arguments.length, he = rt(le), oi = le; oi--; )
              he[oi] = arguments[oi];
            if (kt)
              var On = _o(jt),
                ai = dw(he, On);
            if (
              (w && (he = $m(he, w, S, kt)),
              C && (he = Km(he, C, N, kt)),
              (le -= ai),
              kt && le < pt)
            ) {
              var Qe = Hr(he, On);
              return og(s, c, dc, jt.placeholder, d, he, Qe, G, $, pt - le);
            }
            var Gi = bt ? d : this,
              Sr = Rt ? Gi[s] : s;
            return (
              (le = he.length),
              G ? (he = wM(he, G)) : Zt && le > 1 && he.reverse(),
              mt && $ < le && (he.length = $),
              this && this !== vn && this instanceof jt && (Sr = se || Ga(Sr)),
              Sr.apply(Gi, he)
            );
          }
          return jt;
        }
        function rg(s, c) {
          return function (d, w) {
            return Cb(d, s, c(w), {});
          };
        }
        function pc(s, c) {
          return function (d, w) {
            var S;
            if (d === e && w === e) return c;
            if ((d !== e && (S = d), w !== e)) {
              if (S === e) return w;
              typeof d == "string" || typeof w == "string"
                ? ((d = ri(d)), (w = ri(w)))
                : ((d = Vm(d)), (w = Vm(w))),
                (S = s(d, w));
            }
            return S;
          };
        }
        function Hh(s) {
          return yr(function (c) {
            return (
              (c = We(c, ii(qt()))),
              ae(function (d) {
                var w = this;
                return s(c, function (S) {
                  return ni(S, w, d);
                });
              })
            );
          });
        }
        function mc(s, c) {
          c = c === e ? " " : ri(c);
          var d = c.length;
          if (d < 2) return d ? Oh(c, s) : c;
          var w = Oh(c, ec(s / lo(c)));
          return ao(c) ? qr(zi(w), 0, s).join("") : w.slice(0, s);
        }
        function nM(s, c, d, w) {
          var S = c & b,
            C = Ga(s);
          function N() {
            for (
              var G = -1,
                $ = arguments.length,
                pt = -1,
                mt = w.length,
                bt = rt(mt + $),
                Rt = this && this !== vn && this instanceof N ? C : s;
              ++pt < mt;

            )
              bt[pt] = w[pt];
            for (; $--; ) bt[pt++] = arguments[++G];
            return ni(Rt, S ? d : this, bt);
          }
          return N;
        }
        function sg(s) {
          return function (c, d, w) {
            return (
              w && typeof w != "number" && Fn(c, d, w) && (d = w = e),
              (c = Mr(c)),
              d === e ? ((d = c), (c = 0)) : (d = Mr(d)),
              (w = w === e ? (c < d ? 1 : -1) : Mr(w)),
              Gb(c, d, w, s)
            );
          };
        }
        function gc(s) {
          return function (c, d) {
            return (
              (typeof c == "string" && typeof d == "string") ||
                ((c = Ei(c)), (d = Ei(d))),
              s(c, d)
            );
          };
        }
        function og(s, c, d, w, S, C, N, G, $, pt) {
          var mt = c & E,
            bt = mt ? N : e,
            Rt = mt ? e : N,
            kt = mt ? C : e,
            Zt = mt ? e : C;
          (c |= mt ? A : R), (c &= ~(mt ? R : A)), c & y || (c &= ~(b | _));
          var se = [s, c, S, kt, bt, Zt, Rt, G, $, pt],
            jt = d.apply(e, se);
          return Jh(s) && vg(jt, se), (jt.placeholder = w), xg(jt, s, c);
        }
        function Vh(s) {
          var c = ln[s];
          return function (d, w) {
            if (
              ((d = Ei(d)), (w = w == null ? 0 : Tn(ie(w), 292)), w && xm(d))
            ) {
              var S = (ye(d) + "e").split("e"),
                C = c(S[0] + "e" + (+S[1] + w));
              return (
                (S = (ye(C) + "e").split("e")), +(S[0] + "e" + (+S[1] - w))
              );
            }
            return c(d);
          };
        }
        var iM =
          ho && 1 / Xl(new ho([, -0]))[1] == Q
            ? function (s) {
                return new ho(s);
              }
            : ff;
        function ag(s) {
          return function (c) {
            var d = En(c);
            return d == ct ? xh(c) : d == wt ? yw(c) : fw(c, s(c));
          };
        }
        function xr(s, c, d, w, S, C, N, G) {
          var $ = c & _;
          if (!$ && typeof s != "function") throw new wi(o);
          var pt = w ? w.length : 0;
          if (
            (pt || ((c &= ~(A | R)), (w = S = e)),
            (N = N === e ? N : cn(ie(N), 0)),
            (G = G === e ? G : ie(G)),
            (pt -= S ? S.length : 0),
            c & R)
          ) {
            var mt = w,
              bt = S;
            w = S = e;
          }
          var Rt = $ ? e : Yh(s),
            kt = [s, c, d, w, S, mt, bt, C, N, G];
          if (
            (Rt && vM(kt, Rt),
            (s = kt[0]),
            (c = kt[1]),
            (d = kt[2]),
            (w = kt[3]),
            (S = kt[4]),
            (G = kt[9] = kt[9] === e ? ($ ? 0 : s.length) : cn(kt[9] - pt, 0)),
            !G && c & (E | M) && (c &= ~(E | M)),
            !c || c == b)
          )
            var Zt = tM(s, c, d);
          else
            c == E || c == M
              ? (Zt = eM(s, c, G))
              : (c == A || c == (b | A)) && !S.length
              ? (Zt = nM(s, c, d, w))
              : (Zt = dc.apply(e, kt));
          var se = Rt ? Gm : vg;
          return xg(se(Zt, kt), s, c);
        }
        function lg(s, c, d, w) {
          return s === e || (ki(s, uo[d]) && !be.call(w, d)) ? c : s;
        }
        function cg(s, c, d, w, S, C) {
          return (
            Ye(s) && Ye(c) && (C.set(c, s), cc(s, c, e, cg, C), C.delete(c)), s
          );
        }
        function rM(s) {
          return Wa(s) ? e : s;
        }
        function ug(s, c, d, w, S, C) {
          var N = d & v,
            G = s.length,
            $ = c.length;
          if (G != $ && !(N && $ > G)) return !1;
          var pt = C.get(s),
            mt = C.get(c);
          if (pt && mt) return pt == c && mt == s;
          var bt = -1,
            Rt = !0,
            kt = d & x ? new Ps() : e;
          for (C.set(s, c), C.set(c, s); ++bt < G; ) {
            var Zt = s[bt],
              se = c[bt];
            if (w) var jt = N ? w(se, Zt, bt, c, s, C) : w(Zt, se, bt, s, c, C);
            if (jt !== e) {
              if (jt) continue;
              Rt = !1;
              break;
            }
            if (kt) {
              if (
                !dh(c, function (le, he) {
                  if (!Ra(kt, he) && (Zt === le || S(Zt, le, d, w, C)))
                    return kt.push(he);
                })
              ) {
                Rt = !1;
                break;
              }
            } else if (!(Zt === se || S(Zt, se, d, w, C))) {
              Rt = !1;
              break;
            }
          }
          return C.delete(s), C.delete(c), Rt;
        }
        function sM(s, c, d, w, S, C, N) {
          switch (d) {
            case Ct:
              if (s.byteLength != c.byteLength || s.byteOffset != c.byteOffset)
                return !1;
              (s = s.buffer), (c = c.buffer);
            case Y:
              return !(
                s.byteLength != c.byteLength || !C(new $l(s), new $l(c))
              );
            case U:
            case et:
            case St:
              return ki(+s, +c);
            case gt:
              return s.name == c.name && s.message == c.message;
            case yt:
            case At:
              return s == c + "";
            case ct:
              var G = xh;
            case wt:
              var $ = w & v;
              if ((G || (G = Xl), s.size != c.size && !$)) return !1;
              var pt = N.get(s);
              if (pt) return pt == c;
              (w |= x), N.set(s, c);
              var mt = ug(G(s), G(c), w, S, C, N);
              return N.delete(s), mt;
            case Ht:
              if (Oa) return Oa.call(s) == Oa.call(c);
          }
          return !1;
        }
        function oM(s, c, d, w, S, C) {
          var N = d & v,
            G = Wh(s),
            $ = G.length,
            pt = Wh(c),
            mt = pt.length;
          if ($ != mt && !N) return !1;
          for (var bt = $; bt--; ) {
            var Rt = G[bt];
            if (!(N ? Rt in c : be.call(c, Rt))) return !1;
          }
          var kt = C.get(s),
            Zt = C.get(c);
          if (kt && Zt) return kt == c && Zt == s;
          var se = !0;
          C.set(s, c), C.set(c, s);
          for (var jt = N; ++bt < $; ) {
            Rt = G[bt];
            var le = s[Rt],
              he = c[Rt];
            if (w) var oi = N ? w(he, le, Rt, c, s, C) : w(le, he, Rt, s, c, C);
            if (!(oi === e ? le === he || S(le, he, d, w, C) : oi)) {
              se = !1;
              break;
            }
            jt || (jt = Rt == "constructor");
          }
          if (se && !jt) {
            var On = s.constructor,
              ai = c.constructor;
            On != ai &&
              "constructor" in s &&
              "constructor" in c &&
              !(
                typeof On == "function" &&
                On instanceof On &&
                typeof ai == "function" &&
                ai instanceof ai
              ) &&
              (se = !1);
          }
          return C.delete(s), C.delete(c), se;
        }
        function yr(s) {
          return Kh(gg(s, e, Tg), s + "");
        }
        function Wh(s) {
          return Rm(s, fn, Zh);
        }
        function Xh(s) {
          return Rm(s, Yn, hg);
        }
        var Yh = ic
          ? function (s) {
              return ic.get(s);
            }
          : ff;
        function _c(s) {
          for (
            var c = s.name + "", d = fo[c], w = be.call(fo, c) ? d.length : 0;
            w--;

          ) {
            var S = d[w],
              C = S.func;
            if (C == null || C == s) return S.name;
          }
          return c;
        }
        function _o(s) {
          var c = be.call(L, "placeholder") ? L : s;
          return c.placeholder;
        }
        function qt() {
          var s = L.iteratee || uf;
          return (
            (s = s === uf ? Dm : s),
            arguments.length ? s(arguments[0], arguments[1]) : s
          );
        }
        function vc(s, c) {
          var d = s.__data__;
          return pM(c) ? d[typeof c == "string" ? "string" : "hash"] : d.map;
        }
        function qh(s) {
          for (var c = fn(s), d = c.length; d--; ) {
            var w = c[d],
              S = s[w];
            c[d] = [w, S, pg(S)];
          }
          return c;
        }
        function Fs(s, c) {
          var d = _w(s, c);
          return Im(d) ? d : e;
        }
        function aM(s) {
          var c = be.call(s, Cs),
            d = s[Cs];
          try {
            s[Cs] = e;
            var w = !0;
          } catch {}
          var S = jl.call(s);
          return w && (c ? (s[Cs] = d) : delete s[Cs]), S;
        }
        var Zh = wh
            ? function (s) {
                return s == null
                  ? []
                  : ((s = Pe(s)),
                    kr(wh(s), function (c) {
                      return _m.call(s, c);
                    }));
              }
            : df,
          hg = wh
            ? function (s) {
                for (var c = []; s; ) Gr(c, Zh(s)), (s = Kl(s));
                return c;
              }
            : df,
          En = Dn;
        ((bh && En(new bh(new ArrayBuffer(1))) != Ct) ||
          (Ia && En(new Ia()) != ct) ||
          (Mh && En(Mh.resolve()) != P) ||
          (ho && En(new ho()) != wt) ||
          (Da && En(new Da()) != Vt)) &&
          (En = function (s) {
            var c = Dn(s),
              d = c == I ? s.constructor : e,
              w = d ? Os(d) : "";
            if (w)
              switch (w) {
                case Vw:
                  return Ct;
                case Ww:
                  return ct;
                case Xw:
                  return P;
                case Yw:
                  return wt;
                case qw:
                  return Vt;
              }
            return c;
          });
        function lM(s, c, d) {
          for (var w = -1, S = d.length; ++w < S; ) {
            var C = d[w],
              N = C.size;
            switch (C.type) {
              case "drop":
                s += N;
                break;
              case "dropRight":
                c -= N;
                break;
              case "take":
                c = Tn(c, s + N);
                break;
              case "takeRight":
                s = cn(s, c - N);
                break;
            }
          }
          return { start: s, end: c };
        }
        function cM(s) {
          var c = s.match(nt);
          return c ? c[1].split(ut) : [];
        }
        function fg(s, c, d) {
          c = Yr(c, s);
          for (var w = -1, S = c.length, C = !1; ++w < S; ) {
            var N = Ki(c[w]);
            if (!(C = s != null && d(s, N))) break;
            s = s[N];
          }
          return C || ++w != S
            ? C
            : ((S = s == null ? 0 : s.length),
              !!S && Tc(S) && wr(N, S) && (ne(s) || Ns(s)));
        }
        function uM(s) {
          var c = s.length,
            d = new s.constructor(c);
          return (
            c &&
              typeof s[0] == "string" &&
              be.call(s, "index") &&
              ((d.index = s.index), (d.input = s.input)),
            d
          );
        }
        function dg(s) {
          return typeof s.constructor == "function" && !Ha(s) ? po(Kl(s)) : {};
        }
        function hM(s, c, d) {
          var w = s.constructor;
          switch (c) {
            case Y:
              return Gh(s);
            case U:
            case et:
              return new w(+s);
            case Ct:
              return Zb(s, d);
            case _t:
            case Bt:
            case Ft:
            case ee:
            case Be:
            case He:
            case Te:
            case ve:
            case je:
              return jm(s, d);
            case ct:
              return new w();
            case St:
            case At:
              return new w(s);
            case yt:
              return jb(s);
            case wt:
              return new w();
            case Ht:
              return Jb(s);
          }
        }
        function fM(s, c) {
          var d = c.length;
          if (!d) return s;
          var w = d - 1;
          return (
            (c[w] = (d > 1 ? "& " : "") + c[w]),
            (c = c.join(d > 2 ? ", " : " ")),
            s.replace(
              at,
              `{
/* [wrapped with ` +
                c +
                `] */
`
            )
          );
        }
        function dM(s) {
          return ne(s) || Ns(s) || !!(vm && s && s[vm]);
        }
        function wr(s, c) {
          var d = typeof s;
          return (
            (c = c == null ? st : c),
            !!c &&
              (d == "number" || (d != "symbol" && oe.test(s))) &&
              s > -1 &&
              s % 1 == 0 &&
              s < c
          );
        }
        function Fn(s, c, d) {
          if (!Ye(d)) return !1;
          var w = typeof c;
          return (
            w == "number" ? Xn(d) && wr(c, d.length) : w == "string" && c in d
          )
            ? ki(d[c], s)
            : !1;
        }
        function jh(s, c) {
          if (ne(s)) return !1;
          var d = typeof s;
          return d == "number" ||
            d == "symbol" ||
            d == "boolean" ||
            s == null ||
            si(s)
            ? !0
            : _n.test(s) || !de.test(s) || (c != null && s in Pe(c));
        }
        function pM(s) {
          var c = typeof s;
          return c == "string" ||
            c == "number" ||
            c == "symbol" ||
            c == "boolean"
            ? s !== "__proto__"
            : s === null;
        }
        function Jh(s) {
          var c = _c(s),
            d = L[c];
          if (typeof d != "function" || !(c in ue.prototype)) return !1;
          if (s === d) return !0;
          var w = Yh(d);
          return !!w && s === w[0];
        }
        function mM(s) {
          return !!pm && pm in s;
        }
        var gM = ql ? br : pf;
        function Ha(s) {
          var c = s && s.constructor,
            d = (typeof c == "function" && c.prototype) || uo;
          return s === d;
        }
        function pg(s) {
          return s === s && !Ye(s);
        }
        function mg(s, c) {
          return function (d) {
            return d == null ? !1 : d[s] === c && (c !== e || s in Pe(d));
          };
        }
        function _M(s) {
          var c = Mc(s, function (w) {
              return d.size === h && d.clear(), w;
            }),
            d = c.cache;
          return c;
        }
        function vM(s, c) {
          var d = s[1],
            w = c[1],
            S = d | w,
            C = S < (b | _ | T),
            N =
              (w == T && d == E) ||
              (w == T && d == B && s[7].length <= c[8]) ||
              (w == (T | B) && c[7].length <= c[8] && d == E);
          if (!(C || N)) return s;
          w & b && ((s[2] = c[2]), (S |= d & b ? 0 : y));
          var G = c[3];
          if (G) {
            var $ = s[3];
            (s[3] = $ ? $m($, G, c[4]) : G), (s[4] = $ ? Hr(s[3], f) : c[4]);
          }
          return (
            (G = c[5]),
            G &&
              (($ = s[5]),
              (s[5] = $ ? Km($, G, c[6]) : G),
              (s[6] = $ ? Hr(s[5], f) : c[6])),
            (G = c[7]),
            G && (s[7] = G),
            w & T && (s[8] = s[8] == null ? c[8] : Tn(s[8], c[8])),
            s[9] == null && (s[9] = c[9]),
            (s[0] = c[0]),
            (s[1] = S),
            s
          );
        }
        function xM(s) {
          var c = [];
          if (s != null) for (var d in Pe(s)) c.push(d);
          return c;
        }
        function yM(s) {
          return jl.call(s);
        }
        function gg(s, c, d) {
          return (
            (c = cn(c === e ? s.length - 1 : c, 0)),
            function () {
              for (
                var w = arguments, S = -1, C = cn(w.length - c, 0), N = rt(C);
                ++S < C;

              )
                N[S] = w[c + S];
              S = -1;
              for (var G = rt(c + 1); ++S < c; ) G[S] = w[S];
              return (G[c] = d(N)), ni(s, this, G);
            }
          );
        }
        function _g(s, c) {
          return c.length < 2 ? s : Ds(s, Si(c, 0, -1));
        }
        function wM(s, c) {
          for (var d = s.length, w = Tn(c.length, d), S = Wn(s); w--; ) {
            var C = c[w];
            s[w] = wr(C, d) ? S[C] : e;
          }
          return s;
        }
        function $h(s, c) {
          if (
            !(c === "constructor" && typeof s[c] == "function") &&
            c != "__proto__"
          )
            return s[c];
        }
        var vg = yg(Gm),
          Va =
            Nw ||
            function (s, c) {
              return vn.setTimeout(s, c);
            },
          Kh = yg(Wb);
        function xg(s, c, d) {
          var w = c + "";
          return Kh(s, fM(w, bM(cM(w), d)));
        }
        function yg(s) {
          var c = 0,
            d = 0;
          return function () {
            var w = kw(),
              S = W - (w - d);
            if (((d = w), S > 0)) {
              if (++c >= it) return arguments[0];
            } else c = 0;
            return s.apply(e, arguments);
          };
        }
        function xc(s, c) {
          var d = -1,
            w = s.length,
            S = w - 1;
          for (c = c === e ? w : c; ++d < c; ) {
            var C = Fh(d, S),
              N = s[C];
            (s[C] = s[d]), (s[d] = N);
          }
          return (s.length = c), s;
        }
        var wg = _M(function (s) {
          var c = [];
          return (
            s.charCodeAt(0) === 46 && c.push(""),
            s.replace(Kt, function (d, w, S, C) {
              c.push(S ? C.replace(Gt, "$1") : w || d);
            }),
            c
          );
        });
        function Ki(s) {
          if (typeof s == "string" || si(s)) return s;
          var c = s + "";
          return c == "0" && 1 / s == -Q ? "-0" : c;
        }
        function Os(s) {
          if (s != null) {
            try {
              return Zl.call(s);
            } catch {}
            try {
              return s + "";
            } catch {}
          }
          return "";
        }
        function bM(s, c) {
          return (
            yi(Mt, function (d) {
              var w = "_." + d[0];
              c & d[1] && !Vl(s, w) && s.push(w);
            }),
            s.sort()
          );
        }
        function bg(s) {
          if (s instanceof ue) return s.clone();
          var c = new bi(s.__wrapped__, s.__chain__);
          return (
            (c.__actions__ = Wn(s.__actions__)),
            (c.__index__ = s.__index__),
            (c.__values__ = s.__values__),
            c
          );
        }
        function MM(s, c, d) {
          (d ? Fn(s, c, d) : c === e) ? (c = 1) : (c = cn(ie(c), 0));
          var w = s == null ? 0 : s.length;
          if (!w || c < 1) return [];
          for (var S = 0, C = 0, N = rt(ec(w / c)); S < w; )
            N[C++] = Si(s, S, (S += c));
          return N;
        }
        function SM(s) {
          for (
            var c = -1, d = s == null ? 0 : s.length, w = 0, S = [];
            ++c < d;

          ) {
            var C = s[c];
            C && (S[w++] = C);
          }
          return S;
        }
        function TM() {
          var s = arguments.length;
          if (!s) return [];
          for (var c = rt(s - 1), d = arguments[0], w = s; w--; )
            c[w - 1] = arguments[w];
          return Gr(ne(d) ? Wn(d) : [d], xn(c, 1));
        }
        var EM = ae(function (s, c) {
            return Ke(s) ? Ba(s, xn(c, 1, Ke, !0)) : [];
          }),
          AM = ae(function (s, c) {
            var d = Ti(c);
            return (
              Ke(d) && (d = e), Ke(s) ? Ba(s, xn(c, 1, Ke, !0), qt(d, 2)) : []
            );
          }),
          LM = ae(function (s, c) {
            var d = Ti(c);
            return Ke(d) && (d = e), Ke(s) ? Ba(s, xn(c, 1, Ke, !0), e, d) : [];
          });
        function CM(s, c, d) {
          var w = s == null ? 0 : s.length;
          return w
            ? ((c = d || c === e ? 1 : ie(c)), Si(s, c < 0 ? 0 : c, w))
            : [];
        }
        function RM(s, c, d) {
          var w = s == null ? 0 : s.length;
          return w
            ? ((c = d || c === e ? 1 : ie(c)),
              (c = w - c),
              Si(s, 0, c < 0 ? 0 : c))
            : [];
        }
        function PM(s, c) {
          return s && s.length ? hc(s, qt(c, 3), !0, !0) : [];
        }
        function IM(s, c) {
          return s && s.length ? hc(s, qt(c, 3), !0) : [];
        }
        function DM(s, c, d, w) {
          var S = s == null ? 0 : s.length;
          return S
            ? (d && typeof d != "number" && Fn(s, c, d) && ((d = 0), (w = S)),
              Tb(s, c, d, w))
            : [];
        }
        function Mg(s, c, d) {
          var w = s == null ? 0 : s.length;
          if (!w) return -1;
          var S = d == null ? 0 : ie(d);
          return S < 0 && (S = cn(w + S, 0)), Wl(s, qt(c, 3), S);
        }
        function Sg(s, c, d) {
          var w = s == null ? 0 : s.length;
          if (!w) return -1;
          var S = w - 1;
          return (
            d !== e && ((S = ie(d)), (S = d < 0 ? cn(w + S, 0) : Tn(S, w - 1))),
            Wl(s, qt(c, 3), S, !0)
          );
        }
        function Tg(s) {
          var c = s == null ? 0 : s.length;
          return c ? xn(s, 1) : [];
        }
        function FM(s) {
          var c = s == null ? 0 : s.length;
          return c ? xn(s, Q) : [];
        }
        function OM(s, c) {
          var d = s == null ? 0 : s.length;
          return d ? ((c = c === e ? 1 : ie(c)), xn(s, c)) : [];
        }
        function NM(s) {
          for (var c = -1, d = s == null ? 0 : s.length, w = {}; ++c < d; ) {
            var S = s[c];
            w[S[0]] = S[1];
          }
          return w;
        }
        function Eg(s) {
          return s && s.length ? s[0] : e;
        }
        function BM(s, c, d) {
          var w = s == null ? 0 : s.length;
          if (!w) return -1;
          var S = d == null ? 0 : ie(d);
          return S < 0 && (S = cn(w + S, 0)), oo(s, c, S);
        }
        function zM(s) {
          var c = s == null ? 0 : s.length;
          return c ? Si(s, 0, -1) : [];
        }
        var UM = ae(function (s) {
            var c = We(s, Uh);
            return c.length && c[0] === s[0] ? Ch(c) : [];
          }),
          kM = ae(function (s) {
            var c = Ti(s),
              d = We(s, Uh);
            return (
              c === Ti(d) ? (c = e) : d.pop(),
              d.length && d[0] === s[0] ? Ch(d, qt(c, 2)) : []
            );
          }),
          GM = ae(function (s) {
            var c = Ti(s),
              d = We(s, Uh);
            return (
              (c = typeof c == "function" ? c : e),
              c && d.pop(),
              d.length && d[0] === s[0] ? Ch(d, e, c) : []
            );
          });
        function HM(s, c) {
          return s == null ? "" : zw.call(s, c);
        }
        function Ti(s) {
          var c = s == null ? 0 : s.length;
          return c ? s[c - 1] : e;
        }
        function VM(s, c, d) {
          var w = s == null ? 0 : s.length;
          if (!w) return -1;
          var S = w;
          return (
            d !== e && ((S = ie(d)), (S = S < 0 ? cn(w + S, 0) : Tn(S, w - 1))),
            c === c ? bw(s, c, S) : Wl(s, om, S, !0)
          );
        }
        function WM(s, c) {
          return s && s.length ? Bm(s, ie(c)) : e;
        }
        var XM = ae(Ag);
        function Ag(s, c) {
          return s && s.length && c && c.length ? Dh(s, c) : s;
        }
        function YM(s, c, d) {
          return s && s.length && c && c.length ? Dh(s, c, qt(d, 2)) : s;
        }
        function qM(s, c, d) {
          return s && s.length && c && c.length ? Dh(s, c, e, d) : s;
        }
        var ZM = yr(function (s, c) {
          var d = s == null ? 0 : s.length,
            w = Th(s, c);
          return (
            km(
              s,
              We(c, function (S) {
                return wr(S, d) ? +S : S;
              }).sort(Jm)
            ),
            w
          );
        });
        function jM(s, c) {
          var d = [];
          if (!(s && s.length)) return d;
          var w = -1,
            S = [],
            C = s.length;
          for (c = qt(c, 3); ++w < C; ) {
            var N = s[w];
            c(N, w, s) && (d.push(N), S.push(w));
          }
          return km(s, S), d;
        }
        function Qh(s) {
          return s == null ? s : Hw.call(s);
        }
        function JM(s, c, d) {
          var w = s == null ? 0 : s.length;
          return w
            ? (d && typeof d != "number" && Fn(s, c, d)
                ? ((c = 0), (d = w))
                : ((c = c == null ? 0 : ie(c)), (d = d === e ? w : ie(d))),
              Si(s, c, d))
            : [];
        }
        function $M(s, c) {
          return uc(s, c);
        }
        function KM(s, c, d) {
          return Nh(s, c, qt(d, 2));
        }
        function QM(s, c) {
          var d = s == null ? 0 : s.length;
          if (d) {
            var w = uc(s, c);
            if (w < d && ki(s[w], c)) return w;
          }
          return -1;
        }
        function tS(s, c) {
          return uc(s, c, !0);
        }
        function eS(s, c, d) {
          return Nh(s, c, qt(d, 2), !0);
        }
        function nS(s, c) {
          var d = s == null ? 0 : s.length;
          if (d) {
            var w = uc(s, c, !0) - 1;
            if (ki(s[w], c)) return w;
          }
          return -1;
        }
        function iS(s) {
          return s && s.length ? Hm(s) : [];
        }
        function rS(s, c) {
          return s && s.length ? Hm(s, qt(c, 2)) : [];
        }
        function sS(s) {
          var c = s == null ? 0 : s.length;
          return c ? Si(s, 1, c) : [];
        }
        function oS(s, c, d) {
          return s && s.length
            ? ((c = d || c === e ? 1 : ie(c)), Si(s, 0, c < 0 ? 0 : c))
            : [];
        }
        function aS(s, c, d) {
          var w = s == null ? 0 : s.length;
          return w
            ? ((c = d || c === e ? 1 : ie(c)),
              (c = w - c),
              Si(s, c < 0 ? 0 : c, w))
            : [];
        }
        function lS(s, c) {
          return s && s.length ? hc(s, qt(c, 3), !1, !0) : [];
        }
        function cS(s, c) {
          return s && s.length ? hc(s, qt(c, 3)) : [];
        }
        var uS = ae(function (s) {
            return Xr(xn(s, 1, Ke, !0));
          }),
          hS = ae(function (s) {
            var c = Ti(s);
            return Ke(c) && (c = e), Xr(xn(s, 1, Ke, !0), qt(c, 2));
          }),
          fS = ae(function (s) {
            var c = Ti(s);
            return (
              (c = typeof c == "function" ? c : e), Xr(xn(s, 1, Ke, !0), e, c)
            );
          });
        function dS(s) {
          return s && s.length ? Xr(s) : [];
        }
        function pS(s, c) {
          return s && s.length ? Xr(s, qt(c, 2)) : [];
        }
        function mS(s, c) {
          return (
            (c = typeof c == "function" ? c : e),
            s && s.length ? Xr(s, e, c) : []
          );
        }
        function tf(s) {
          if (!(s && s.length)) return [];
          var c = 0;
          return (
            (s = kr(s, function (d) {
              if (Ke(d)) return (c = cn(d.length, c)), !0;
            })),
            _h(c, function (d) {
              return We(s, ph(d));
            })
          );
        }
        function Lg(s, c) {
          if (!(s && s.length)) return [];
          var d = tf(s);
          return c == null
            ? d
            : We(d, function (w) {
                return ni(c, e, w);
              });
        }
        var gS = ae(function (s, c) {
            return Ke(s) ? Ba(s, c) : [];
          }),
          _S = ae(function (s) {
            return zh(kr(s, Ke));
          }),
          vS = ae(function (s) {
            var c = Ti(s);
            return Ke(c) && (c = e), zh(kr(s, Ke), qt(c, 2));
          }),
          xS = ae(function (s) {
            var c = Ti(s);
            return (c = typeof c == "function" ? c : e), zh(kr(s, Ke), e, c);
          }),
          yS = ae(tf);
        function wS(s, c) {
          return Ym(s || [], c || [], Na);
        }
        function bS(s, c) {
          return Ym(s || [], c || [], ka);
        }
        var MS = ae(function (s) {
          var c = s.length,
            d = c > 1 ? s[c - 1] : e;
          return (d = typeof d == "function" ? (s.pop(), d) : e), Lg(s, d);
        });
        function Cg(s) {
          var c = L(s);
          return (c.__chain__ = !0), c;
        }
        function SS(s, c) {
          return c(s), s;
        }
        function yc(s, c) {
          return c(s);
        }
        var TS = yr(function (s) {
          var c = s.length,
            d = c ? s[0] : 0,
            w = this.__wrapped__,
            S = function (C) {
              return Th(C, s);
            };
          return c > 1 ||
            this.__actions__.length ||
            !(w instanceof ue) ||
            !wr(d)
            ? this.thru(S)
            : ((w = w.slice(d, +d + (c ? 1 : 0))),
              w.__actions__.push({ func: yc, args: [S], thisArg: e }),
              new bi(w, this.__chain__).thru(function (C) {
                return c && !C.length && C.push(e), C;
              }));
        });
        function ES() {
          return Cg(this);
        }
        function AS() {
          return new bi(this.value(), this.__chain__);
        }
        function LS() {
          this.__values__ === e && (this.__values__ = Vg(this.value()));
          var s = this.__index__ >= this.__values__.length,
            c = s ? e : this.__values__[this.__index__++];
          return { done: s, value: c };
        }
        function CS() {
          return this;
        }
        function RS(s) {
          for (var c, d = this; d instanceof sc; ) {
            var w = bg(d);
            (w.__index__ = 0),
              (w.__values__ = e),
              c ? (S.__wrapped__ = w) : (c = w);
            var S = w;
            d = d.__wrapped__;
          }
          return (S.__wrapped__ = s), c;
        }
        function PS() {
          var s = this.__wrapped__;
          if (s instanceof ue) {
            var c = s;
            return (
              this.__actions__.length && (c = new ue(this)),
              (c = c.reverse()),
              c.__actions__.push({ func: yc, args: [Qh], thisArg: e }),
              new bi(c, this.__chain__)
            );
          }
          return this.thru(Qh);
        }
        function IS() {
          return Xm(this.__wrapped__, this.__actions__);
        }
        var DS = fc(function (s, c, d) {
          be.call(s, d) ? ++s[d] : vr(s, d, 1);
        });
        function FS(s, c, d) {
          var w = ne(s) ? rm : Sb;
          return d && Fn(s, c, d) && (c = e), w(s, qt(c, 3));
        }
        function OS(s, c) {
          var d = ne(s) ? kr : Lm;
          return d(s, qt(c, 3));
        }
        var NS = ng(Mg),
          BS = ng(Sg);
        function zS(s, c) {
          return xn(wc(s, c), 1);
        }
        function US(s, c) {
          return xn(wc(s, c), Q);
        }
        function kS(s, c, d) {
          return (d = d === e ? 1 : ie(d)), xn(wc(s, c), d);
        }
        function Rg(s, c) {
          var d = ne(s) ? yi : Wr;
          return d(s, qt(c, 3));
        }
        function Pg(s, c) {
          var d = ne(s) ? sw : Am;
          return d(s, qt(c, 3));
        }
        var GS = fc(function (s, c, d) {
          be.call(s, d) ? s[d].push(c) : vr(s, d, [c]);
        });
        function HS(s, c, d, w) {
          (s = Xn(s) ? s : xo(s)), (d = d && !w ? ie(d) : 0);
          var S = s.length;
          return (
            d < 0 && (d = cn(S + d, 0)),
            Ec(s) ? d <= S && s.indexOf(c, d) > -1 : !!S && oo(s, c, d) > -1
          );
        }
        var VS = ae(function (s, c, d) {
            var w = -1,
              S = typeof c == "function",
              C = Xn(s) ? rt(s.length) : [];
            return (
              Wr(s, function (N) {
                C[++w] = S ? ni(c, N, d) : za(N, c, d);
              }),
              C
            );
          }),
          WS = fc(function (s, c, d) {
            vr(s, d, c);
          });
        function wc(s, c) {
          var d = ne(s) ? We : Fm;
          return d(s, qt(c, 3));
        }
        function XS(s, c, d, w) {
          return s == null
            ? []
            : (ne(c) || (c = c == null ? [] : [c]),
              (d = w ? e : d),
              ne(d) || (d = d == null ? [] : [d]),
              zm(s, c, d));
        }
        var YS = fc(
          function (s, c, d) {
            s[d ? 0 : 1].push(c);
          },
          function () {
            return [[], []];
          }
        );
        function qS(s, c, d) {
          var w = ne(s) ? fh : lm,
            S = arguments.length < 3;
          return w(s, qt(c, 4), d, S, Wr);
        }
        function ZS(s, c, d) {
          var w = ne(s) ? ow : lm,
            S = arguments.length < 3;
          return w(s, qt(c, 4), d, S, Am);
        }
        function jS(s, c) {
          var d = ne(s) ? kr : Lm;
          return d(s, Sc(qt(c, 3)));
        }
        function JS(s) {
          var c = ne(s) ? Mm : Hb;
          return c(s);
        }
        function $S(s, c, d) {
          (d ? Fn(s, c, d) : c === e) ? (c = 1) : (c = ie(c));
          var w = ne(s) ? xb : Vb;
          return w(s, c);
        }
        function KS(s) {
          var c = ne(s) ? yb : Xb;
          return c(s);
        }
        function QS(s) {
          if (s == null) return 0;
          if (Xn(s)) return Ec(s) ? lo(s) : s.length;
          var c = En(s);
          return c == ct || c == wt ? s.size : Ph(s).length;
        }
        function t1(s, c, d) {
          var w = ne(s) ? dh : Yb;
          return d && Fn(s, c, d) && (c = e), w(s, qt(c, 3));
        }
        var e1 = ae(function (s, c) {
            if (s == null) return [];
            var d = c.length;
            return (
              d > 1 && Fn(s, c[0], c[1])
                ? (c = [])
                : d > 2 && Fn(c[0], c[1], c[2]) && (c = [c[0]]),
              zm(s, xn(c, 1), [])
            );
          }),
          bc =
            Ow ||
            function () {
              return vn.Date.now();
            };
        function n1(s, c) {
          if (typeof c != "function") throw new wi(o);
          return (
            (s = ie(s)),
            function () {
              if (--s < 1) return c.apply(this, arguments);
            }
          );
        }
        function Ig(s, c, d) {
          return (
            (c = d ? e : c),
            (c = s && c == null ? s.length : c),
            xr(s, T, e, e, e, e, c)
          );
        }
        function Dg(s, c) {
          var d;
          if (typeof c != "function") throw new wi(o);
          return (
            (s = ie(s)),
            function () {
              return (
                --s > 0 && (d = c.apply(this, arguments)), s <= 1 && (c = e), d
              );
            }
          );
        }
        var ef = ae(function (s, c, d) {
            var w = b;
            if (d.length) {
              var S = Hr(d, _o(ef));
              w |= A;
            }
            return xr(s, w, c, d, S);
          }),
          Fg = ae(function (s, c, d) {
            var w = b | _;
            if (d.length) {
              var S = Hr(d, _o(Fg));
              w |= A;
            }
            return xr(c, w, s, d, S);
          });
        function Og(s, c, d) {
          c = d ? e : c;
          var w = xr(s, E, e, e, e, e, e, c);
          return (w.placeholder = Og.placeholder), w;
        }
        function Ng(s, c, d) {
          c = d ? e : c;
          var w = xr(s, M, e, e, e, e, e, c);
          return (w.placeholder = Ng.placeholder), w;
        }
        function Bg(s, c, d) {
          var w,
            S,
            C,
            N,
            G,
            $,
            pt = 0,
            mt = !1,
            bt = !1,
            Rt = !0;
          if (typeof s != "function") throw new wi(o);
          (c = Ei(c) || 0),
            Ye(d) &&
              ((mt = !!d.leading),
              (bt = "maxWait" in d),
              (C = bt ? cn(Ei(d.maxWait) || 0, c) : C),
              (Rt = "trailing" in d ? !!d.trailing : Rt));
          function kt(Qe) {
            var Gi = w,
              Sr = S;
            return (w = S = e), (pt = Qe), (N = s.apply(Sr, Gi)), N;
          }
          function Zt(Qe) {
            return (pt = Qe), (G = Va(le, c)), mt ? kt(Qe) : N;
          }
          function se(Qe) {
            var Gi = Qe - $,
              Sr = Qe - pt,
              n_ = c - Gi;
            return bt ? Tn(n_, C - Sr) : n_;
          }
          function jt(Qe) {
            var Gi = Qe - $,
              Sr = Qe - pt;
            return $ === e || Gi >= c || Gi < 0 || (bt && Sr >= C);
          }
          function le() {
            var Qe = bc();
            if (jt(Qe)) return he(Qe);
            G = Va(le, se(Qe));
          }
          function he(Qe) {
            return (G = e), Rt && w ? kt(Qe) : ((w = S = e), N);
          }
          function oi() {
            G !== e && qm(G), (pt = 0), (w = $ = S = G = e);
          }
          function On() {
            return G === e ? N : he(bc());
          }
          function ai() {
            var Qe = bc(),
              Gi = jt(Qe);
            if (((w = arguments), (S = this), ($ = Qe), Gi)) {
              if (G === e) return Zt($);
              if (bt) return qm(G), (G = Va(le, c)), kt($);
            }
            return G === e && (G = Va(le, c)), N;
          }
          return (ai.cancel = oi), (ai.flush = On), ai;
        }
        var i1 = ae(function (s, c) {
            return Em(s, 1, c);
          }),
          r1 = ae(function (s, c, d) {
            return Em(s, Ei(c) || 0, d);
          });
        function s1(s) {
          return xr(s, X);
        }
        function Mc(s, c) {
          if (typeof s != "function" || (c != null && typeof c != "function"))
            throw new wi(o);
          var d = function () {
            var w = arguments,
              S = c ? c.apply(this, w) : w[0],
              C = d.cache;
            if (C.has(S)) return C.get(S);
            var N = s.apply(this, w);
            return (d.cache = C.set(S, N) || C), N;
          };
          return (d.cache = new (Mc.Cache || _r)()), d;
        }
        Mc.Cache = _r;
        function Sc(s) {
          if (typeof s != "function") throw new wi(o);
          return function () {
            var c = arguments;
            switch (c.length) {
              case 0:
                return !s.call(this);
              case 1:
                return !s.call(this, c[0]);
              case 2:
                return !s.call(this, c[0], c[1]);
              case 3:
                return !s.call(this, c[0], c[1], c[2]);
            }
            return !s.apply(this, c);
          };
        }
        function o1(s) {
          return Dg(2, s);
        }
        var a1 = qb(function (s, c) {
            c =
              c.length == 1 && ne(c[0])
                ? We(c[0], ii(qt()))
                : We(xn(c, 1), ii(qt()));
            var d = c.length;
            return ae(function (w) {
              for (var S = -1, C = Tn(w.length, d); ++S < C; )
                w[S] = c[S].call(this, w[S]);
              return ni(s, this, w);
            });
          }),
          nf = ae(function (s, c) {
            var d = Hr(c, _o(nf));
            return xr(s, A, e, c, d);
          }),
          zg = ae(function (s, c) {
            var d = Hr(c, _o(zg));
            return xr(s, R, e, c, d);
          }),
          l1 = yr(function (s, c) {
            return xr(s, B, e, e, e, c);
          });
        function c1(s, c) {
          if (typeof s != "function") throw new wi(o);
          return (c = c === e ? c : ie(c)), ae(s, c);
        }
        function u1(s, c) {
          if (typeof s != "function") throw new wi(o);
          return (
            (c = c == null ? 0 : cn(ie(c), 0)),
            ae(function (d) {
              var w = d[c],
                S = qr(d, 0, c);
              return w && Gr(S, w), ni(s, this, S);
            })
          );
        }
        function h1(s, c, d) {
          var w = !0,
            S = !0;
          if (typeof s != "function") throw new wi(o);
          return (
            Ye(d) &&
              ((w = "leading" in d ? !!d.leading : w),
              (S = "trailing" in d ? !!d.trailing : S)),
            Bg(s, c, { leading: w, maxWait: c, trailing: S })
          );
        }
        function f1(s) {
          return Ig(s, 1);
        }
        function d1(s, c) {
          return nf(kh(c), s);
        }
        function p1() {
          if (!arguments.length) return [];
          var s = arguments[0];
          return ne(s) ? s : [s];
        }
        function m1(s) {
          return Mi(s, p);
        }
        function g1(s, c) {
          return (c = typeof c == "function" ? c : e), Mi(s, p, c);
        }
        function _1(s) {
          return Mi(s, m | p);
        }
        function v1(s, c) {
          return (c = typeof c == "function" ? c : e), Mi(s, m | p, c);
        }
        function x1(s, c) {
          return c == null || Tm(s, c, fn(c));
        }
        function ki(s, c) {
          return s === c || (s !== s && c !== c);
        }
        var y1 = gc(Lh),
          w1 = gc(function (s, c) {
            return s >= c;
          }),
          Ns = Pm(
            (function () {
              return arguments;
            })()
          )
            ? Pm
            : function (s) {
                return Je(s) && be.call(s, "callee") && !_m.call(s, "callee");
              },
          ne = rt.isArray,
          b1 = Kp ? ii(Kp) : Rb;
        function Xn(s) {
          return s != null && Tc(s.length) && !br(s);
        }
        function Ke(s) {
          return Je(s) && Xn(s);
        }
        function M1(s) {
          return s === !0 || s === !1 || (Je(s) && Dn(s) == U);
        }
        var Zr = Bw || pf,
          S1 = Qp ? ii(Qp) : Pb;
        function T1(s) {
          return Je(s) && s.nodeType === 1 && !Wa(s);
        }
        function E1(s) {
          if (s == null) return !0;
          if (
            Xn(s) &&
            (ne(s) ||
              typeof s == "string" ||
              typeof s.splice == "function" ||
              Zr(s) ||
              vo(s) ||
              Ns(s))
          )
            return !s.length;
          var c = En(s);
          if (c == ct || c == wt) return !s.size;
          if (Ha(s)) return !Ph(s).length;
          for (var d in s) if (be.call(s, d)) return !1;
          return !0;
        }
        function A1(s, c) {
          return Ua(s, c);
        }
        function L1(s, c, d) {
          d = typeof d == "function" ? d : e;
          var w = d ? d(s, c) : e;
          return w === e ? Ua(s, c, e, d) : !!w;
        }
        function rf(s) {
          if (!Je(s)) return !1;
          var c = Dn(s);
          return (
            c == gt ||
            c == dt ||
            (typeof s.message == "string" &&
              typeof s.name == "string" &&
              !Wa(s))
          );
        }
        function C1(s) {
          return typeof s == "number" && xm(s);
        }
        function br(s) {
          if (!Ye(s)) return !1;
          var c = Dn(s);
          return c == j || c == ot || c == F || c == lt;
        }
        function Ug(s) {
          return typeof s == "number" && s == ie(s);
        }
        function Tc(s) {
          return typeof s == "number" && s > -1 && s % 1 == 0 && s <= st;
        }
        function Ye(s) {
          var c = typeof s;
          return s != null && (c == "object" || c == "function");
        }
        function Je(s) {
          return s != null && typeof s == "object";
        }
        var kg = tm ? ii(tm) : Db;
        function R1(s, c) {
          return s === c || Rh(s, c, qh(c));
        }
        function P1(s, c, d) {
          return (d = typeof d == "function" ? d : e), Rh(s, c, qh(c), d);
        }
        function I1(s) {
          return Gg(s) && s != +s;
        }
        function D1(s) {
          if (gM(s)) throw new te(r);
          return Im(s);
        }
        function F1(s) {
          return s === null;
        }
        function O1(s) {
          return s == null;
        }
        function Gg(s) {
          return typeof s == "number" || (Je(s) && Dn(s) == St);
        }
        function Wa(s) {
          if (!Je(s) || Dn(s) != I) return !1;
          var c = Kl(s);
          if (c === null) return !0;
          var d = be.call(c, "constructor") && c.constructor;
          return typeof d == "function" && d instanceof d && Zl.call(d) == Pw;
        }
        var sf = em ? ii(em) : Fb;
        function N1(s) {
          return Ug(s) && s >= -st && s <= st;
        }
        var Hg = nm ? ii(nm) : Ob;
        function Ec(s) {
          return typeof s == "string" || (!ne(s) && Je(s) && Dn(s) == At);
        }
        function si(s) {
          return typeof s == "symbol" || (Je(s) && Dn(s) == Ht);
        }
        var vo = im ? ii(im) : Nb;
        function B1(s) {
          return s === e;
        }
        function z1(s) {
          return Je(s) && En(s) == Vt;
        }
        function U1(s) {
          return Je(s) && Dn(s) == Nt;
        }
        var k1 = gc(Ih),
          G1 = gc(function (s, c) {
            return s <= c;
          });
        function Vg(s) {
          if (!s) return [];
          if (Xn(s)) return Ec(s) ? zi(s) : Wn(s);
          if (Pa && s[Pa]) return xw(s[Pa]());
          var c = En(s),
            d = c == ct ? xh : c == wt ? Xl : xo;
          return d(s);
        }
        function Mr(s) {
          if (!s) return s === 0 ? s : 0;
          if (((s = Ei(s)), s === Q || s === -Q)) {
            var c = s < 0 ? -1 : 1;
            return c * Lt;
          }
          return s === s ? s : 0;
        }
        function ie(s) {
          var c = Mr(s),
            d = c % 1;
          return c === c ? (d ? c - d : c) : 0;
        }
        function Wg(s) {
          return s ? Is(ie(s), 0, vt) : 0;
        }
        function Ei(s) {
          if (typeof s == "number") return s;
          if (si(s)) return J;
          if (Ye(s)) {
            var c = typeof s.valueOf == "function" ? s.valueOf() : s;
            s = Ye(c) ? c + "" : c;
          }
          if (typeof s != "string") return s === 0 ? s : +s;
          s = cm(s);
          var d = Qt.test(s);
          return d || _i.test(s)
            ? nw(s.slice(2), d ? 2 : 8)
            : Wt.test(s)
            ? J
            : +s;
        }
        function Xg(s) {
          return $i(s, Yn(s));
        }
        function H1(s) {
          return s ? Is(ie(s), -st, st) : s === 0 ? s : 0;
        }
        function ye(s) {
          return s == null ? "" : ri(s);
        }
        var V1 = mo(function (s, c) {
            if (Ha(c) || Xn(c)) {
              $i(c, fn(c), s);
              return;
            }
            for (var d in c) be.call(c, d) && Na(s, d, c[d]);
          }),
          Yg = mo(function (s, c) {
            $i(c, Yn(c), s);
          }),
          Ac = mo(function (s, c, d, w) {
            $i(c, Yn(c), s, w);
          }),
          W1 = mo(function (s, c, d, w) {
            $i(c, fn(c), s, w);
          }),
          X1 = yr(Th);
        function Y1(s, c) {
          var d = po(s);
          return c == null ? d : Sm(d, c);
        }
        var q1 = ae(function (s, c) {
            s = Pe(s);
            var d = -1,
              w = c.length,
              S = w > 2 ? c[2] : e;
            for (S && Fn(c[0], c[1], S) && (w = 1); ++d < w; )
              for (var C = c[d], N = Yn(C), G = -1, $ = N.length; ++G < $; ) {
                var pt = N[G],
                  mt = s[pt];
                (mt === e || (ki(mt, uo[pt]) && !be.call(s, pt))) &&
                  (s[pt] = C[pt]);
              }
            return s;
          }),
          Z1 = ae(function (s) {
            return s.push(e, cg), ni(qg, e, s);
          });
        function j1(s, c) {
          return sm(s, qt(c, 3), Ji);
        }
        function J1(s, c) {
          return sm(s, qt(c, 3), Ah);
        }
        function $1(s, c) {
          return s == null ? s : Eh(s, qt(c, 3), Yn);
        }
        function K1(s, c) {
          return s == null ? s : Cm(s, qt(c, 3), Yn);
        }
        function Q1(s, c) {
          return s && Ji(s, qt(c, 3));
        }
        function tT(s, c) {
          return s && Ah(s, qt(c, 3));
        }
        function eT(s) {
          return s == null ? [] : lc(s, fn(s));
        }
        function nT(s) {
          return s == null ? [] : lc(s, Yn(s));
        }
        function of(s, c, d) {
          var w = s == null ? e : Ds(s, c);
          return w === e ? d : w;
        }
        function iT(s, c) {
          return s != null && fg(s, c, Eb);
        }
        function af(s, c) {
          return s != null && fg(s, c, Ab);
        }
        var rT = rg(function (s, c, d) {
            c != null && typeof c.toString != "function" && (c = jl.call(c)),
              (s[c] = d);
          }, cf(qn)),
          sT = rg(function (s, c, d) {
            c != null && typeof c.toString != "function" && (c = jl.call(c)),
              be.call(s, c) ? s[c].push(d) : (s[c] = [d]);
          }, qt),
          oT = ae(za);
        function fn(s) {
          return Xn(s) ? bm(s) : Ph(s);
        }
        function Yn(s) {
          return Xn(s) ? bm(s, !0) : Bb(s);
        }
        function aT(s, c) {
          var d = {};
          return (
            (c = qt(c, 3)),
            Ji(s, function (w, S, C) {
              vr(d, c(w, S, C), w);
            }),
            d
          );
        }
        function lT(s, c) {
          var d = {};
          return (
            (c = qt(c, 3)),
            Ji(s, function (w, S, C) {
              vr(d, S, c(w, S, C));
            }),
            d
          );
        }
        var cT = mo(function (s, c, d) {
            cc(s, c, d);
          }),
          qg = mo(function (s, c, d, w) {
            cc(s, c, d, w);
          }),
          uT = yr(function (s, c) {
            var d = {};
            if (s == null) return d;
            var w = !1;
            (c = We(c, function (C) {
              return (C = Yr(C, s)), w || (w = C.length > 1), C;
            })),
              $i(s, Xh(s), d),
              w && (d = Mi(d, m | g | p, rM));
            for (var S = c.length; S--; ) Bh(d, c[S]);
            return d;
          });
        function hT(s, c) {
          return Zg(s, Sc(qt(c)));
        }
        var fT = yr(function (s, c) {
          return s == null ? {} : Ub(s, c);
        });
        function Zg(s, c) {
          if (s == null) return {};
          var d = We(Xh(s), function (w) {
            return [w];
          });
          return (
            (c = qt(c)),
            Um(s, d, function (w, S) {
              return c(w, S[0]);
            })
          );
        }
        function dT(s, c, d) {
          c = Yr(c, s);
          var w = -1,
            S = c.length;
          for (S || ((S = 1), (s = e)); ++w < S; ) {
            var C = s == null ? e : s[Ki(c[w])];
            C === e && ((w = S), (C = d)), (s = br(C) ? C.call(s) : C);
          }
          return s;
        }
        function pT(s, c, d) {
          return s == null ? s : ka(s, c, d);
        }
        function mT(s, c, d, w) {
          return (
            (w = typeof w == "function" ? w : e), s == null ? s : ka(s, c, d, w)
          );
        }
        var jg = ag(fn),
          Jg = ag(Yn);
        function gT(s, c, d) {
          var w = ne(s),
            S = w || Zr(s) || vo(s);
          if (((c = qt(c, 4)), d == null)) {
            var C = s && s.constructor;
            S
              ? (d = w ? new C() : [])
              : Ye(s)
              ? (d = br(C) ? po(Kl(s)) : {})
              : (d = {});
          }
          return (
            (S ? yi : Ji)(s, function (N, G, $) {
              return c(d, N, G, $);
            }),
            d
          );
        }
        function _T(s, c) {
          return s == null ? !0 : Bh(s, c);
        }
        function vT(s, c, d) {
          return s == null ? s : Wm(s, c, kh(d));
        }
        function xT(s, c, d, w) {
          return (
            (w = typeof w == "function" ? w : e),
            s == null ? s : Wm(s, c, kh(d), w)
          );
        }
        function xo(s) {
          return s == null ? [] : vh(s, fn(s));
        }
        function yT(s) {
          return s == null ? [] : vh(s, Yn(s));
        }
        function wT(s, c, d) {
          return (
            d === e && ((d = c), (c = e)),
            d !== e && ((d = Ei(d)), (d = d === d ? d : 0)),
            c !== e && ((c = Ei(c)), (c = c === c ? c : 0)),
            Is(Ei(s), c, d)
          );
        }
        function bT(s, c, d) {
          return (
            (c = Mr(c)),
            d === e ? ((d = c), (c = 0)) : (d = Mr(d)),
            (s = Ei(s)),
            Lb(s, c, d)
          );
        }
        function MT(s, c, d) {
          if (
            (d && typeof d != "boolean" && Fn(s, c, d) && (c = d = e),
            d === e &&
              (typeof c == "boolean"
                ? ((d = c), (c = e))
                : typeof s == "boolean" && ((d = s), (s = e))),
            s === e && c === e
              ? ((s = 0), (c = 1))
              : ((s = Mr(s)), c === e ? ((c = s), (s = 0)) : (c = Mr(c))),
            s > c)
          ) {
            var w = s;
            (s = c), (c = w);
          }
          if (d || s % 1 || c % 1) {
            var S = ym();
            return Tn(s + S * (c - s + ew("1e-" + ((S + "").length - 1))), c);
          }
          return Fh(s, c);
        }
        var ST = go(function (s, c, d) {
          return (c = c.toLowerCase()), s + (d ? $g(c) : c);
        });
        function $g(s) {
          return lf(ye(s).toLowerCase());
        }
        function Kg(s) {
          return (s = ye(s)), s && s.replace(dr, pw).replace(Xy, "");
        }
        function TT(s, c, d) {
          (s = ye(s)), (c = ri(c));
          var w = s.length;
          d = d === e ? w : Is(ie(d), 0, w);
          var S = d;
          return (d -= c.length), d >= 0 && s.slice(d, S) == c;
        }
        function ET(s) {
          return (s = ye(s)), s && ro.test(s) ? s.replace(Hn, mw) : s;
        }
        function AT(s) {
          return (s = ye(s)), s && Re.test(s) ? s.replace(Ce, "\\$&") : s;
        }
        var LT = go(function (s, c, d) {
            return s + (d ? "-" : "") + c.toLowerCase();
          }),
          CT = go(function (s, c, d) {
            return s + (d ? " " : "") + c.toLowerCase();
          }),
          RT = eg("toLowerCase");
        function PT(s, c, d) {
          (s = ye(s)), (c = ie(c));
          var w = c ? lo(s) : 0;
          if (!c || w >= c) return s;
          var S = (c - w) / 2;
          return mc(nc(S), d) + s + mc(ec(S), d);
        }
        function IT(s, c, d) {
          (s = ye(s)), (c = ie(c));
          var w = c ? lo(s) : 0;
          return c && w < c ? s + mc(c - w, d) : s;
        }
        function DT(s, c, d) {
          (s = ye(s)), (c = ie(c));
          var w = c ? lo(s) : 0;
          return c && w < c ? mc(c - w, d) + s : s;
        }
        function FT(s, c, d) {
          return (
            d || c == null ? (c = 0) : c && (c = +c),
            Gw(ye(s).replace(D, ""), c || 0)
          );
        }
        function OT(s, c, d) {
          return (
            (d ? Fn(s, c, d) : c === e) ? (c = 1) : (c = ie(c)), Oh(ye(s), c)
          );
        }
        function NT() {
          var s = arguments,
            c = ye(s[0]);
          return s.length < 3 ? c : c.replace(s[1], s[2]);
        }
        var BT = go(function (s, c, d) {
          return s + (d ? "_" : "") + c.toLowerCase();
        });
        function zT(s, c, d) {
          return (
            d && typeof d != "number" && Fn(s, c, d) && (c = d = e),
            (d = d === e ? vt : d >>> 0),
            d
              ? ((s = ye(s)),
                s &&
                (typeof c == "string" || (c != null && !sf(c))) &&
                ((c = ri(c)), !c && ao(s))
                  ? qr(zi(s), 0, d)
                  : s.split(c, d))
              : []
          );
        }
        var UT = go(function (s, c, d) {
          return s + (d ? " " : "") + lf(c);
        });
        function kT(s, c, d) {
          return (
            (s = ye(s)),
            (d = d == null ? 0 : Is(ie(d), 0, s.length)),
            (c = ri(c)),
            s.slice(d, d + c.length) == c
          );
        }
        function GT(s, c, d) {
          var w = L.templateSettings;
          d && Fn(s, c, d) && (c = e), (s = ye(s)), (c = Ac({}, c, w, lg));
          var S = Ac({}, c.imports, w.imports, lg),
            C = fn(S),
            N = vh(S, C),
            G,
            $,
            pt = 0,
            mt = c.interpolate || xe,
            bt = "__p += '",
            Rt = yh(
              (c.escape || xe).source +
                "|" +
                mt.source +
                "|" +
                (mt === ge ? $t : xe).source +
                "|" +
                (c.evaluate || xe).source +
                "|$",
              "g"
            ),
            kt =
              "//# sourceURL=" +
              (be.call(c, "sourceURL")
                ? (c.sourceURL + "").replace(/\s/g, " ")
                : "lodash.templateSources[" + ++Jy + "]") +
              `
`;
          s.replace(Rt, function (jt, le, he, oi, On, ai) {
            return (
              he || (he = oi),
              (bt += s.slice(pt, ai).replace(pr, gw)),
              le &&
                ((G = !0),
                (bt +=
                  `' +
__e(` +
                  le +
                  `) +
'`)),
              On &&
                (($ = !0),
                (bt +=
                  `';
` +
                  On +
                  `;
__p += '`)),
              he &&
                (bt +=
                  `' +
((__t = (` +
                  he +
                  `)) == null ? '' : __t) +
'`),
              (pt = ai + jt.length),
              jt
            );
          }),
            (bt += `';
`);
          var Zt = be.call(c, "variable") && c.variable;
          if (!Zt)
            bt =
              `with (obj) {
` +
              bt +
              `
}
`;
          else if (It.test(Zt)) throw new te(l);
          (bt = ($ ? bt.replace(rn, "") : bt)
            .replace(hr, "$1")
            .replace(Zi, "$1;")),
            (bt =
              "function(" +
              (Zt || "obj") +
              `) {
` +
              (Zt
                ? ""
                : `obj || (obj = {});
`) +
              "var __t, __p = ''" +
              (G ? ", __e = _.escape" : "") +
              ($
                ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`
                : `;
`) +
              bt +
              `return __p
}`);
          var se = t_(function () {
            return _e(C, kt + "return " + bt).apply(e, N);
          });
          if (((se.source = bt), rf(se))) throw se;
          return se;
        }
        function HT(s) {
          return ye(s).toLowerCase();
        }
        function VT(s) {
          return ye(s).toUpperCase();
        }
        function WT(s, c, d) {
          if (((s = ye(s)), s && (d || c === e))) return cm(s);
          if (!s || !(c = ri(c))) return s;
          var w = zi(s),
            S = zi(c),
            C = um(w, S),
            N = hm(w, S) + 1;
          return qr(w, C, N).join("");
        }
        function XT(s, c, d) {
          if (((s = ye(s)), s && (d || c === e))) return s.slice(0, dm(s) + 1);
          if (!s || !(c = ri(c))) return s;
          var w = zi(s),
            S = hm(w, zi(c)) + 1;
          return qr(w, 0, S).join("");
        }
        function YT(s, c, d) {
          if (((s = ye(s)), s && (d || c === e))) return s.replace(D, "");
          if (!s || !(c = ri(c))) return s;
          var w = zi(s),
            S = um(w, zi(c));
          return qr(w, S).join("");
        }
        function qT(s, c) {
          var d = H,
            w = O;
          if (Ye(c)) {
            var S = "separator" in c ? c.separator : S;
            (d = "length" in c ? ie(c.length) : d),
              (w = "omission" in c ? ri(c.omission) : w);
          }
          s = ye(s);
          var C = s.length;
          if (ao(s)) {
            var N = zi(s);
            C = N.length;
          }
          if (d >= C) return s;
          var G = d - lo(w);
          if (G < 1) return w;
          var $ = N ? qr(N, 0, G).join("") : s.slice(0, G);
          if (S === e) return $ + w;
          if ((N && (G += $.length - G), sf(S))) {
            if (s.slice(G).search(S)) {
              var pt,
                mt = $;
              for (
                S.global || (S = yh(S.source, ye(Yt.exec(S)) + "g")),
                  S.lastIndex = 0;
                (pt = S.exec(mt));

              )
                var bt = pt.index;
              $ = $.slice(0, bt === e ? G : bt);
            }
          } else if (s.indexOf(ri(S), G) != G) {
            var Rt = $.lastIndexOf(S);
            Rt > -1 && ($ = $.slice(0, Rt));
          }
          return $ + w;
        }
        function ZT(s) {
          return (s = ye(s)), s && As.test(s) ? s.replace(fr, Mw) : s;
        }
        var jT = go(function (s, c, d) {
            return s + (d ? " " : "") + c.toUpperCase();
          }),
          lf = eg("toUpperCase");
        function Qg(s, c, d) {
          return (
            (s = ye(s)),
            (c = d ? e : c),
            c === e ? (vw(s) ? Ew(s) : cw(s)) : s.match(c) || []
          );
        }
        var t_ = ae(function (s, c) {
            try {
              return ni(s, e, c);
            } catch (d) {
              return rf(d) ? d : new te(d);
            }
          }),
          JT = yr(function (s, c) {
            return (
              yi(c, function (d) {
                (d = Ki(d)), vr(s, d, ef(s[d], s));
              }),
              s
            );
          });
        function $T(s) {
          var c = s == null ? 0 : s.length,
            d = qt();
          return (
            (s = c
              ? We(s, function (w) {
                  if (typeof w[1] != "function") throw new wi(o);
                  return [d(w[0]), w[1]];
                })
              : []),
            ae(function (w) {
              for (var S = -1; ++S < c; ) {
                var C = s[S];
                if (ni(C[0], this, w)) return ni(C[1], this, w);
              }
            })
          );
        }
        function KT(s) {
          return Mb(Mi(s, m));
        }
        function cf(s) {
          return function () {
            return s;
          };
        }
        function QT(s, c) {
          return s == null || s !== s ? c : s;
        }
        var tE = ig(),
          eE = ig(!0);
        function qn(s) {
          return s;
        }
        function uf(s) {
          return Dm(typeof s == "function" ? s : Mi(s, m));
        }
        function nE(s) {
          return Om(Mi(s, m));
        }
        function iE(s, c) {
          return Nm(s, Mi(c, m));
        }
        var rE = ae(function (s, c) {
            return function (d) {
              return za(d, s, c);
            };
          }),
          sE = ae(function (s, c) {
            return function (d) {
              return za(s, d, c);
            };
          });
        function hf(s, c, d) {
          var w = fn(c),
            S = lc(c, w);
          d == null &&
            !(Ye(c) && (S.length || !w.length)) &&
            ((d = c), (c = s), (s = this), (S = lc(c, fn(c))));
          var C = !(Ye(d) && "chain" in d) || !!d.chain,
            N = br(s);
          return (
            yi(S, function (G) {
              var $ = c[G];
              (s[G] = $),
                N &&
                  (s.prototype[G] = function () {
                    var pt = this.__chain__;
                    if (C || pt) {
                      var mt = s(this.__wrapped__),
                        bt = (mt.__actions__ = Wn(this.__actions__));
                      return (
                        bt.push({ func: $, args: arguments, thisArg: s }),
                        (mt.__chain__ = pt),
                        mt
                      );
                    }
                    return $.apply(s, Gr([this.value()], arguments));
                  });
            }),
            s
          );
        }
        function oE() {
          return vn._ === this && (vn._ = Iw), this;
        }
        function ff() {}
        function aE(s) {
          return (
            (s = ie(s)),
            ae(function (c) {
              return Bm(c, s);
            })
          );
        }
        var lE = Hh(We),
          cE = Hh(rm),
          uE = Hh(dh);
        function e_(s) {
          return jh(s) ? ph(Ki(s)) : kb(s);
        }
        function hE(s) {
          return function (c) {
            return s == null ? e : Ds(s, c);
          };
        }
        var fE = sg(),
          dE = sg(!0);
        function df() {
          return [];
        }
        function pf() {
          return !1;
        }
        function pE() {
          return {};
        }
        function mE() {
          return "";
        }
        function gE() {
          return !0;
        }
        function _E(s, c) {
          if (((s = ie(s)), s < 1 || s > st)) return [];
          var d = vt,
            w = Tn(s, vt);
          (c = qt(c)), (s -= vt);
          for (var S = _h(w, c); ++d < s; ) c(d);
          return S;
        }
        function vE(s) {
          return ne(s) ? We(s, Ki) : si(s) ? [s] : Wn(wg(ye(s)));
        }
        function xE(s) {
          var c = ++Rw;
          return ye(s) + c;
        }
        var yE = pc(function (s, c) {
            return s + c;
          }, 0),
          wE = Vh("ceil"),
          bE = pc(function (s, c) {
            return s / c;
          }, 1),
          ME = Vh("floor");
        function SE(s) {
          return s && s.length ? ac(s, qn, Lh) : e;
        }
        function TE(s, c) {
          return s && s.length ? ac(s, qt(c, 2), Lh) : e;
        }
        function EE(s) {
          return am(s, qn);
        }
        function AE(s, c) {
          return am(s, qt(c, 2));
        }
        function LE(s) {
          return s && s.length ? ac(s, qn, Ih) : e;
        }
        function CE(s, c) {
          return s && s.length ? ac(s, qt(c, 2), Ih) : e;
        }
        var RE = pc(function (s, c) {
            return s * c;
          }, 1),
          PE = Vh("round"),
          IE = pc(function (s, c) {
            return s - c;
          }, 0);
        function DE(s) {
          return s && s.length ? gh(s, qn) : 0;
        }
        function FE(s, c) {
          return s && s.length ? gh(s, qt(c, 2)) : 0;
        }
        return (
          (L.after = n1),
          (L.ary = Ig),
          (L.assign = V1),
          (L.assignIn = Yg),
          (L.assignInWith = Ac),
          (L.assignWith = W1),
          (L.at = X1),
          (L.before = Dg),
          (L.bind = ef),
          (L.bindAll = JT),
          (L.bindKey = Fg),
          (L.castArray = p1),
          (L.chain = Cg),
          (L.chunk = MM),
          (L.compact = SM),
          (L.concat = TM),
          (L.cond = $T),
          (L.conforms = KT),
          (L.constant = cf),
          (L.countBy = DS),
          (L.create = Y1),
          (L.curry = Og),
          (L.curryRight = Ng),
          (L.debounce = Bg),
          (L.defaults = q1),
          (L.defaultsDeep = Z1),
          (L.defer = i1),
          (L.delay = r1),
          (L.difference = EM),
          (L.differenceBy = AM),
          (L.differenceWith = LM),
          (L.drop = CM),
          (L.dropRight = RM),
          (L.dropRightWhile = PM),
          (L.dropWhile = IM),
          (L.fill = DM),
          (L.filter = OS),
          (L.flatMap = zS),
          (L.flatMapDeep = US),
          (L.flatMapDepth = kS),
          (L.flatten = Tg),
          (L.flattenDeep = FM),
          (L.flattenDepth = OM),
          (L.flip = s1),
          (L.flow = tE),
          (L.flowRight = eE),
          (L.fromPairs = NM),
          (L.functions = eT),
          (L.functionsIn = nT),
          (L.groupBy = GS),
          (L.initial = zM),
          (L.intersection = UM),
          (L.intersectionBy = kM),
          (L.intersectionWith = GM),
          (L.invert = rT),
          (L.invertBy = sT),
          (L.invokeMap = VS),
          (L.iteratee = uf),
          (L.keyBy = WS),
          (L.keys = fn),
          (L.keysIn = Yn),
          (L.map = wc),
          (L.mapKeys = aT),
          (L.mapValues = lT),
          (L.matches = nE),
          (L.matchesProperty = iE),
          (L.memoize = Mc),
          (L.merge = cT),
          (L.mergeWith = qg),
          (L.method = rE),
          (L.methodOf = sE),
          (L.mixin = hf),
          (L.negate = Sc),
          (L.nthArg = aE),
          (L.omit = uT),
          (L.omitBy = hT),
          (L.once = o1),
          (L.orderBy = XS),
          (L.over = lE),
          (L.overArgs = a1),
          (L.overEvery = cE),
          (L.overSome = uE),
          (L.partial = nf),
          (L.partialRight = zg),
          (L.partition = YS),
          (L.pick = fT),
          (L.pickBy = Zg),
          (L.property = e_),
          (L.propertyOf = hE),
          (L.pull = XM),
          (L.pullAll = Ag),
          (L.pullAllBy = YM),
          (L.pullAllWith = qM),
          (L.pullAt = ZM),
          (L.range = fE),
          (L.rangeRight = dE),
          (L.rearg = l1),
          (L.reject = jS),
          (L.remove = jM),
          (L.rest = c1),
          (L.reverse = Qh),
          (L.sampleSize = $S),
          (L.set = pT),
          (L.setWith = mT),
          (L.shuffle = KS),
          (L.slice = JM),
          (L.sortBy = e1),
          (L.sortedUniq = iS),
          (L.sortedUniqBy = rS),
          (L.split = zT),
          (L.spread = u1),
          (L.tail = sS),
          (L.take = oS),
          (L.takeRight = aS),
          (L.takeRightWhile = lS),
          (L.takeWhile = cS),
          (L.tap = SS),
          (L.throttle = h1),
          (L.thru = yc),
          (L.toArray = Vg),
          (L.toPairs = jg),
          (L.toPairsIn = Jg),
          (L.toPath = vE),
          (L.toPlainObject = Xg),
          (L.transform = gT),
          (L.unary = f1),
          (L.union = uS),
          (L.unionBy = hS),
          (L.unionWith = fS),
          (L.uniq = dS),
          (L.uniqBy = pS),
          (L.uniqWith = mS),
          (L.unset = _T),
          (L.unzip = tf),
          (L.unzipWith = Lg),
          (L.update = vT),
          (L.updateWith = xT),
          (L.values = xo),
          (L.valuesIn = yT),
          (L.without = gS),
          (L.words = Qg),
          (L.wrap = d1),
          (L.xor = _S),
          (L.xorBy = vS),
          (L.xorWith = xS),
          (L.zip = yS),
          (L.zipObject = wS),
          (L.zipObjectDeep = bS),
          (L.zipWith = MS),
          (L.entries = jg),
          (L.entriesIn = Jg),
          (L.extend = Yg),
          (L.extendWith = Ac),
          hf(L, L),
          (L.add = yE),
          (L.attempt = t_),
          (L.camelCase = ST),
          (L.capitalize = $g),
          (L.ceil = wE),
          (L.clamp = wT),
          (L.clone = m1),
          (L.cloneDeep = _1),
          (L.cloneDeepWith = v1),
          (L.cloneWith = g1),
          (L.conformsTo = x1),
          (L.deburr = Kg),
          (L.defaultTo = QT),
          (L.divide = bE),
          (L.endsWith = TT),
          (L.eq = ki),
          (L.escape = ET),
          (L.escapeRegExp = AT),
          (L.every = FS),
          (L.find = NS),
          (L.findIndex = Mg),
          (L.findKey = j1),
          (L.findLast = BS),
          (L.findLastIndex = Sg),
          (L.findLastKey = J1),
          (L.floor = ME),
          (L.forEach = Rg),
          (L.forEachRight = Pg),
          (L.forIn = $1),
          (L.forInRight = K1),
          (L.forOwn = Q1),
          (L.forOwnRight = tT),
          (L.get = of),
          (L.gt = y1),
          (L.gte = w1),
          (L.has = iT),
          (L.hasIn = af),
          (L.head = Eg),
          (L.identity = qn),
          (L.includes = HS),
          (L.indexOf = BM),
          (L.inRange = bT),
          (L.invoke = oT),
          (L.isArguments = Ns),
          (L.isArray = ne),
          (L.isArrayBuffer = b1),
          (L.isArrayLike = Xn),
          (L.isArrayLikeObject = Ke),
          (L.isBoolean = M1),
          (L.isBuffer = Zr),
          (L.isDate = S1),
          (L.isElement = T1),
          (L.isEmpty = E1),
          (L.isEqual = A1),
          (L.isEqualWith = L1),
          (L.isError = rf),
          (L.isFinite = C1),
          (L.isFunction = br),
          (L.isInteger = Ug),
          (L.isLength = Tc),
          (L.isMap = kg),
          (L.isMatch = R1),
          (L.isMatchWith = P1),
          (L.isNaN = I1),
          (L.isNative = D1),
          (L.isNil = O1),
          (L.isNull = F1),
          (L.isNumber = Gg),
          (L.isObject = Ye),
          (L.isObjectLike = Je),
          (L.isPlainObject = Wa),
          (L.isRegExp = sf),
          (L.isSafeInteger = N1),
          (L.isSet = Hg),
          (L.isString = Ec),
          (L.isSymbol = si),
          (L.isTypedArray = vo),
          (L.isUndefined = B1),
          (L.isWeakMap = z1),
          (L.isWeakSet = U1),
          (L.join = HM),
          (L.kebabCase = LT),
          (L.last = Ti),
          (L.lastIndexOf = VM),
          (L.lowerCase = CT),
          (L.lowerFirst = RT),
          (L.lt = k1),
          (L.lte = G1),
          (L.max = SE),
          (L.maxBy = TE),
          (L.mean = EE),
          (L.meanBy = AE),
          (L.min = LE),
          (L.minBy = CE),
          (L.stubArray = df),
          (L.stubFalse = pf),
          (L.stubObject = pE),
          (L.stubString = mE),
          (L.stubTrue = gE),
          (L.multiply = RE),
          (L.nth = WM),
          (L.noConflict = oE),
          (L.noop = ff),
          (L.now = bc),
          (L.pad = PT),
          (L.padEnd = IT),
          (L.padStart = DT),
          (L.parseInt = FT),
          (L.random = MT),
          (L.reduce = qS),
          (L.reduceRight = ZS),
          (L.repeat = OT),
          (L.replace = NT),
          (L.result = dT),
          (L.round = PE),
          (L.runInContext = Z),
          (L.sample = JS),
          (L.size = QS),
          (L.snakeCase = BT),
          (L.some = t1),
          (L.sortedIndex = $M),
          (L.sortedIndexBy = KM),
          (L.sortedIndexOf = QM),
          (L.sortedLastIndex = tS),
          (L.sortedLastIndexBy = eS),
          (L.sortedLastIndexOf = nS),
          (L.startCase = UT),
          (L.startsWith = kT),
          (L.subtract = IE),
          (L.sum = DE),
          (L.sumBy = FE),
          (L.template = GT),
          (L.times = _E),
          (L.toFinite = Mr),
          (L.toInteger = ie),
          (L.toLength = Wg),
          (L.toLower = HT),
          (L.toNumber = Ei),
          (L.toSafeInteger = H1),
          (L.toString = ye),
          (L.toUpper = VT),
          (L.trim = WT),
          (L.trimEnd = XT),
          (L.trimStart = YT),
          (L.truncate = qT),
          (L.unescape = ZT),
          (L.uniqueId = xE),
          (L.upperCase = jT),
          (L.upperFirst = lf),
          (L.each = Rg),
          (L.eachRight = Pg),
          (L.first = Eg),
          hf(
            L,
            (function () {
              var s = {};
              return (
                Ji(L, function (c, d) {
                  be.call(L.prototype, d) || (s[d] = c);
                }),
                s
              );
            })(),
            { chain: !1 }
          ),
          (L.VERSION = n),
          yi(
            [
              "bind",
              "bindKey",
              "curry",
              "curryRight",
              "partial",
              "partialRight",
            ],
            function (s) {
              L[s].placeholder = L;
            }
          ),
          yi(["drop", "take"], function (s, c) {
            (ue.prototype[s] = function (d) {
              d = d === e ? 1 : cn(ie(d), 0);
              var w = this.__filtered__ && !c ? new ue(this) : this.clone();
              return (
                w.__filtered__
                  ? (w.__takeCount__ = Tn(d, w.__takeCount__))
                  : w.__views__.push({
                      size: Tn(d, vt),
                      type: s + (w.__dir__ < 0 ? "Right" : ""),
                    }),
                w
              );
            }),
              (ue.prototype[s + "Right"] = function (d) {
                return this.reverse()[s](d).reverse();
              });
          }),
          yi(["filter", "map", "takeWhile"], function (s, c) {
            var d = c + 1,
              w = d == q || d == V;
            ue.prototype[s] = function (S) {
              var C = this.clone();
              return (
                C.__iteratees__.push({ iteratee: qt(S, 3), type: d }),
                (C.__filtered__ = C.__filtered__ || w),
                C
              );
            };
          }),
          yi(["head", "last"], function (s, c) {
            var d = "take" + (c ? "Right" : "");
            ue.prototype[s] = function () {
              return this[d](1).value()[0];
            };
          }),
          yi(["initial", "tail"], function (s, c) {
            var d = "drop" + (c ? "" : "Right");
            ue.prototype[s] = function () {
              return this.__filtered__ ? new ue(this) : this[d](1);
            };
          }),
          (ue.prototype.compact = function () {
            return this.filter(qn);
          }),
          (ue.prototype.find = function (s) {
            return this.filter(s).head();
          }),
          (ue.prototype.findLast = function (s) {
            return this.reverse().find(s);
          }),
          (ue.prototype.invokeMap = ae(function (s, c) {
            return typeof s == "function"
              ? new ue(this)
              : this.map(function (d) {
                  return za(d, s, c);
                });
          })),
          (ue.prototype.reject = function (s) {
            return this.filter(Sc(qt(s)));
          }),
          (ue.prototype.slice = function (s, c) {
            s = ie(s);
            var d = this;
            return d.__filtered__ && (s > 0 || c < 0)
              ? new ue(d)
              : (s < 0 ? (d = d.takeRight(-s)) : s && (d = d.drop(s)),
                c !== e &&
                  ((c = ie(c)), (d = c < 0 ? d.dropRight(-c) : d.take(c - s))),
                d);
          }),
          (ue.prototype.takeRightWhile = function (s) {
            return this.reverse().takeWhile(s).reverse();
          }),
          (ue.prototype.toArray = function () {
            return this.take(vt);
          }),
          Ji(ue.prototype, function (s, c) {
            var d = /^(?:filter|find|map|reject)|While$/.test(c),
              w = /^(?:head|last)$/.test(c),
              S = L[w ? "take" + (c == "last" ? "Right" : "") : c],
              C = w || /^find/.test(c);
            !S ||
              (L.prototype[c] = function () {
                var N = this.__wrapped__,
                  G = w ? [1] : arguments,
                  $ = N instanceof ue,
                  pt = G[0],
                  mt = $ || ne(N),
                  bt = function (le) {
                    var he = S.apply(L, Gr([le], G));
                    return w && Rt ? he[0] : he;
                  };
                mt &&
                  d &&
                  typeof pt == "function" &&
                  pt.length != 1 &&
                  ($ = mt = !1);
                var Rt = this.__chain__,
                  kt = !!this.__actions__.length,
                  Zt = C && !Rt,
                  se = $ && !kt;
                if (!C && mt) {
                  N = se ? N : new ue(this);
                  var jt = s.apply(N, G);
                  return (
                    jt.__actions__.push({ func: yc, args: [bt], thisArg: e }),
                    new bi(jt, Rt)
                  );
                }
                return Zt && se
                  ? s.apply(this, G)
                  : ((jt = this.thru(bt)),
                    Zt ? (w ? jt.value()[0] : jt.value()) : jt);
              });
          }),
          yi(
            ["pop", "push", "shift", "sort", "splice", "unshift"],
            function (s) {
              var c = Yl[s],
                d = /^(?:push|sort|unshift)$/.test(s) ? "tap" : "thru",
                w = /^(?:pop|shift)$/.test(s);
              L.prototype[s] = function () {
                var S = arguments;
                if (w && !this.__chain__) {
                  var C = this.value();
                  return c.apply(ne(C) ? C : [], S);
                }
                return this[d](function (N) {
                  return c.apply(ne(N) ? N : [], S);
                });
              };
            }
          ),
          Ji(ue.prototype, function (s, c) {
            var d = L[c];
            if (d) {
              var w = d.name + "";
              be.call(fo, w) || (fo[w] = []), fo[w].push({ name: c, func: d });
            }
          }),
          (fo[dc(e, _).name] = [{ name: "wrapper", func: e }]),
          (ue.prototype.clone = Zw),
          (ue.prototype.reverse = jw),
          (ue.prototype.value = Jw),
          (L.prototype.at = TS),
          (L.prototype.chain = ES),
          (L.prototype.commit = AS),
          (L.prototype.next = LS),
          (L.prototype.plant = RS),
          (L.prototype.reverse = PS),
          (L.prototype.toJSON = L.prototype.valueOf = L.prototype.value = IS),
          (L.prototype.first = L.prototype.head),
          Pa && (L.prototype[Pa] = CS),
          L
        );
      },
      co = Aw();
    Ls ? (((Ls.exports = co)._ = co), (ch._ = co)) : (vn._ = co);
  }.call(Bs));
})(g_, g_.exports);
function Tr(a) {
  if (a === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return a;
}
function __(a, t) {
  (a.prototype = Object.create(t.prototype)),
    (a.prototype.constructor = a),
    (a.__proto__ = t);
}
/*!
 * GSAP 3.8.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Zn = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  wo = { duration: 0.5, overwrite: !1, delay: 0 },
  gf,
  Qi = 1e8,
  Ie = 1 / Qi,
  _f = Math.PI * 2,
  XE = _f / 4,
  YE = 0,
  v_ = Math.sqrt,
  qE = Math.cos,
  ZE = Math.sin,
  yn = function (t) {
    return typeof t == "string";
  },
  dn = function (t) {
    return typeof t == "function";
  },
  Er = function (t) {
    return typeof t == "number";
  },
  vf = function (t) {
    return typeof t == "undefined";
  },
  Ar = function (t) {
    return typeof t == "object";
  },
  jn = function (t) {
    return t !== !1;
  },
  x_ = function () {
    return typeof window != "undefined";
  },
  y_ = function (t) {
    return dn(t) || yn(t);
  },
  w_ =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  li = Array.isArray,
  xf = /(?:-?\.?\d|\.)+/gi,
  b_ = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  bo = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  yf = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  M_ = /[+-]=-?[.\d]+/,
  S_ = /[^,'"\[\]\s]+/gi,
  jE = /[\d.+\-=]+(?:e[-+]\d*)*/i,
  qe,
  tr,
  wf,
  bf,
  ci = {},
  Rc = {},
  T_,
  E_ = function (t) {
    return (Rc = So(t, ci)) && nr;
  },
  Mf = function (t, e) {
    return console.warn(
      "Invalid property",
      t,
      "set to",
      e,
      "Missing plugin? gsap.registerPlugin()"
    );
  },
  Pc = function (t, e) {
    return !e && console.warn(t);
  },
  A_ = function (t, e) {
    return (t && (ci[t] = e) && Rc && (Rc[t] = e)) || ci;
  },
  Mo = function () {
    return 0;
  },
  Sf = {},
  jr = [],
  Tf = {},
  L_,
  ui = {},
  Ef = {},
  C_ = 30,
  Ic = [],
  Af = "",
  Lf = function (t) {
    var e = t[0],
      n,
      i;
    if ((Ar(e) || dn(e) || (t = [t]), !(n = (e._gsap || {}).harness))) {
      for (i = Ic.length; i-- && !Ic[i].targetTest(e); );
      n = Ic[i];
    }
    for (i = t.length; i--; )
      (t[i] && (t[i]._gsap || (t[i]._gsap = new n0(t[i], n)))) ||
        t.splice(i, 1);
    return t;
  },
  zs = function (t) {
    return t._gsap || Lf(Ci(t))[0]._gsap;
  },
  R_ = function (t, e, n) {
    return (n = t[e]) && dn(n)
      ? t[e]()
      : (vf(n) && t.getAttribute && t.getAttribute(e)) || n;
  },
  hi = function (t, e) {
    return (t = t.split(",")).forEach(e) || t;
  },
  sn = function (t) {
    return Math.round(t * 1e5) / 1e5 || 0;
  },
  An = function (t) {
    return Math.round(t * 1e7) / 1e7 || 0;
  },
  JE = function (t, e) {
    for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
    return i < n;
  },
  Dc = function () {
    var t = jr.length,
      e = jr.slice(0),
      n,
      i;
    for (Tf = {}, jr.length = 0, n = 0; n < t; n++)
      (i = e[n]),
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
  },
  P_ = function (t, e, n, i) {
    jr.length && Dc(), t.render(e, n, i), jr.length && Dc();
  },
  I_ = function (t) {
    var e = parseFloat(t);
    return (e || e === 0) && (t + "").match(S_).length < 2
      ? e
      : yn(t)
      ? t.trim()
      : t;
  },
  D_ = function (t) {
    return t;
  },
  Ai = function (t, e) {
    for (var n in e) n in t || (t[n] = e[n]);
    return t;
  },
  $E = function (t, e) {
    for (var n in e)
      n in t || n === "duration" || n === "ease" || (t[n] = e[n]);
  },
  So = function (t, e) {
    for (var n in e) t[n] = e[n];
    return t;
  },
  F_ = function a(t, e) {
    for (var n in e)
      n !== "__proto__" &&
        n !== "constructor" &&
        n !== "prototype" &&
        (t[n] = Ar(e[n]) ? a(t[n] || (t[n] = {}), e[n]) : e[n]);
    return t;
  },
  Cf = function (t, e) {
    var n = {},
      i;
    for (i in t) i in e || (n[i] = t[i]);
    return n;
  },
  Xa = function (t) {
    var e = t.parent || qe,
      n = t.keyframes ? $E : Ai;
    if (jn(t.inherit))
      for (; e; ) n(t, e.vars.defaults), (e = e.parent || e._dp);
    return t;
  },
  KE = function (t, e) {
    for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n]; );
    return n < 0;
  },
  QE = function (t, e, n, i, r) {
    n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
    var o = t[i],
      l;
    if (r) for (l = e[r]; o && o[r] > l; ) o = o._prev;
    return (
      o ? ((e._next = o._next), (o._next = e)) : ((e._next = t[n]), (t[n] = e)),
      e._next ? (e._next._prev = e) : (t[i] = e),
      (e._prev = o),
      (e.parent = e._dp = t),
      e
    );
  },
  Fc = function (t, e, n, i) {
    n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
    var r = e._prev,
      o = e._next;
    r ? (r._next = o) : t[n] === e && (t[n] = o),
      o ? (o._prev = r) : t[i] === e && (t[i] = r),
      (e._next = e._prev = e.parent = null);
  },
  Jr = function (t, e) {
    t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t),
      (t._act = 0);
  },
  Us = function (t, e) {
    if (t && (!e || e._end > t._dur || e._start < 0))
      for (var n = t; n; ) (n._dirty = 1), (n = n.parent);
    return t;
  },
  tA = function (t) {
    for (var e = t.parent; e && e.parent; )
      (e._dirty = 1), e.totalDuration(), (e = e.parent);
    return t;
  },
  eA = function a(t) {
    return !t || (t._ts && a(t.parent));
  },
  O_ = function (t) {
    return t._repeat ? To(t._tTime, (t = t.duration() + t._rDelay)) * t : 0;
  },
  To = function (t, e) {
    var n = Math.floor((t /= e));
    return t && n === t ? n - 1 : n;
  },
  Oc = function (t, e) {
    return (
      (t - e._start) * e._ts +
      (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
    );
  },
  Nc = function (t) {
    return (t._end = An(
      t._start + (t._tDur / Math.abs(t._ts || t._rts || Ie) || 0)
    ));
  },
  N_ = function (t, e) {
    var n = t._dp;
    return (
      n &&
        n.smoothChildTiming &&
        t._ts &&
        ((t._start = An(
          n._time -
            (t._ts > 0
              ? e / t._ts
              : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)
        )),
        Nc(t),
        n._dirty || Us(n, t)),
      t
    );
  },
  B_ = function (t, e) {
    var n;
    if (
      ((e._time || (e._initted && !e._dur)) &&
        ((n = Oc(t.rawTime(), e)),
        (!e._dur || qa(0, e.totalDuration(), n) - e._tTime > Ie) &&
          e.render(n, !0)),
      Us(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
    ) {
      if (t._dur < t.duration())
        for (n = t; n._dp; )
          n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
      t._zTime = -Ie;
    }
  },
  er = function (t, e, n, i) {
    return (
      e.parent && Jr(e),
      (e._start = An(
        (Er(n) ? n : n || t !== qe ? Li(t, n, e) : t._time) + e._delay
      )),
      (e._end = An(
        e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)
      )),
      QE(t, e, "_first", "_last", t._sort ? "_start" : 0),
      Rf(e) || (t._recent = e),
      i || B_(t, e),
      t
    );
  },
  z_ = function (t, e) {
    return (
      (ci.ScrollTrigger || Mf("scrollTrigger", e)) &&
      ci.ScrollTrigger.create(e, t)
    );
  },
  U_ = function (t, e, n, i) {
    if ((SA(t, e), !t._initted)) return 1;
    if (
      !n &&
      t._pt &&
      ((t._dur && t.vars.lazy !== !1) || (!t._dur && t.vars.lazy)) &&
      L_ !== Pi.frame
    )
      return jr.push(t), (t._lazy = [e, i]), 1;
  },
  nA = function a(t) {
    var e = t.parent;
    return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || a(e));
  },
  Rf = function (t) {
    var e = t.data;
    return e === "isFromStart" || e === "isStart";
  },
  iA = function (t, e, n, i) {
    var r = t.ratio,
      o =
        e < 0 ||
        (!e &&
          ((!t._start && nA(t) && !(!t._initted && Rf(t))) ||
            ((t._ts < 0 || t._dp._ts < 0) && !Rf(t))))
          ? 0
          : 1,
      l = t._rDelay,
      u = 0,
      h,
      f,
      m;
    if (
      (l &&
        t._repeat &&
        ((u = qa(0, t._tDur, e)),
        (f = To(u, l)),
        (m = To(t._tTime, l)),
        t._yoyo && f & 1 && (o = 1 - o),
        f !== m &&
          ((r = 1 - o), t.vars.repeatRefresh && t._initted && t.invalidate())),
      o !== r || i || t._zTime === Ie || (!e && t._zTime))
    ) {
      if (!t._initted && U_(t, e, i, n)) return;
      for (
        m = t._zTime,
          t._zTime = e || (n ? Ie : 0),
          n || (n = e && !m),
          t.ratio = o,
          t._from && (o = 1 - o),
          t._time = 0,
          t._tTime = u,
          h = t._pt;
        h;

      )
        h.r(o, h.d), (h = h._next);
      t._startAt && e < 0 && t._startAt.render(e, !0, !0),
        t._onUpdate && !n && Ri(t, "onUpdate"),
        u && t._repeat && !n && t.parent && Ri(t, "onRepeat"),
        (e >= t._tDur || e < 0) &&
          t.ratio === o &&
          (o && Jr(t, 1),
          n ||
            (Ri(t, o ? "onComplete" : "onReverseComplete", !0),
            t._prom && t._prom()));
    } else t._zTime || (t._zTime = e);
  },
  rA = function (t, e, n) {
    var i;
    if (n > e)
      for (i = t._first; i && i._start <= n; ) {
        if (!i._dur && i.data === "isPause" && i._start > e) return i;
        i = i._next;
      }
    else
      for (i = t._last; i && i._start >= n; ) {
        if (!i._dur && i.data === "isPause" && i._start < e) return i;
        i = i._prev;
      }
  },
  Eo = function (t, e, n, i) {
    var r = t._repeat,
      o = An(e) || 0,
      l = t._tTime / t._tDur;
    return (
      l && !i && (t._time *= o / t._dur),
      (t._dur = o),
      (t._tDur = r ? (r < 0 ? 1e10 : An(o * (r + 1) + t._rDelay * r)) : o),
      l && !i ? N_(t, (t._tTime = t._tDur * l)) : t.parent && Nc(t),
      n || Us(t.parent, t),
      t
    );
  },
  k_ = function (t) {
    return t instanceof Jn ? Us(t) : Eo(t, t._dur);
  },
  sA = { _start: 0, endTime: Mo, totalDuration: Mo },
  Li = function a(t, e, n) {
    var i = t.labels,
      r = t._recent || sA,
      o = t.duration() >= Qi ? r.endTime(!1) : t._dur,
      l,
      u,
      h;
    return yn(e) && (isNaN(e) || e in i)
      ? ((u = e.charAt(0)),
        (h = e.substr(-1) === "%"),
        (l = e.indexOf("=")),
        u === "<" || u === ">"
          ? (l >= 0 && (e = e.replace(/=/, "")),
            (u === "<" ? r._start : r.endTime(r._repeat >= 0)) +
              (parseFloat(e.substr(1)) || 0) *
                (h ? (l < 0 ? r : n).totalDuration() / 100 : 1))
          : l < 0
          ? (e in i || (i[e] = o), i[e])
          : ((u = parseFloat(e.charAt(l - 1) + e.substr(l + 1))),
            h && n && (u = (u / 100) * (li(n) ? n[0] : n).totalDuration()),
            l > 1 ? a(t, e.substr(0, l - 1), n) + u : o + u))
      : e == null
      ? o
      : +e;
  },
  Ya = function (t, e, n) {
    var i = Er(e[1]),
      r = (i ? 2 : 1) + (t < 2 ? 0 : 1),
      o = e[r],
      l,
      u;
    if ((i && (o.duration = e[1]), (o.parent = n), t)) {
      for (l = o, u = n; u && !("immediateRender" in l); )
        (l = u.vars.defaults || {}), (u = jn(u.vars.inherit) && u.parent);
      (o.immediateRender = jn(l.immediateRender)),
        t < 2 ? (o.runBackwards = 1) : (o.startAt = e[r - 1]);
    }
    return new pn(e[0], o, e[r + 1]);
  },
  $r = function (t, e) {
    return t || t === 0 ? e(t) : e;
  },
  qa = function (t, e, n) {
    return n < t ? t : n > e ? e : n;
  },
  fi = function (t) {
    if (typeof t != "string") return "";
    var e = jE.exec(t);
    return e ? t.substr(e.index + e[0].length) : "";
  },
  oA = function (t, e, n) {
    return $r(n, function (i) {
      return qa(t, e, i);
    });
  },
  Pf = [].slice,
  G_ = function (t, e) {
    return (
      t &&
      Ar(t) &&
      "length" in t &&
      ((!e && !t.length) || (t.length - 1 in t && Ar(t[0]))) &&
      !t.nodeType &&
      t !== tr
    );
  },
  aA = function (t, e, n) {
    return (
      n === void 0 && (n = []),
      t.forEach(function (i) {
        var r;
        return (yn(i) && !e) || G_(i, 1)
          ? (r = n).push.apply(r, Ci(i))
          : n.push(i);
      }) || n
    );
  },
  Ci = function (t, e, n) {
    return yn(t) && !n && (wf || !Lo())
      ? Pf.call((e || bf).querySelectorAll(t), 0)
      : li(t)
      ? aA(t, n)
      : G_(t)
      ? Pf.call(t, 0)
      : t
      ? [t]
      : [];
  },
  lA = function (t) {
    return (
      (t = Ci(t)[0] || Pc("Invalid scope") || {}),
      function (e) {
        var n = t.current || t.nativeElement || t;
        return Ci(
          e,
          n.querySelectorAll
            ? n
            : n === t
            ? Pc("Invalid scope") || bf.createElement("div")
            : t
        );
      }
    );
  },
  H_ = function (t) {
    return t.sort(function () {
      return 0.5 - Math.random();
    });
  },
  V_ = function (t) {
    if (dn(t)) return t;
    var e = Ar(t) ? t : { each: t },
      n = Co(e.ease),
      i = e.from || 0,
      r = parseFloat(e.base) || 0,
      o = {},
      l = i > 0 && i < 1,
      u = isNaN(i) || l,
      h = e.axis,
      f = i,
      m = i;
    return (
      yn(i)
        ? (f = m = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
        : !l && u && ((f = i[0]), (m = i[1])),
      function (g, p, v) {
        var x = (v || e).length,
          b = o[x],
          _,
          y,
          E,
          M,
          A,
          R,
          T,
          B,
          X;
        if (!b) {
          if (((X = e.grid === "auto" ? 0 : (e.grid || [1, Qi])[1]), !X)) {
            for (
              T = -Qi;
              T < (T = v[X++].getBoundingClientRect().left) && X < x;

            );
            X--;
          }
          for (
            b = o[x] = [],
              _ = u ? Math.min(X, x) * f - 0.5 : i % X,
              y = u ? (x * m) / X - 0.5 : (i / X) | 0,
              T = 0,
              B = Qi,
              R = 0;
            R < x;
            R++
          )
            (E = (R % X) - _),
              (M = y - ((R / X) | 0)),
              (b[R] = A = h ? Math.abs(h === "y" ? M : E) : v_(E * E + M * M)),
              A > T && (T = A),
              A < B && (B = A);
          i === "random" && H_(b),
            (b.max = T - B),
            (b.min = B),
            (b.v = x =
              (parseFloat(e.amount) ||
                parseFloat(e.each) *
                  (X > x
                    ? x - 1
                    : h
                    ? h === "y"
                      ? x / X
                      : X
                    : Math.max(X, x / X)) ||
                0) * (i === "edges" ? -1 : 1)),
            (b.b = x < 0 ? r - x : r),
            (b.u = fi(e.amount || e.each) || 0),
            (n = n && x < 0 ? Q_(n) : n);
        }
        return (
          (x = (b[g] - b.min) / b.max || 0),
          An(b.b + (n ? n(x) : x) * b.v) + b.u
        );
      }
    );
  },
  If = function (t) {
    var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
    return function (n) {
      var i = Math.round(parseFloat(n) / t) * t * e;
      return (i - (i % 1)) / e + (Er(n) ? 0 : fi(n));
    };
  },
  W_ = function (t, e) {
    var n = li(t),
      i,
      r;
    return (
      !n &&
        Ar(t) &&
        ((i = n = t.radius || Qi),
        t.values
          ? ((t = Ci(t.values)), (r = !Er(t[0])) && (i *= i))
          : (t = If(t.increment))),
      $r(
        e,
        n
          ? dn(t)
            ? function (o) {
                return (r = t(o)), Math.abs(r - o) <= i ? r : o;
              }
            : function (o) {
                for (
                  var l = parseFloat(r ? o.x : o),
                    u = parseFloat(r ? o.y : 0),
                    h = Qi,
                    f = 0,
                    m = t.length,
                    g,
                    p;
                  m--;

                )
                  r
                    ? ((g = t[m].x - l), (p = t[m].y - u), (g = g * g + p * p))
                    : (g = Math.abs(t[m] - l)),
                    g < h && ((h = g), (f = m));
                return (
                  (f = !i || h <= i ? t[f] : o),
                  r || f === o || Er(o) ? f : f + fi(o)
                );
              }
          : If(t)
      )
    );
  },
  X_ = function (t, e, n, i) {
    return $r(li(t) ? !e : n === !0 ? !!(n = 0) : !i, function () {
      return li(t)
        ? t[~~(Math.random() * t.length)]
        : (n = n || 1e-5) &&
            (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
            Math.floor(
              Math.round((t - n / 2 + Math.random() * (e - t + n * 0.99)) / n) *
                n *
                i
            ) / i;
    });
  },
  cA = function () {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    return function (i) {
      return e.reduce(function (r, o) {
        return o(r);
      }, i);
    };
  },
  uA = function (t, e) {
    return function (n) {
      return t(parseFloat(n)) + (e || fi(n));
    };
  },
  hA = function (t, e, n) {
    return q_(t, e, 0, 1, n);
  },
  Y_ = function (t, e, n) {
    return $r(n, function (i) {
      return t[~~e(i)];
    });
  },
  fA = function a(t, e, n) {
    var i = e - t;
    return li(t)
      ? Y_(t, a(0, t.length), e)
      : $r(n, function (r) {
          return ((i + ((r - t) % i)) % i) + t;
        });
  },
  dA = function a(t, e, n) {
    var i = e - t,
      r = i * 2;
    return li(t)
      ? Y_(t, a(0, t.length - 1), e)
      : $r(n, function (o) {
          return (o = (r + ((o - t) % r)) % r || 0), t + (o > i ? r - o : o);
        });
  },
  Za = function (t) {
    for (var e = 0, n = "", i, r, o, l; ~(i = t.indexOf("random(", e)); )
      (o = t.indexOf(")", i)),
        (l = t.charAt(i + 7) === "["),
        (r = t.substr(i + 7, o - i - 7).match(l ? S_ : xf)),
        (n +=
          t.substr(e, i - e) + X_(l ? r : +r[0], l ? 0 : +r[1], +r[2] || 1e-5)),
        (e = o + 1);
    return n + t.substr(e, t.length - e);
  },
  q_ = function (t, e, n, i, r) {
    var o = e - t,
      l = i - n;
    return $r(r, function (u) {
      return n + (((u - t) / o) * l || 0);
    });
  },
  pA = function a(t, e, n, i) {
    var r = isNaN(t + e)
      ? 0
      : function (p) {
          return (1 - p) * t + p * e;
        };
    if (!r) {
      var o = yn(t),
        l = {},
        u,
        h,
        f,
        m,
        g;
      if ((n === !0 && (i = 1) && (n = null), o))
        (t = { p: t }), (e = { p: e });
      else if (li(t) && !li(e)) {
        for (f = [], m = t.length, g = m - 2, h = 1; h < m; h++)
          f.push(a(t[h - 1], t[h]));
        m--,
          (r = function (v) {
            v *= m;
            var x = Math.min(g, ~~v);
            return f[x](v - x);
          }),
          (n = e);
      } else i || (t = So(li(t) ? [] : {}, t));
      if (!f) {
        for (u in e) Nf.call(l, t, u, "get", e[u]);
        r = function (v) {
          return Uf(v, l) || (o ? t.p : t);
        };
      }
    }
    return $r(n, r);
  },
  Z_ = function (t, e, n) {
    var i = t.labels,
      r = Qi,
      o,
      l,
      u;
    for (o in i)
      (l = i[o] - e),
        l < 0 == !!n && l && r > (l = Math.abs(l)) && ((u = o), (r = l));
    return u;
  },
  Ri = function (t, e, n) {
    var i = t.vars,
      r = i[e],
      o,
      l;
    if (!!r)
      return (
        (o = i[e + "Params"]),
        (l = i.callbackScope || t),
        n && jr.length && Dc(),
        o ? r.apply(l, o) : r.call(l)
      );
  },
  ja = function (t) {
    return (
      Jr(t),
      t.scrollTrigger && t.scrollTrigger.kill(!1),
      t.progress() < 1 && Ri(t, "onInterrupt"),
      t
    );
  },
  Ao,
  mA = function (t) {
    t = (!t.name && t.default) || t;
    var e = t.name,
      n = dn(t),
      i =
        e && !n && t.init
          ? function () {
              this._props = [];
            }
          : t,
      r = { init: Mo, render: Uf, add: Nf, kill: PA, modifier: RA, rawVars: 0 },
      o = { targetTest: 0, get: 0, getSetter: zf, aliases: {}, register: 0 };
    if ((Lo(), t !== i)) {
      if (ui[e]) return;
      Ai(i, Ai(Cf(t, r), o)),
        So(i.prototype, So(r, Cf(t, o))),
        (ui[(i.prop = e)] = i),
        t.targetTest && (Ic.push(i), (Sf[e] = 1)),
        (e =
          (e === "css" ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) +
          "Plugin");
    }
    A_(e, i), t.register && t.register(nr, i, $n);
  },
  De = 255,
  Ja = {
    aqua: [0, De, De],
    lime: [0, De, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, De],
    navy: [0, 0, 128],
    white: [De, De, De],
    olive: [128, 128, 0],
    yellow: [De, De, 0],
    orange: [De, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [De, 0, 0],
    pink: [De, 192, 203],
    cyan: [0, De, De],
    transparent: [De, De, De, 0],
  },
  Df = function (t, e, n) {
    return (
      (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t),
      ((t * 6 < 1
        ? e + (n - e) * t * 6
        : t < 0.5
        ? n
        : t * 3 < 2
        ? e + (n - e) * (2 / 3 - t) * 6
        : e) *
        De +
        0.5) |
        0
    );
  },
  j_ = function (t, e, n) {
    var i = t ? (Er(t) ? [t >> 16, (t >> 8) & De, t & De] : 0) : Ja.black,
      r,
      o,
      l,
      u,
      h,
      f,
      m,
      g,
      p,
      v;
    if (!i) {
      if ((t.substr(-1) === "," && (t = t.substr(0, t.length - 1)), Ja[t]))
        i = Ja[t];
      else if (t.charAt(0) === "#") {
        if (
          (t.length < 6 &&
            ((r = t.charAt(1)),
            (o = t.charAt(2)),
            (l = t.charAt(3)),
            (t =
              "#" +
              r +
              r +
              o +
              o +
              l +
              l +
              (t.length === 5 ? t.charAt(4) + t.charAt(4) : ""))),
          t.length === 9)
        )
          return (
            (i = parseInt(t.substr(1, 6), 16)),
            [i >> 16, (i >> 8) & De, i & De, parseInt(t.substr(7), 16) / 255]
          );
        (t = parseInt(t.substr(1), 16)), (i = [t >> 16, (t >> 8) & De, t & De]);
      } else if (t.substr(0, 3) === "hsl") {
        if (((i = v = t.match(xf)), !e))
          (u = (+i[0] % 360) / 360),
            (h = +i[1] / 100),
            (f = +i[2] / 100),
            (o = f <= 0.5 ? f * (h + 1) : f + h - f * h),
            (r = f * 2 - o),
            i.length > 3 && (i[3] *= 1),
            (i[0] = Df(u + 1 / 3, r, o)),
            (i[1] = Df(u, r, o)),
            (i[2] = Df(u - 1 / 3, r, o));
        else if (~t.indexOf("="))
          return (i = t.match(b_)), n && i.length < 4 && (i[3] = 1), i;
      } else i = t.match(xf) || Ja.transparent;
      i = i.map(Number);
    }
    return (
      e &&
        !v &&
        ((r = i[0] / De),
        (o = i[1] / De),
        (l = i[2] / De),
        (m = Math.max(r, o, l)),
        (g = Math.min(r, o, l)),
        (f = (m + g) / 2),
        m === g
          ? (u = h = 0)
          : ((p = m - g),
            (h = f > 0.5 ? p / (2 - m - g) : p / (m + g)),
            (u =
              m === r
                ? (o - l) / p + (o < l ? 6 : 0)
                : m === o
                ? (l - r) / p + 2
                : (r - o) / p + 4),
            (u *= 60)),
        (i[0] = ~~(u + 0.5)),
        (i[1] = ~~(h * 100 + 0.5)),
        (i[2] = ~~(f * 100 + 0.5))),
      n && i.length < 4 && (i[3] = 1),
      i
    );
  },
  J_ = function (t) {
    var e = [],
      n = [],
      i = -1;
    return (
      t.split(Kr).forEach(function (r) {
        var o = r.match(bo) || [];
        e.push.apply(e, o), n.push((i += o.length + 1));
      }),
      (e.c = n),
      e
    );
  },
  $_ = function (t, e, n) {
    var i = "",
      r = (t + i).match(Kr),
      o = e ? "hsla(" : "rgba(",
      l = 0,
      u,
      h,
      f,
      m;
    if (!r) return t;
    if (
      ((r = r.map(function (g) {
        return (
          (g = j_(g, e, 1)) &&
          o +
            (e ? g[0] + "," + g[1] + "%," + g[2] + "%," + g[3] : g.join(",")) +
            ")"
        );
      })),
      n && ((f = J_(t)), (u = n.c), u.join(i) !== f.c.join(i)))
    )
      for (h = t.replace(Kr, "1").split(bo), m = h.length - 1; l < m; l++)
        i +=
          h[l] +
          (~u.indexOf(l)
            ? r.shift() || o + "0,0,0,0)"
            : (f.length ? f : r.length ? r : n).shift());
    if (!h)
      for (h = t.split(Kr), m = h.length - 1; l < m; l++) i += h[l] + r[l];
    return i + h[m];
  },
  Kr = (function () {
    var a =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      t;
    for (t in Ja) a += "|" + t + "\\b";
    return new RegExp(a + ")", "gi");
  })(),
  gA = /hsl[a]?\(/,
  K_ = function (t) {
    var e = t.join(" "),
      n;
    if (((Kr.lastIndex = 0), Kr.test(e)))
      return (
        (n = gA.test(e)),
        (t[1] = $_(t[1], n)),
        (t[0] = $_(t[0], n, J_(t[1]))),
        !0
      );
  },
  Bc,
  Pi = (function () {
    var a = Date.now,
      t = 500,
      e = 33,
      n = a(),
      i = n,
      r = 1e3 / 240,
      o = r,
      l = [],
      u,
      h,
      f,
      m,
      g,
      p,
      v = function x(b) {
        var _ = a() - i,
          y = b === !0,
          E,
          M,
          A,
          R;
        if (
          (_ > t && (n += _ - e),
          (i += _),
          (A = i - n),
          (E = A - o),
          (E > 0 || y) &&
            ((R = ++m.frame),
            (g = A - m.time * 1e3),
            (m.time = A = A / 1e3),
            (o += E + (E >= r ? 4 : r - E)),
            (M = 1)),
          y || (u = h(x)),
          M)
        )
          for (p = 0; p < l.length; p++) l[p](A, g, R, b);
      };
    return (
      (m = {
        time: 0,
        frame: 0,
        tick: function () {
          v(!0);
        },
        deltaRatio: function (b) {
          return g / (1e3 / (b || 60));
        },
        wake: function () {
          T_ &&
            (!wf &&
              x_() &&
              ((tr = wf = window),
              (bf = tr.document || {}),
              (ci.gsap = nr),
              (tr.gsapVersions || (tr.gsapVersions = [])).push(nr.version),
              E_(Rc || tr.GreenSockGlobals || (!tr.gsap && tr) || {}),
              (f = tr.requestAnimationFrame)),
            u && m.sleep(),
            (h =
              f ||
              function (b) {
                return setTimeout(b, (o - m.time * 1e3 + 1) | 0);
              }),
            (Bc = 1),
            v(2));
        },
        sleep: function () {
          (f ? tr.cancelAnimationFrame : clearTimeout)(u), (Bc = 0), (h = Mo);
        },
        lagSmoothing: function (b, _) {
          (t = b || 1 / Ie), (e = Math.min(_, t, 0));
        },
        fps: function (b) {
          (r = 1e3 / (b || 240)), (o = m.time * 1e3 + r);
        },
        add: function (b) {
          l.indexOf(b) < 0 && l.push(b), Lo();
        },
        remove: function (b) {
          var _;
          ~(_ = l.indexOf(b)) && l.splice(_, 1) && p >= _ && p--;
        },
        _listeners: l,
      }),
      m
    );
  })(),
  Lo = function () {
    return !Bc && Pi.wake();
  },
  pe = {},
  _A = /^[\d.\-M][\d.\-,\s]/,
  vA = /["']/g,
  xA = function (t) {
    for (
      var e = {},
        n = t.substr(1, t.length - 3).split(":"),
        i = n[0],
        r = 1,
        o = n.length,
        l,
        u,
        h;
      r < o;
      r++
    )
      (u = n[r]),
        (l = r !== o - 1 ? u.lastIndexOf(",") : u.length),
        (h = u.substr(0, l)),
        (e[i] = isNaN(h) ? h.replace(vA, "").trim() : +h),
        (i = u.substr(l + 1).trim());
    return e;
  },
  yA = function (t) {
    var e = t.indexOf("(") + 1,
      n = t.indexOf(")"),
      i = t.indexOf("(", e);
    return t.substring(e, ~i && i < n ? t.indexOf(")", n + 1) : n);
  },
  wA = function (t) {
    var e = (t + "").split("("),
      n = pe[e[0]];
    return n && e.length > 1 && n.config
      ? n.config.apply(
          null,
          ~t.indexOf("{") ? [xA(e[1])] : yA(t).split(",").map(I_)
        )
      : pe._CE && _A.test(t)
      ? pe._CE("", t)
      : n;
  },
  Q_ = function (t) {
    return function (e) {
      return 1 - t(1 - e);
    };
  },
  t0 = function a(t, e) {
    for (var n = t._first, i; n; )
      n instanceof Jn
        ? a(n, e)
        : n.vars.yoyoEase &&
          (!n._yoyo || !n._repeat) &&
          n._yoyo !== e &&
          (n.timeline
            ? a(n.timeline, e)
            : ((i = n._ease),
              (n._ease = n._yEase),
              (n._yEase = i),
              (n._yoyo = e))),
        (n = n._next);
  },
  Co = function (t, e) {
    return (t && (dn(t) ? t : pe[t] || wA(t))) || e;
  },
  ks = function (t, e, n, i) {
    n === void 0 &&
      (n = function (u) {
        return 1 - e(1 - u);
      }),
      i === void 0 &&
        (i = function (u) {
          return u < 0.5 ? e(u * 2) / 2 : 1 - e((1 - u) * 2) / 2;
        });
    var r = { easeIn: e, easeOut: n, easeInOut: i },
      o;
    return (
      hi(t, function (l) {
        (pe[l] = ci[l] = r), (pe[(o = l.toLowerCase())] = n);
        for (var u in r)
          pe[
            o + (u === "easeIn" ? ".in" : u === "easeOut" ? ".out" : ".inOut")
          ] = pe[l + "." + u] = r[u];
      }),
      r
    );
  },
  e0 = function (t) {
    return function (e) {
      return e < 0.5 ? (1 - t(1 - e * 2)) / 2 : 0.5 + t((e - 0.5) * 2) / 2;
    };
  },
  Ff = function a(t, e, n) {
    var i = e >= 1 ? e : 1,
      r = (n || (t ? 0.3 : 0.45)) / (e < 1 ? e : 1),
      o = (r / _f) * (Math.asin(1 / i) || 0),
      l = function (f) {
        return f === 1 ? 1 : i * Math.pow(2, -10 * f) * ZE((f - o) * r) + 1;
      },
      u =
        t === "out"
          ? l
          : t === "in"
          ? function (h) {
              return 1 - l(1 - h);
            }
          : e0(l);
    return (
      (r = _f / r),
      (u.config = function (h, f) {
        return a(t, h, f);
      }),
      u
    );
  },
  Of = function a(t, e) {
    e === void 0 && (e = 1.70158);
    var n = function (o) {
        return o ? --o * o * ((e + 1) * o + e) + 1 : 0;
      },
      i =
        t === "out"
          ? n
          : t === "in"
          ? function (r) {
              return 1 - n(1 - r);
            }
          : e0(n);
    return (
      (i.config = function (r) {
        return a(t, r);
      }),
      i
    );
  };
hi("Linear,Quad,Cubic,Quart,Quint,Strong", function (a, t) {
  var e = t < 5 ? t + 1 : t;
  ks(
    a + ",Power" + (e - 1),
    t
      ? function (n) {
          return Math.pow(n, e);
        }
      : function (n) {
          return n;
        },
    function (n) {
      return 1 - Math.pow(1 - n, e);
    },
    function (n) {
      return n < 0.5
        ? Math.pow(n * 2, e) / 2
        : 1 - Math.pow((1 - n) * 2, e) / 2;
    }
  );
});
pe.Linear.easeNone = pe.none = pe.Linear.easeIn;
ks("Elastic", Ff("in"), Ff("out"), Ff());
(function (a, t) {
  var e = 1 / t,
    n = 2 * e,
    i = 2.5 * e,
    r = function (l) {
      return l < e
        ? a * l * l
        : l < n
        ? a * Math.pow(l - 1.5 / t, 2) + 0.75
        : l < i
        ? a * (l -= 2.25 / t) * l + 0.9375
        : a * Math.pow(l - 2.625 / t, 2) + 0.984375;
    };
  ks(
    "Bounce",
    function (o) {
      return 1 - r(1 - o);
    },
    r
  );
})(7.5625, 2.75);
ks("Expo", function (a) {
  return a ? Math.pow(2, 10 * (a - 1)) : 0;
});
ks("Circ", function (a) {
  return -(v_(1 - a * a) - 1);
});
ks("Sine", function (a) {
  return a === 1 ? 1 : -qE(a * XE) + 1;
});
ks("Back", Of("in"), Of("out"), Of());
pe.SteppedEase =
  pe.steps =
  ci.SteppedEase =
    {
      config: function (t, e) {
        t === void 0 && (t = 1);
        var n = 1 / t,
          i = t + (e ? 0 : 1),
          r = e ? 1 : 0,
          o = 1 - Ie;
        return function (l) {
          return (((i * qa(0, o, l)) | 0) + r) * n;
        };
      },
    };
wo.ease = pe["quad.out"];
hi(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (a) {
    return (Af += a + "," + a + "Params,");
  }
);
var n0 = function (t, e) {
    (this.id = YE++),
      (t._gsap = this),
      (this.target = t),
      (this.harness = e),
      (this.get = e ? e.get : R_),
      (this.set = e ? e.getSetter : zf);
  },
  $a = (function () {
    function a(e) {
      (this.vars = e),
        (this._delay = +e.delay || 0),
        (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) &&
          ((this._rDelay = e.repeatDelay || 0),
          (this._yoyo = !!e.yoyo || !!e.yoyoEase)),
        (this._ts = 1),
        Eo(this, +e.duration, 1, 1),
        (this.data = e.data),
        Bc || Pi.wake();
    }
    var t = a.prototype;
    return (
      (t.delay = function (n) {
        return n || n === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + n - this._delay),
            (this._delay = n),
            this)
          : this._delay;
      }),
      (t.duration = function (n) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n
            )
          : this.totalDuration() && this._dur;
      }),
      (t.totalDuration = function (n) {
        return arguments.length
          ? ((this._dirty = 0),
            Eo(
              this,
              this._repeat < 0
                ? n
                : (n - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (t.totalTime = function (n, i) {
        if ((Lo(), !arguments.length)) return this._tTime;
        var r = this._dp;
        if (r && r.smoothChildTiming && this._ts) {
          for (N_(this, n), !r._dp || r.parent || B_(r, this); r && r.parent; )
            r.parent._time !==
              r._start +
                (r._ts >= 0
                  ? r._tTime / r._ts
                  : (r.totalDuration() - r._tTime) / -r._ts) &&
              r.totalTime(r._tTime, !0),
              (r = r.parent);
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && n < this._tDur) ||
              (this._ts < 0 && n > 0) ||
              (!this._tDur && !n)) &&
            er(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== n ||
            (!this._dur && !i) ||
            (this._initted && Math.abs(this._zTime) === Ie) ||
            (!n && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = n), P_(this, n, i)),
          this
        );
      }),
      (t.time = function (n, i) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), n + O_(this)) %
                (this._dur + this._rDelay) || (n ? this._dur : 0),
              i
            )
          : this._time;
      }),
      (t.totalProgress = function (n, i) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * n, i)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.ratio;
      }),
      (t.progress = function (n, i) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) +
                O_(this),
              i
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.ratio;
      }),
      (t.iteration = function (n, i) {
        var r = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (n - 1) * r, i)
          : this._repeat
          ? To(this._tTime, r) + 1
          : 1;
      }),
      (t.timeScale = function (n) {
        if (!arguments.length) return this._rts === -Ie ? 0 : this._rts;
        if (this._rts === n) return this;
        var i =
          this.parent && this._ts ? Oc(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +n || 0),
          (this._ts = this._ps || n === -Ie ? 0 : this._rts),
          tA(this.totalTime(qa(-this._delay, this._tDur, i), !0)),
          Nc(this),
          this
        );
      }),
      (t.paused = function (n) {
        return arguments.length
          ? (this._ps !== n &&
              ((this._ps = n),
              n
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (Lo(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== Ie &&
                      (this._tTime -= Ie)
                  ))),
            this)
          : this._ps;
      }),
      (t.startTime = function (n) {
        if (arguments.length) {
          this._start = n;
          var i = this.parent || this._dp;
          return (
            i && (i._sort || !this.parent) && er(i, this, n - this._delay), this
          );
        }
        return this._start;
      }),
      (t.endTime = function (n) {
        return (
          this._start +
          (jn(n) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (t.rawTime = function (n) {
        var i = this.parent || this._dp;
        return i
          ? n &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? Oc(i.rawTime(n), this)
            : this._tTime
          : this._tTime;
      }),
      (t.globalTime = function (n) {
        for (var i = this, r = arguments.length ? n : i.rawTime(); i; )
          (r = i._start + r / (i._ts || 1)), (i = i._dp);
        return r;
      }),
      (t.repeat = function (n) {
        return arguments.length
          ? ((this._repeat = n === 1 / 0 ? -2 : n), k_(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat;
      }),
      (t.repeatDelay = function (n) {
        if (arguments.length) {
          var i = this._time;
          return (this._rDelay = n), k_(this), i ? this.time(i) : this;
        }
        return this._rDelay;
      }),
      (t.yoyo = function (n) {
        return arguments.length ? ((this._yoyo = n), this) : this._yoyo;
      }),
      (t.seek = function (n, i) {
        return this.totalTime(Li(this, n), jn(i));
      }),
      (t.restart = function (n, i) {
        return this.play().totalTime(n ? -this._delay : 0, jn(i));
      }),
      (t.play = function (n, i) {
        return n != null && this.seek(n, i), this.reversed(!1).paused(!1);
      }),
      (t.reverse = function (n, i) {
        return (
          n != null && this.seek(n || this.totalDuration(), i),
          this.reversed(!0).paused(!1)
        );
      }),
      (t.pause = function (n, i) {
        return n != null && this.seek(n, i), this.paused(!0);
      }),
      (t.resume = function () {
        return this.paused(!1);
      }),
      (t.reversed = function (n) {
        return arguments.length
          ? (!!n !== this.reversed() &&
              this.timeScale(-this._rts || (n ? -Ie : 0)),
            this)
          : this._rts < 0;
      }),
      (t.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -Ie), this;
      }),
      (t.isActive = function () {
        var n = this.parent || this._dp,
          i = this._start,
          r;
        return !!(
          !n ||
          (this._ts &&
            this._initted &&
            n.isActive() &&
            (r = n.rawTime(!0)) >= i &&
            r < this.endTime(!0) - Ie)
        );
      }),
      (t.eventCallback = function (n, i, r) {
        var o = this.vars;
        return arguments.length > 1
          ? (i
              ? ((o[n] = i),
                r && (o[n + "Params"] = r),
                n === "onUpdate" && (this._onUpdate = i))
              : delete o[n],
            this)
          : o[n];
      }),
      (t.then = function (n) {
        var i = this;
        return new Promise(function (r) {
          var o = dn(n) ? n : D_,
            l = function () {
              var h = i.then;
              (i.then = null),
                dn(o) && (o = o(i)) && (o.then || o === i) && (i.then = h),
                r(o),
                (i.then = h);
            };
          (i._initted && i.totalProgress() === 1 && i._ts >= 0) ||
          (!i._tTime && i._ts < 0)
            ? l()
            : (i._prom = l);
        });
      }),
      (t.kill = function () {
        ja(this);
      }),
      a
    );
  })();
Ai($a.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -Ie,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var Jn = (function (a) {
  __(t, a);
  function t(n, i) {
    var r;
    return (
      n === void 0 && (n = {}),
      (r = a.call(this, n) || this),
      (r.labels = {}),
      (r.smoothChildTiming = !!n.smoothChildTiming),
      (r.autoRemoveChildren = !!n.autoRemoveChildren),
      (r._sort = jn(n.sortChildren)),
      qe && er(n.parent || qe, Tr(r), i),
      n.reversed && r.reverse(),
      n.paused && r.paused(!0),
      n.scrollTrigger && z_(Tr(r), n.scrollTrigger),
      r
    );
  }
  var e = t.prototype;
  return (
    (e.to = function (i, r, o) {
      return Ya(0, arguments, this), this;
    }),
    (e.from = function (i, r, o) {
      return Ya(1, arguments, this), this;
    }),
    (e.fromTo = function (i, r, o, l) {
      return Ya(2, arguments, this), this;
    }),
    (e.set = function (i, r, o) {
      return (
        (r.duration = 0),
        (r.parent = this),
        Xa(r).repeatDelay || (r.repeat = 0),
        (r.immediateRender = !!r.immediateRender),
        new pn(i, r, Li(this, o), 1),
        this
      );
    }),
    (e.call = function (i, r, o) {
      return er(this, pn.delayedCall(0, i, r), o);
    }),
    (e.staggerTo = function (i, r, o, l, u, h, f) {
      return (
        (o.duration = r),
        (o.stagger = o.stagger || l),
        (o.onComplete = h),
        (o.onCompleteParams = f),
        (o.parent = this),
        new pn(i, o, Li(this, u)),
        this
      );
    }),
    (e.staggerFrom = function (i, r, o, l, u, h, f) {
      return (
        (o.runBackwards = 1),
        (Xa(o).immediateRender = jn(o.immediateRender)),
        this.staggerTo(i, r, o, l, u, h, f)
      );
    }),
    (e.staggerFromTo = function (i, r, o, l, u, h, f, m) {
      return (
        (l.startAt = o),
        (Xa(l).immediateRender = jn(l.immediateRender)),
        this.staggerTo(i, r, l, u, h, f, m)
      );
    }),
    (e.render = function (i, r, o) {
      var l = this._time,
        u = this._dirty ? this.totalDuration() : this._tDur,
        h = this._dur,
        f = i <= 0 ? 0 : An(i),
        m = this._zTime < 0 != i < 0 && (this._initted || !h),
        g,
        p,
        v,
        x,
        b,
        _,
        y,
        E,
        M,
        A,
        R,
        T;
      if (
        (this !== qe && f > u && i >= 0 && (f = u), f !== this._tTime || o || m)
      ) {
        if (
          (l !== this._time &&
            h &&
            ((f += this._time - l), (i += this._time - l)),
          (g = f),
          (M = this._start),
          (E = this._ts),
          (_ = !E),
          m && (h || (l = this._zTime), (i || !r) && (this._zTime = i)),
          this._repeat)
        ) {
          if (
            ((R = this._yoyo),
            (b = h + this._rDelay),
            this._repeat < -1 && i < 0)
          )
            return this.totalTime(b * 100 + i, r, o);
          if (
            ((g = An(f % b)),
            f === u
              ? ((x = this._repeat), (g = h))
              : ((x = ~~(f / b)),
                x && x === f / b && ((g = h), x--),
                g > h && (g = h)),
            (A = To(this._tTime, b)),
            !l && this._tTime && A !== x && (A = x),
            R && x & 1 && ((g = h - g), (T = 1)),
            x !== A && !this._lock)
          ) {
            var B = R && A & 1,
              X = B === (R && x & 1);
            if (
              (x < A && (B = !B),
              (l = B ? 0 : h),
              (this._lock = 1),
              (this.render(l || (T ? 0 : An(x * b)), r, !h)._lock = 0),
              (this._tTime = f),
              !r && this.parent && Ri(this, "onRepeat"),
              this.vars.repeatRefresh && !T && (this.invalidate()._lock = 1),
              (l && l !== this._time) ||
                _ !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((h = this._dur),
              (u = this._tDur),
              X &&
                ((this._lock = 2),
                (l = B ? h : -1e-4),
                this.render(l, !0),
                this.vars.repeatRefresh && !T && this.invalidate()),
              (this._lock = 0),
              !this._ts && !_)
            )
              return this;
            t0(this, T);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((y = rA(this, An(l), An(g))), y && (f -= g - (g = y._start))),
          (this._tTime = f),
          (this._time = g),
          (this._act = !E),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = i),
            (l = 0)),
          !l && g && !r && (Ri(this, "onStart"), this._tTime !== f))
        )
          return this;
        if (g >= l && i >= 0)
          for (p = this._first; p; ) {
            if (
              ((v = p._next), (p._act || g >= p._start) && p._ts && y !== p)
            ) {
              if (p.parent !== this) return this.render(i, r, o);
              if (
                (p.render(
                  p._ts > 0
                    ? (g - p._start) * p._ts
                    : (p._dirty ? p.totalDuration() : p._tDur) +
                        (g - p._start) * p._ts,
                  r,
                  o
                ),
                g !== this._time || (!this._ts && !_))
              ) {
                (y = 0), v && (f += this._zTime = -Ie);
                break;
              }
            }
            p = v;
          }
        else {
          p = this._last;
          for (var H = i < 0 ? i : g; p; ) {
            if (((v = p._prev), (p._act || H <= p._end) && p._ts && y !== p)) {
              if (p.parent !== this) return this.render(i, r, o);
              if (
                (p.render(
                  p._ts > 0
                    ? (H - p._start) * p._ts
                    : (p._dirty ? p.totalDuration() : p._tDur) +
                        (H - p._start) * p._ts,
                  r,
                  o
                ),
                g !== this._time || (!this._ts && !_))
              ) {
                (y = 0), v && (f += this._zTime = H ? -Ie : Ie);
                break;
              }
            }
            p = v;
          }
        }
        if (
          y &&
          !r &&
          (this.pause(),
          (y.render(g >= l ? 0 : -Ie)._zTime = g >= l ? 1 : -1),
          this._ts)
        )
          return (this._start = M), Nc(this), this.render(i, r, o);
        this._onUpdate && !r && Ri(this, "onUpdate", !0),
          ((f === u && u >= this.totalDuration()) || (!f && l)) &&
            (M === this._start || Math.abs(E) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((i || !h) &&
                ((f === u && this._ts > 0) || (!f && this._ts < 0)) &&
                Jr(this, 1),
              !r &&
                !(i < 0 && !l) &&
                (f || l || !u) &&
                (Ri(
                  this,
                  f === u && i >= 0 ? "onComplete" : "onReverseComplete",
                  !0
                ),
                this._prom &&
                  !(f < u && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }),
    (e.add = function (i, r) {
      var o = this;
      if ((Er(r) || (r = Li(this, r, i)), !(i instanceof $a))) {
        if (li(i))
          return (
            i.forEach(function (l) {
              return o.add(l, r);
            }),
            this
          );
        if (yn(i)) return this.addLabel(i, r);
        if (dn(i)) i = pn.delayedCall(0, i);
        else return this;
      }
      return this !== i ? er(this, i, r) : this;
    }),
    (e.getChildren = function (i, r, o, l) {
      i === void 0 && (i = !0),
        r === void 0 && (r = !0),
        o === void 0 && (o = !0),
        l === void 0 && (l = -Qi);
      for (var u = [], h = this._first; h; )
        h._start >= l &&
          (h instanceof pn
            ? r && u.push(h)
            : (o && u.push(h), i && u.push.apply(u, h.getChildren(!0, r, o)))),
          (h = h._next);
      return u;
    }),
    (e.getById = function (i) {
      for (var r = this.getChildren(1, 1, 1), o = r.length; o--; )
        if (r[o].vars.id === i) return r[o];
    }),
    (e.remove = function (i) {
      return yn(i)
        ? this.removeLabel(i)
        : dn(i)
        ? this.killTweensOf(i)
        : (Fc(this, i),
          i === this._recent && (this._recent = this._last),
          Us(this));
    }),
    (e.totalTime = function (i, r) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = An(
              Pi.time -
                (this._ts > 0
                  ? i / this._ts
                  : (this.totalDuration() - i) / -this._ts)
            )),
          a.prototype.totalTime.call(this, i, r),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (e.addLabel = function (i, r) {
      return (this.labels[i] = Li(this, r)), this;
    }),
    (e.removeLabel = function (i) {
      return delete this.labels[i], this;
    }),
    (e.addPause = function (i, r, o) {
      var l = pn.delayedCall(0, r || Mo, o);
      return (
        (l.data = "isPause"), (this._hasPause = 1), er(this, l, Li(this, i))
      );
    }),
    (e.removePause = function (i) {
      var r = this._first;
      for (i = Li(this, i); r; )
        r._start === i && r.data === "isPause" && Jr(r), (r = r._next);
    }),
    (e.killTweensOf = function (i, r, o) {
      for (var l = this.getTweensOf(i, o), u = l.length; u--; )
        Qr !== l[u] && l[u].kill(i, r);
      return this;
    }),
    (e.getTweensOf = function (i, r) {
      for (var o = [], l = Ci(i), u = this._first, h = Er(r), f; u; )
        u instanceof pn
          ? JE(u._targets, l) &&
            (h
              ? (!Qr || (u._initted && u._ts)) &&
                u.globalTime(0) <= r &&
                u.globalTime(u.totalDuration()) > r
              : !r || u.isActive()) &&
            o.push(u)
          : (f = u.getTweensOf(l, r)).length && o.push.apply(o, f),
          (u = u._next);
      return o;
    }),
    (e.tweenTo = function (i, r) {
      r = r || {};
      var o = this,
        l = Li(o, i),
        u = r,
        h = u.startAt,
        f = u.onStart,
        m = u.onStartParams,
        g = u.immediateRender,
        p,
        v = pn.to(
          o,
          Ai(
            {
              ease: r.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: l,
              overwrite: "auto",
              duration:
                r.duration ||
                Math.abs(
                  (l - (h && "time" in h ? h.time : o._time)) / o.timeScale()
                ) ||
                Ie,
              onStart: function () {
                if ((o.pause(), !p)) {
                  var b =
                    r.duration ||
                    Math.abs(
                      (l - (h && "time" in h ? h.time : o._time)) /
                        o.timeScale()
                    );
                  v._dur !== b && Eo(v, b, 0, 1).render(v._time, !0, !0),
                    (p = 1);
                }
                f && f.apply(v, m || []);
              },
            },
            r
          )
        );
      return g ? v.render(0) : v;
    }),
    (e.tweenFromTo = function (i, r, o) {
      return this.tweenTo(r, Ai({ startAt: { time: Li(this, i) } }, o));
    }),
    (e.recent = function () {
      return this._recent;
    }),
    (e.nextLabel = function (i) {
      return i === void 0 && (i = this._time), Z_(this, Li(this, i));
    }),
    (e.previousLabel = function (i) {
      return i === void 0 && (i = this._time), Z_(this, Li(this, i), 1);
    }),
    (e.currentLabel = function (i) {
      return arguments.length
        ? this.seek(i, !0)
        : this.previousLabel(this._time + Ie);
    }),
    (e.shiftChildren = function (i, r, o) {
      o === void 0 && (o = 0);
      for (var l = this._first, u = this.labels, h; l; )
        l._start >= o && ((l._start += i), (l._end += i)), (l = l._next);
      if (r) for (h in u) u[h] >= o && (u[h] += i);
      return Us(this);
    }),
    (e.invalidate = function () {
      var i = this._first;
      for (this._lock = 0; i; ) i.invalidate(), (i = i._next);
      return a.prototype.invalidate.call(this);
    }),
    (e.clear = function (i) {
      i === void 0 && (i = !0);
      for (var r = this._first, o; r; ) (o = r._next), this.remove(r), (r = o);
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        Us(this)
      );
    }),
    (e.totalDuration = function (i) {
      var r = 0,
        o = this,
        l = o._last,
        u = Qi,
        h,
        f,
        m;
      if (arguments.length)
        return o.timeScale(
          (o._repeat < 0 ? o.duration() : o.totalDuration()) /
            (o.reversed() ? -i : i)
        );
      if (o._dirty) {
        for (m = o.parent; l; )
          (h = l._prev),
            l._dirty && l.totalDuration(),
            (f = l._start),
            f > u && o._sort && l._ts && !o._lock
              ? ((o._lock = 1), (er(o, l, f - l._delay, 1)._lock = 0))
              : (u = f),
            f < 0 &&
              l._ts &&
              ((r -= f),
              ((!m && !o._dp) || (m && m.smoothChildTiming)) &&
                ((o._start += f / o._ts), (o._time -= f), (o._tTime -= f)),
              o.shiftChildren(-f, !1, -1 / 0),
              (u = 0)),
            l._end > r && l._ts && (r = l._end),
            (l = h);
        Eo(o, o === qe && o._time > r ? o._time : r, 1, 1), (o._dirty = 0);
      }
      return o._tDur;
    }),
    (t.updateRoot = function (i) {
      if ((qe._ts && (P_(qe, Oc(i, qe)), (L_ = Pi.frame)), Pi.frame >= C_)) {
        C_ += Zn.autoSleep || 120;
        var r = qe._first;
        if ((!r || !r._ts) && Zn.autoSleep && Pi._listeners.length < 2) {
          for (; r && !r._ts; ) r = r._next;
          r || Pi.sleep();
        }
      }
    }),
    t
  );
})($a);
Ai(Jn.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var bA = function (t, e, n, i, r, o, l) {
    var u = new $n(this._pt, t, e, 0, 1, a0, null, r),
      h = 0,
      f = 0,
      m,
      g,
      p,
      v,
      x,
      b,
      _,
      y;
    for (
      u.b = n,
        u.e = i,
        n += "",
        i += "",
        (_ = ~i.indexOf("random(")) && (i = Za(i)),
        o && ((y = [n, i]), o(y, t, e), (n = y[0]), (i = y[1])),
        g = n.match(yf) || [];
      (m = yf.exec(i));

    )
      (v = m[0]),
        (x = i.substring(h, m.index)),
        p ? (p = (p + 1) % 5) : x.substr(-5) === "rgba(" && (p = 1),
        v !== g[f++] &&
          ((b = parseFloat(g[f - 1]) || 0),
          (u._pt = {
            _next: u._pt,
            p: x || f === 1 ? x : ",",
            s: b,
            c:
              v.charAt(1) === "="
                ? parseFloat(v.substr(2)) * (v.charAt(0) === "-" ? -1 : 1)
                : parseFloat(v) - b,
            m: p && p < 4 ? Math.round : 0,
          }),
          (h = yf.lastIndex));
    return (
      (u.c = h < i.length ? i.substring(h, i.length) : ""),
      (u.fp = l),
      (M_.test(i) || _) && (u.e = 0),
      (this._pt = u),
      u
    );
  },
  Nf = function (t, e, n, i, r, o, l, u, h) {
    dn(i) && (i = i(r || 0, t, o));
    var f = t[e],
      m =
        n !== "get"
          ? n
          : dn(f)
          ? h
            ? t[
                e.indexOf("set") || !dn(t["get" + e.substr(3)])
                  ? e
                  : "get" + e.substr(3)
              ](h)
            : t[e]()
          : f,
      g = dn(f) ? (h ? AA : s0) : Bf,
      p;
    if (
      (yn(i) &&
        (~i.indexOf("random(") && (i = Za(i)),
        i.charAt(1) === "=" &&
          ((p =
            parseFloat(m) +
            parseFloat(i.substr(2)) * (i.charAt(0) === "-" ? -1 : 1) +
            (fi(m) || 0)),
          (p || p === 0) && (i = p))),
      m !== i)
    )
      return !isNaN(m * i) && i !== ""
        ? ((p = new $n(
            this._pt,
            t,
            e,
            +m || 0,
            i - (m || 0),
            typeof f == "boolean" ? CA : o0,
            0,
            g
          )),
          h && (p.fp = h),
          l && p.modifier(l, this, t),
          (this._pt = p))
        : (!f && !(e in t) && Mf(e, i),
          bA.call(this, t, e, m, i, g, u || Zn.stringFilter, h));
  },
  MA = function (t, e, n, i, r) {
    if (
      (dn(t) && (t = Ka(t, r, e, n, i)),
      !Ar(t) || (t.style && t.nodeType) || li(t) || w_(t))
    )
      return yn(t) ? Ka(t, r, e, n, i) : t;
    var o = {},
      l;
    for (l in t) o[l] = Ka(t[l], r, e, n, i);
    return o;
  },
  i0 = function (t, e, n, i, r, o) {
    var l, u, h, f;
    if (
      ui[t] &&
      (l = new ui[t]()).init(
        r,
        l.rawVars ? e[t] : MA(e[t], i, r, o, n),
        n,
        i,
        o
      ) !== !1 &&
      ((n._pt = u = new $n(n._pt, r, t, 0, 1, l.render, l, 0, l.priority)),
      n !== Ao)
    )
      for (h = n._ptLookup[n._targets.indexOf(r)], f = l._props.length; f--; )
        h[l._props[f]] = u;
    return l;
  },
  Qr,
  SA = function a(t, e) {
    var n = t.vars,
      i = n.ease,
      r = n.startAt,
      o = n.immediateRender,
      l = n.lazy,
      u = n.onUpdate,
      h = n.onUpdateParams,
      f = n.callbackScope,
      m = n.runBackwards,
      g = n.yoyoEase,
      p = n.keyframes,
      v = n.autoRevert,
      x = t._dur,
      b = t._startAt,
      _ = t._targets,
      y = t.parent,
      E = y && y.data === "nested" ? y.parent._targets : _,
      M = t._overwrite === "auto" && !gf,
      A = t.timeline,
      R,
      T,
      B,
      X,
      H,
      O,
      it,
      W,
      q,
      tt,
      V,
      Q,
      st;
    if (
      (A && (!p || !i) && (i = "none"),
      (t._ease = Co(i, wo.ease)),
      (t._yEase = g ? Q_(Co(g === !0 ? i : g, wo.ease)) : 0),
      g &&
        t._yoyo &&
        !t._repeat &&
        ((g = t._yEase), (t._yEase = t._ease), (t._ease = g)),
      (t._from = !A && !!n.runBackwards),
      !A)
    ) {
      if (
        ((W = _[0] ? zs(_[0]).harness : 0),
        (Q = W && n[W.prop]),
        (R = Cf(n, Sf)),
        b && b.render(-1, !0).kill(),
        r)
      )
        if (
          (Jr(
            (t._startAt = pn.set(
              _,
              Ai(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: y,
                  immediateRender: !0,
                  lazy: jn(l),
                  startAt: null,
                  delay: 0,
                  onUpdate: u,
                  onUpdateParams: h,
                  callbackScope: f,
                  stagger: 0,
                },
                r
              )
            ))
          ),
          e < 0 && !o && !v && t._startAt.render(-1, !0),
          o)
        ) {
          if ((e > 0 && !v && (t._startAt = 0), x && e <= 0)) {
            e && (t._zTime = e);
            return;
          }
        } else v === !1 && (t._startAt = 0);
      else if (m && x) {
        if (b) !v && (t._startAt = 0);
        else if (
          (e && (o = !1),
          (B = Ai(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: o && jn(l),
              immediateRender: o,
              stagger: 0,
              parent: y,
            },
            R
          )),
          Q && (B[W.prop] = Q),
          Jr((t._startAt = pn.set(_, B))),
          e < 0 && t._startAt.render(-1, !0),
          !o)
        )
          a(t._startAt, Ie);
        else if (!e) return;
      }
      for (t._pt = 0, l = (x && jn(l)) || (l && !x), T = 0; T < _.length; T++) {
        if (
          ((H = _[T]),
          (it = H._gsap || Lf(_)[T]._gsap),
          (t._ptLookup[T] = tt = {}),
          Tf[it.id] && jr.length && Dc(),
          (V = E === _ ? T : E.indexOf(H)),
          W &&
            (q = new W()).init(H, Q || R, t, V, E) !== !1 &&
            ((t._pt = X =
              new $n(t._pt, H, q.name, 0, 1, q.render, q, 0, q.priority)),
            q._props.forEach(function (Lt) {
              tt[Lt] = X;
            }),
            q.priority && (O = 1)),
          !W || Q)
        )
          for (B in R)
            ui[B] && (q = i0(B, R, t, V, H, E))
              ? q.priority && (O = 1)
              : (tt[B] = X =
                  Nf.call(t, H, B, "get", R[B], V, E, 0, n.stringFilter));
        t._op && t._op[T] && t.kill(H, t._op[T]),
          M &&
            t._pt &&
            ((Qr = t),
            qe.killTweensOf(H, tt, t.globalTime(e)),
            (st = !t.parent),
            (Qr = 0)),
          t._pt && l && (Tf[it.id] = 1);
      }
      O && l0(t), t._onInit && t._onInit(t);
    }
    (t._onUpdate = u), (t._initted = (!t._op || t._pt) && !st);
  },
  TA = function (t, e) {
    var n = t[0] ? zs(t[0]).harness : 0,
      i = n && n.aliases,
      r,
      o,
      l,
      u;
    if (!i) return e;
    r = So({}, e);
    for (o in i)
      if (o in r) for (u = i[o].split(","), l = u.length; l--; ) r[u[l]] = r[o];
    return r;
  },
  Ka = function (t, e, n, i, r) {
    return dn(t)
      ? t.call(e, n, i, r)
      : yn(t) && ~t.indexOf("random(")
      ? Za(t)
      : t;
  },
  r0 = Af + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
  EA = (r0 + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
  pn = (function (a) {
    __(t, a);
    function t(n, i, r, o) {
      var l;
      typeof i == "number" && ((r.duration = i), (i = r), (r = null)),
        (l = a.call(this, o ? i : Xa(i)) || this);
      var u = l.vars,
        h = u.duration,
        f = u.delay,
        m = u.immediateRender,
        g = u.stagger,
        p = u.overwrite,
        v = u.keyframes,
        x = u.defaults,
        b = u.scrollTrigger,
        _ = u.yoyoEase,
        y = i.parent || qe,
        E = (li(n) || w_(n) ? Er(n[0]) : "length" in i) ? [n] : Ci(n),
        M,
        A,
        R,
        T,
        B,
        X,
        H,
        O;
      if (
        ((l._targets = E.length
          ? Lf(E)
          : Pc(
              "GSAP target " + n + " not found. https://greensock.com",
              !Zn.nullTargetWarn
            ) || []),
        (l._ptLookup = []),
        (l._overwrite = p),
        v || g || y_(h) || y_(f))
      ) {
        if (
          ((i = l.vars),
          (M = l.timeline = new Jn({ data: "nested", defaults: x || {} })),
          M.kill(),
          (M.parent = M._dp = Tr(l)),
          (M._start = 0),
          v)
        )
          Xa(Ai(M.vars.defaults, { ease: "none" })),
            g
              ? E.forEach(function (it, W) {
                  return v.forEach(function (q, tt) {
                    return M.to(it, q, tt ? ">" : W * g);
                  });
                })
              : v.forEach(function (it) {
                  return M.to(E, it, ">");
                });
        else {
          if (((T = E.length), (H = g ? V_(g) : Mo), Ar(g)))
            for (B in g) ~r0.indexOf(B) && (O || (O = {}), (O[B] = g[B]));
          for (A = 0; A < T; A++) {
            R = {};
            for (B in i) EA.indexOf(B) < 0 && (R[B] = i[B]);
            (R.stagger = 0),
              _ && (R.yoyoEase = _),
              O && So(R, O),
              (X = E[A]),
              (R.duration = +Ka(h, Tr(l), A, X, E)),
              (R.delay = (+Ka(f, Tr(l), A, X, E) || 0) - l._delay),
              !g &&
                T === 1 &&
                R.delay &&
                ((l._delay = f = R.delay), (l._start += f), (R.delay = 0)),
              M.to(X, R, H(A, X, E));
          }
          M.duration() ? (h = f = 0) : (l.timeline = 0);
        }
        h || l.duration((h = M.duration()));
      } else l.timeline = 0;
      return (
        p === !0 && !gf && ((Qr = Tr(l)), qe.killTweensOf(E), (Qr = 0)),
        er(y, Tr(l), r),
        i.reversed && l.reverse(),
        i.paused && l.paused(!0),
        (m ||
          (!h &&
            !v &&
            l._start === An(y._time) &&
            jn(m) &&
            eA(Tr(l)) &&
            y.data !== "nested")) &&
          ((l._tTime = -Ie), l.render(Math.max(0, -f))),
        b && z_(Tr(l), b),
        l
      );
    }
    var e = t.prototype;
    return (
      (e.render = function (i, r, o) {
        var l = this._time,
          u = this._tDur,
          h = this._dur,
          f = i > u - Ie && i >= 0 ? u : i < Ie ? 0 : i,
          m,
          g,
          p,
          v,
          x,
          b,
          _,
          y,
          E;
        if (!h) iA(this, i, r, o);
        else if (
          f !== this._tTime ||
          !i ||
          o ||
          (!this._initted && this._tTime) ||
          (this._startAt && this._zTime < 0 != i < 0)
        ) {
          if (((m = f), (y = this.timeline), this._repeat)) {
            if (((v = h + this._rDelay), this._repeat < -1 && i < 0))
              return this.totalTime(v * 100 + i, r, o);
            if (
              ((m = An(f % v)),
              f === u
                ? ((p = this._repeat), (m = h))
                : ((p = ~~(f / v)),
                  p && p === f / v && ((m = h), p--),
                  m > h && (m = h)),
              (b = this._yoyo && p & 1),
              b && ((E = this._yEase), (m = h - m)),
              (x = To(this._tTime, v)),
              m === l && !o && this._initted)
            )
              return this;
            p !== x &&
              (y && this._yEase && t0(y, b),
              this.vars.repeatRefresh &&
                !b &&
                !this._lock &&
                ((this._lock = o = 1),
                (this.render(An(v * p), !0).invalidate()._lock = 0)));
          }
          if (!this._initted) {
            if (U_(this, i < 0 ? i : m, o, r)) return (this._tTime = 0), this;
            if (h !== this._dur) return this.render(i, r, o);
          }
          if (
            ((this._tTime = f),
            (this._time = m),
            !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
            (this.ratio = _ = (E || this._ease)(m / h)),
            this._from && (this.ratio = _ = 1 - _),
            m && !l && !r && (Ri(this, "onStart"), this._tTime !== f))
          )
            return this;
          for (g = this._pt; g; ) g.r(_, g.d), (g = g._next);
          (y && y.render(i < 0 ? i : !m && b ? -Ie : y._dur * _, r, o)) ||
            (this._startAt && (this._zTime = i)),
            this._onUpdate &&
              !r &&
              (i < 0 && this._startAt && this._startAt.render(i, !0, o),
              Ri(this, "onUpdate")),
            this._repeat &&
              p !== x &&
              this.vars.onRepeat &&
              !r &&
              this.parent &&
              Ri(this, "onRepeat"),
            (f === this._tDur || !f) &&
              this._tTime === f &&
              (i < 0 &&
                this._startAt &&
                !this._onUpdate &&
                this._startAt.render(i, !0, !0),
              (i || !h) &&
                ((f === this._tDur && this._ts > 0) || (!f && this._ts < 0)) &&
                Jr(this, 1),
              !r &&
                !(i < 0 && !l) &&
                (f || l) &&
                (Ri(this, f === u ? "onComplete" : "onReverseComplete", !0),
                this._prom &&
                  !(f < u && this.timeScale() > 0) &&
                  this._prom()));
        }
        return this;
      }),
      (e.targets = function () {
        return this._targets;
      }),
      (e.invalidate = function () {
        return (
          (this._pt =
            this._op =
            this._startAt =
            this._onUpdate =
            this._lazy =
            this.ratio =
              0),
          (this._ptLookup = []),
          this.timeline && this.timeline.invalidate(),
          a.prototype.invalidate.call(this)
        );
      }),
      (e.kill = function (i, r) {
        if ((r === void 0 && (r = "all"), !i && (!r || r === "all")))
          return (this._lazy = this._pt = 0), this.parent ? ja(this) : this;
        if (this.timeline) {
          var o = this.timeline.totalDuration();
          return (
            this.timeline.killTweensOf(i, r, Qr && Qr.vars.overwrite !== !0)
              ._first || ja(this),
            this.parent &&
              o !== this.timeline.totalDuration() &&
              Eo(this, (this._dur * this.timeline._tDur) / o, 0, 1),
            this
          );
        }
        var l = this._targets,
          u = i ? Ci(i) : l,
          h = this._ptLookup,
          f = this._pt,
          m,
          g,
          p,
          v,
          x,
          b,
          _;
        if ((!r || r === "all") && KE(l, u))
          return r === "all" && (this._pt = 0), ja(this);
        for (
          m = this._op = this._op || [],
            r !== "all" &&
              (yn(r) &&
                ((x = {}),
                hi(r, function (y) {
                  return (x[y] = 1);
                }),
                (r = x)),
              (r = TA(l, r))),
            _ = l.length;
          _--;

        )
          if (~u.indexOf(l[_])) {
            (g = h[_]),
              r === "all"
                ? ((m[_] = r), (v = g), (p = {}))
                : ((p = m[_] = m[_] || {}), (v = r));
            for (x in v)
              (b = g && g[x]),
                b &&
                  ((!("kill" in b.d) || b.d.kill(x) === !0) &&
                    Fc(this, b, "_pt"),
                  delete g[x]),
                p !== "all" && (p[x] = 1);
          }
        return this._initted && !this._pt && f && ja(this), this;
      }),
      (t.to = function (i, r) {
        return new t(i, r, arguments[2]);
      }),
      (t.from = function (i, r) {
        return Ya(1, arguments);
      }),
      (t.delayedCall = function (i, r, o, l) {
        return new t(r, 0, {
          immediateRender: !1,
          lazy: !1,
          overwrite: !1,
          delay: i,
          onComplete: r,
          onReverseComplete: r,
          onCompleteParams: o,
          onReverseCompleteParams: o,
          callbackScope: l,
        });
      }),
      (t.fromTo = function (i, r, o) {
        return Ya(2, arguments);
      }),
      (t.set = function (i, r) {
        return (r.duration = 0), r.repeatDelay || (r.repeat = 0), new t(i, r);
      }),
      (t.killTweensOf = function (i, r, o) {
        return qe.killTweensOf(i, r, o);
      }),
      t
    );
  })($a);
Ai(pn.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
hi("staggerTo,staggerFrom,staggerFromTo", function (a) {
  pn[a] = function () {
    var t = new Jn(),
      e = Pf.call(arguments, 0);
    return e.splice(a === "staggerFromTo" ? 5 : 4, 0, 0), t[a].apply(t, e);
  };
});
var Bf = function (t, e, n) {
    return (t[e] = n);
  },
  s0 = function (t, e, n) {
    return t[e](n);
  },
  AA = function (t, e, n, i) {
    return t[e](i.fp, n);
  },
  LA = function (t, e, n) {
    return t.setAttribute(e, n);
  },
  zf = function (t, e) {
    return dn(t[e]) ? s0 : vf(t[e]) && t.setAttribute ? LA : Bf;
  },
  o0 = function (t, e) {
    return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e6) / 1e6, e);
  },
  CA = function (t, e) {
    return e.set(e.t, e.p, !!(e.s + e.c * t), e);
  },
  a0 = function (t, e) {
    var n = e._pt,
      i = "";
    if (!t && e.b) i = e.b;
    else if (t === 1 && e.e) i = e.e;
    else {
      for (; n; )
        (i =
          n.p +
          (n.m ? n.m(n.s + n.c * t) : Math.round((n.s + n.c * t) * 1e4) / 1e4) +
          i),
          (n = n._next);
      i += e.c;
    }
    e.set(e.t, e.p, i, e);
  },
  Uf = function (t, e) {
    for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
  },
  RA = function (t, e, n, i) {
    for (var r = this._pt, o; r; )
      (o = r._next), r.p === i && r.modifier(t, e, n), (r = o);
  },
  PA = function (t) {
    for (var e = this._pt, n, i; e; )
      (i = e._next),
        (e.p === t && !e.op) || e.op === t
          ? Fc(this, e, "_pt")
          : e.dep || (n = 1),
        (e = i);
    return !n;
  },
  IA = function (t, e, n, i) {
    i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
  },
  l0 = function (t) {
    for (var e = t._pt, n, i, r, o; e; ) {
      for (n = e._next, i = r; i && i.pr > e.pr; ) i = i._next;
      (e._prev = i ? i._prev : o) ? (e._prev._next = e) : (r = e),
        (e._next = i) ? (i._prev = e) : (o = e),
        (e = n);
    }
    t._pt = r;
  },
  $n = (function () {
    function a(e, n, i, r, o, l, u, h, f) {
      (this.t = n),
        (this.s = r),
        (this.c = o),
        (this.p = i),
        (this.r = l || o0),
        (this.d = u || this),
        (this.set = h || Bf),
        (this.pr = f || 0),
        (this._next = e),
        e && (e._prev = this);
    }
    var t = a.prototype;
    return (
      (t.modifier = function (n, i, r) {
        (this.mSet = this.mSet || this.set),
          (this.set = IA),
          (this.m = n),
          (this.mt = r),
          (this.tween = i);
      }),
      a
    );
  })();
hi(
  Af +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (a) {
    return (Sf[a] = 1);
  }
);
ci.TweenMax = ci.TweenLite = pn;
ci.TimelineLite = ci.TimelineMax = Jn;
qe = new Jn({
  sortChildren: !1,
  defaults: wo,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
});
Zn.stringFilter = K_;
var zc = {
  registerPlugin: function () {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
      e[n] = arguments[n];
    e.forEach(function (i) {
      return mA(i);
    });
  },
  timeline: function (t) {
    return new Jn(t);
  },
  getTweensOf: function (t, e) {
    return qe.getTweensOf(t, e);
  },
  getProperty: function (t, e, n, i) {
    yn(t) && (t = Ci(t)[0]);
    var r = zs(t || {}).get,
      o = n ? D_ : I_;
    return (
      n === "native" && (n = ""),
      t &&
        (e
          ? o(((ui[e] && ui[e].get) || r)(t, e, n, i))
          : function (l, u, h) {
              return o(((ui[l] && ui[l].get) || r)(t, l, u, h));
            })
    );
  },
  quickSetter: function (t, e, n) {
    if (((t = Ci(t)), t.length > 1)) {
      var i = t.map(function (f) {
          return nr.quickSetter(f, e, n);
        }),
        r = i.length;
      return function (f) {
        for (var m = r; m--; ) i[m](f);
      };
    }
    t = t[0] || {};
    var o = ui[e],
      l = zs(t),
      u = (l.harness && (l.harness.aliases || {})[e]) || e,
      h = o
        ? function (f) {
            var m = new o();
            (Ao._pt = 0),
              m.init(t, n ? f + n : f, Ao, 0, [t]),
              m.render(1, m),
              Ao._pt && Uf(1, Ao);
          }
        : l.set(t, u);
    return o
      ? h
      : function (f) {
          return h(t, u, n ? f + n : f, l, 1);
        };
  },
  isTweening: function (t) {
    return qe.getTweensOf(t, !0).length > 0;
  },
  defaults: function (t) {
    return t && t.ease && (t.ease = Co(t.ease, wo.ease)), F_(wo, t || {});
  },
  config: function (t) {
    return F_(Zn, t || {});
  },
  registerEffect: function (t) {
    var e = t.name,
      n = t.effect,
      i = t.plugins,
      r = t.defaults,
      o = t.extendTimeline;
    (i || "").split(",").forEach(function (l) {
      return (
        l && !ui[l] && !ci[l] && Pc(e + " effect requires " + l + " plugin.")
      );
    }),
      (Ef[e] = function (l, u, h) {
        return n(Ci(l), Ai(u || {}, r), h);
      }),
      o &&
        (Jn.prototype[e] = function (l, u, h) {
          return this.add(Ef[e](l, Ar(u) ? u : (h = u) && {}, this), h);
        });
  },
  registerEase: function (t, e) {
    pe[t] = Co(e);
  },
  parseEase: function (t, e) {
    return arguments.length ? Co(t, e) : pe;
  },
  getById: function (t) {
    return qe.getById(t);
  },
  exportRoot: function (t, e) {
    t === void 0 && (t = {});
    var n = new Jn(t),
      i,
      r;
    for (
      n.smoothChildTiming = jn(t.smoothChildTiming),
        qe.remove(n),
        n._dp = 0,
        n._time = n._tTime = qe._time,
        i = qe._first;
      i;

    )
      (r = i._next),
        (e ||
          !(
            !i._dur &&
            i instanceof pn &&
            i.vars.onComplete === i._targets[0]
          )) &&
          er(n, i, i._start - i._delay),
        (i = r);
    return er(qe, n, 0), n;
  },
  utils: {
    wrap: fA,
    wrapYoyo: dA,
    distribute: V_,
    random: X_,
    snap: W_,
    normalize: hA,
    getUnit: fi,
    clamp: oA,
    splitColor: j_,
    toArray: Ci,
    selector: lA,
    mapRange: q_,
    pipe: cA,
    unitize: uA,
    interpolate: pA,
    shuffle: H_,
  },
  install: E_,
  effects: Ef,
  ticker: Pi,
  updateRoot: Jn.updateRoot,
  plugins: ui,
  globalTimeline: qe,
  core: {
    PropTween: $n,
    globals: A_,
    Tween: pn,
    Timeline: Jn,
    Animation: $a,
    getCache: zs,
    _removeLinkedListItem: Fc,
    suppressOverwrites: function (t) {
      return (gf = t);
    },
  },
};
hi("to,from,fromTo,delayedCall,set,killTweensOf", function (a) {
  return (zc[a] = pn[a]);
});
Pi.add(Jn.updateRoot);
Ao = zc.to({}, { duration: 0 });
var DA = function (t, e) {
    for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
      n = n._next;
    return n;
  },
  FA = function (t, e) {
    var n = t._targets,
      i,
      r,
      o;
    for (i in e)
      for (r = n.length; r--; )
        (o = t._ptLookup[r][i]),
          o &&
            (o = o.d) &&
            (o._pt && (o = DA(o, i)),
            o && o.modifier && o.modifier(e[i], t, n[r], i));
  },
  kf = function (t, e) {
    return {
      name: t,
      rawVars: 1,
      init: function (i, r, o) {
        o._onInit = function (l) {
          var u, h;
          if (
            (yn(r) &&
              ((u = {}),
              hi(r, function (f) {
                return (u[f] = 1);
              }),
              (r = u)),
            e)
          ) {
            u = {};
            for (h in r) u[h] = e(r[h]);
            r = u;
          }
          FA(l, r);
        };
      },
    };
  },
  nr =
    zc.registerPlugin(
      {
        name: "attr",
        init: function (t, e, n, i, r) {
          var o, l;
          for (o in e)
            (l = this.add(
              t,
              "setAttribute",
              (t.getAttribute(o) || 0) + "",
              e[o],
              i,
              r,
              0,
              0,
              o
            )),
              l && (l.op = o),
              this._props.push(o);
        },
      },
      {
        name: "endArray",
        init: function (t, e) {
          for (var n = e.length; n--; ) this.add(t, n, t[n] || 0, e[n]);
        },
      },
      kf("roundProps", If),
      kf("modifiers"),
      kf("snap", W_)
    ) || zc;
pn.version = Jn.version = nr.version = "3.8.0";
T_ = 1;
x_() && Lo();
pe.Power0;
pe.Power1;
pe.Power2;
pe.Power3;
pe.Power4;
pe.Linear;
pe.Quad;
pe.Cubic;
pe.Quart;
pe.Quint;
pe.Strong;
pe.Elastic;
pe.Back;
pe.SteppedEase;
pe.Bounce;
pe.Sine;
var lF = pe.Expo;
pe.Circ;
/*!
 * CSSPlugin 3.8.0
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var c0,
  ts,
  Ro,
  Gf,
  Gs,
  u0,
  OA = function () {
    return typeof window != "undefined";
  },
  es = {},
  Hs = 180 / Math.PI,
  Po = Math.PI / 180,
  Io = Math.atan2,
  h0 = 1e8,
  f0 = /([A-Z])/g,
  NA = /(?:left|right|width|margin|padding|x)/i,
  BA = /[\s,\(]\S/,
  ns = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  d0 = function (t, e) {
    return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u, e);
  },
  zA = function (t, e) {
    return e.set(
      e.t,
      e.p,
      t === 1 ? e.e : Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u,
      e
    );
  },
  UA = function (t, e) {
    return e.set(
      e.t,
      e.p,
      t ? Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u : e.b,
      e
    );
  },
  kA = function (t, e) {
    var n = e.s + e.c * t;
    e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
  },
  p0 = function (t, e) {
    return e.set(e.t, e.p, t ? e.e : e.b, e);
  },
  m0 = function (t, e) {
    return e.set(e.t, e.p, t !== 1 ? e.b : e.e, e);
  },
  GA = function (t, e, n) {
    return (t.style[e] = n);
  },
  HA = function (t, e, n) {
    return t.style.setProperty(e, n);
  },
  VA = function (t, e, n) {
    return (t._gsap[e] = n);
  },
  WA = function (t, e, n) {
    return (t._gsap.scaleX = t._gsap.scaleY = n);
  },
  XA = function (t, e, n, i, r) {
    var o = t._gsap;
    (o.scaleX = o.scaleY = n), o.renderTransform(r, o);
  },
  YA = function (t, e, n, i, r) {
    var o = t._gsap;
    (o[e] = n), o.renderTransform(r, o);
  },
  wn = "transform",
  is = wn + "Origin",
  g0,
  Hf = function (t, e) {
    var n = ts.createElementNS
      ? ts.createElementNS(
          (e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          t
        )
      : ts.createElement(t);
    return n.style ? n : ts.createElement(t);
  },
  Lr = function a(t, e, n) {
    var i = getComputedStyle(t);
    return (
      i[e] ||
      i.getPropertyValue(e.replace(f0, "-$1").toLowerCase()) ||
      i.getPropertyValue(e) ||
      (!n && a(t, Do(e) || e, 1)) ||
      ""
    );
  },
  _0 = "O,Moz,ms,Ms,Webkit".split(","),
  Do = function (t, e, n) {
    var i = e || Gs,
      r = i.style,
      o = 5;
    if (t in r && !n) return t;
    for (
      t = t.charAt(0).toUpperCase() + t.substr(1);
      o-- && !(_0[o] + t in r);

    );
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? _0[o] : "") + t;
  },
  Vf = function () {
    OA() &&
      window.document &&
      ((c0 = window),
      (ts = c0.document),
      (Ro = ts.documentElement),
      (Gs = Hf("div") || { style: {} }),
      Hf("div"),
      (wn = Do(wn)),
      (is = wn + "Origin"),
      (Gs.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      (g0 = !!Do("perspective")),
      (Gf = 1));
  },
  Wf = function a(t) {
    var e = Hf(
        "svg",
        (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) ||
          "http://www.w3.org/2000/svg"
      ),
      n = this.parentNode,
      i = this.nextSibling,
      r = this.style.cssText,
      o;
    if (
      (Ro.appendChild(e),
      e.appendChild(this),
      (this.style.display = "block"),
      t)
    )
      try {
        (o = this.getBBox()),
          (this._gsapBBox = this.getBBox),
          (this.getBBox = a);
      } catch {}
    else this._gsapBBox && (o = this._gsapBBox());
    return (
      n && (i ? n.insertBefore(this, i) : n.appendChild(this)),
      Ro.removeChild(e),
      (this.style.cssText = r),
      o
    );
  },
  v0 = function (t, e) {
    for (var n = e.length; n--; )
      if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
  },
  x0 = function (t) {
    var e;
    try {
      e = t.getBBox();
    } catch {
      e = Wf.call(t, !0);
    }
    return (
      (e && (e.width || e.height)) || t.getBBox === Wf || (e = Wf.call(t, !0)),
      e && !e.width && !e.x && !e.y
        ? {
            x: +v0(t, ["x", "cx", "x1"]) || 0,
            y: +v0(t, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : e
    );
  },
  y0 = function (t) {
    return !!(t.getCTM && (!t.parentNode || t.ownerSVGElement) && x0(t));
  },
  Qa = function (t, e) {
    if (e) {
      var n = t.style;
      e in es && e !== is && (e = wn),
        n.removeProperty
          ? ((e.substr(0, 2) === "ms" || e.substr(0, 6) === "webkit") &&
              (e = "-" + e),
            n.removeProperty(e.replace(f0, "-$1").toLowerCase()))
          : n.removeAttribute(e);
    }
  },
  rs = function (t, e, n, i, r, o) {
    var l = new $n(t._pt, e, n, 0, 1, o ? m0 : p0);
    return (t._pt = l), (l.b = i), (l.e = r), t._props.push(n), l;
  },
  w0 = { deg: 1, rad: 1, turn: 1 },
  ss = function a(t, e, n, i) {
    var r = parseFloat(n) || 0,
      o = (n + "").trim().substr((r + "").length) || "px",
      l = Gs.style,
      u = NA.test(e),
      h = t.tagName.toLowerCase() === "svg",
      f = (h ? "client" : "offset") + (u ? "Width" : "Height"),
      m = 100,
      g = i === "px",
      p = i === "%",
      v,
      x,
      b,
      _;
    return i === o || !r || w0[i] || w0[o]
      ? r
      : (o !== "px" && !g && (r = a(t, e, n, "px")),
        (_ = t.getCTM && y0(t)),
        (p || o === "%") && (es[e] || ~e.indexOf("adius"))
          ? ((v = _ ? t.getBBox()[u ? "width" : "height"] : t[f]),
            sn(p ? (r / v) * m : (r / 100) * v))
          : ((l[u ? "width" : "height"] = m + (g ? o : i)),
            (x =
              ~e.indexOf("adius") || (i === "em" && t.appendChild && !h)
                ? t
                : t.parentNode),
            _ && (x = (t.ownerSVGElement || {}).parentNode),
            (!x || x === ts || !x.appendChild) && (x = ts.body),
            (b = x._gsap),
            b && p && b.width && u && b.time === Pi.time
              ? sn((r / b.width) * m)
              : ((p || o === "%") && (l.position = Lr(t, "position")),
                x === t && (l.position = "static"),
                x.appendChild(Gs),
                (v = Gs[f]),
                x.removeChild(Gs),
                (l.position = "absolute"),
                u && p && ((b = zs(x)), (b.time = Pi.time), (b.width = x[f])),
                sn(g ? (v * r) / m : v && r ? (m / v) * r : 0))));
  },
  Fo = function (t, e, n, i) {
    var r;
    return (
      Gf || Vf(),
      e in ns &&
        e !== "transform" &&
        ((e = ns[e]), ~e.indexOf(",") && (e = e.split(",")[0])),
      es[e] && e !== "transform"
        ? ((r = el(t, i)),
          (r =
            e !== "transformOrigin"
              ? r[e]
              : r.svg
              ? r.origin
              : kc(Lr(t, is)) + " " + r.zOrigin + "px"))
        : ((r = t.style[e]),
          (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) &&
            (r =
              (Uc[e] && Uc[e](t, e, n)) ||
              Lr(t, e) ||
              R_(t, e) ||
              (e === "opacity" ? 1 : 0))),
      n && !~(r + "").trim().indexOf(" ") ? ss(t, e, r, n) + n : r
    );
  },
  qA = function (t, e, n, i) {
    if (!n || n === "none") {
      var r = Do(e, t, 1),
        o = r && Lr(t, r, 1);
      o && o !== n
        ? ((e = r), (n = o))
        : e === "borderColor" && (n = Lr(t, "borderTopColor"));
    }
    var l = new $n(this._pt, t.style, e, 0, 1, a0),
      u = 0,
      h = 0,
      f,
      m,
      g,
      p,
      v,
      x,
      b,
      _,
      y,
      E,
      M,
      A,
      R;
    if (
      ((l.b = n),
      (l.e = i),
      (n += ""),
      (i += ""),
      i === "auto" && ((t.style[e] = i), (i = Lr(t, e) || i), (t.style[e] = n)),
      (f = [n, i]),
      K_(f),
      (n = f[0]),
      (i = f[1]),
      (g = n.match(bo) || []),
      (R = i.match(bo) || []),
      R.length)
    ) {
      for (; (m = bo.exec(i)); )
        (b = m[0]),
          (y = i.substring(u, m.index)),
          v
            ? (v = (v + 1) % 5)
            : (y.substr(-5) === "rgba(" || y.substr(-5) === "hsla(") && (v = 1),
          b !== (x = g[h++] || "") &&
            ((p = parseFloat(x) || 0),
            (M = x.substr((p + "").length)),
            (A = b.charAt(1) === "=" ? +(b.charAt(0) + "1") : 0),
            A && (b = b.substr(2)),
            (_ = parseFloat(b)),
            (E = b.substr((_ + "").length)),
            (u = bo.lastIndex - E.length),
            E ||
              ((E = E || Zn.units[e] || M),
              u === i.length && ((i += E), (l.e += E))),
            M !== E && (p = ss(t, e, x, E) || 0),
            (l._pt = {
              _next: l._pt,
              p: y || h === 1 ? y : ",",
              s: p,
              c: A ? A * _ : _ - p,
              m: (v && v < 4) || e === "zIndex" ? Math.round : 0,
            }));
      l.c = u < i.length ? i.substring(u, i.length) : "";
    } else l.r = e === "display" && i === "none" ? m0 : p0;
    return M_.test(i) && (l.e = 0), (this._pt = l), l;
  },
  b0 = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" },
  ZA = function (t) {
    var e = t.split(" "),
      n = e[0],
      i = e[1] || "50%";
    return (
      (n === "top" || n === "bottom" || i === "left" || i === "right") &&
        ((t = n), (n = i), (i = t)),
      (e[0] = b0[n] || n),
      (e[1] = b0[i] || i),
      e.join(" ")
    );
  },
  jA = function (t, e) {
    if (e.tween && e.tween._time === e.tween._dur) {
      var n = e.t,
        i = n.style,
        r = e.u,
        o = n._gsap,
        l,
        u,
        h;
      if (r === "all" || r === !0) (i.cssText = ""), (u = 1);
      else
        for (r = r.split(","), h = r.length; --h > -1; )
          (l = r[h]),
            es[l] && ((u = 1), (l = l === "transformOrigin" ? is : wn)),
            Qa(n, l);
      u &&
        (Qa(n, wn),
        o &&
          (o.svg && n.removeAttribute("transform"), el(n, 1), (o.uncache = 1)));
    }
  },
  Uc = {
    clearProps: function (t, e, n, i, r) {
      if (r.data !== "isFromStart") {
        var o = (t._pt = new $n(t._pt, e, n, 0, 0, jA));
        return (o.u = i), (o.pr = -10), (o.tween = r), t._props.push(n), 1;
      }
    },
  },
  tl = [1, 0, 0, 1, 0, 0],
  M0 = {},
  S0 = function (t) {
    return t === "matrix(1, 0, 0, 1, 0, 0)" || t === "none" || !t;
  },
  T0 = function (t) {
    var e = Lr(t, wn);
    return S0(e) ? tl : e.substr(7).match(b_).map(sn);
  },
  Xf = function (t, e) {
    var n = t._gsap || zs(t),
      i = t.style,
      r = T0(t),
      o,
      l,
      u,
      h;
    return n.svg && t.getAttribute("transform")
      ? ((u = t.transform.baseVal.consolidate().matrix),
        (r = [u.a, u.b, u.c, u.d, u.e, u.f]),
        r.join(",") === "1,0,0,1,0,0" ? tl : r)
      : (r === tl &&
          !t.offsetParent &&
          t !== Ro &&
          !n.svg &&
          ((u = i.display),
          (i.display = "block"),
          (o = t.parentNode),
          (!o || !t.offsetParent) &&
            ((h = 1), (l = t.nextSibling), Ro.appendChild(t)),
          (r = T0(t)),
          u ? (i.display = u) : Qa(t, "display"),
          h &&
            (l
              ? o.insertBefore(t, l)
              : o
              ? o.appendChild(t)
              : Ro.removeChild(t))),
        e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
  },
  Yf = function (t, e, n, i, r, o) {
    var l = t._gsap,
      u = r || Xf(t, !0),
      h = l.xOrigin || 0,
      f = l.yOrigin || 0,
      m = l.xOffset || 0,
      g = l.yOffset || 0,
      p = u[0],
      v = u[1],
      x = u[2],
      b = u[3],
      _ = u[4],
      y = u[5],
      E = e.split(" "),
      M = parseFloat(E[0]) || 0,
      A = parseFloat(E[1]) || 0,
      R,
      T,
      B,
      X;
    n
      ? u !== tl &&
        (T = p * b - v * x) &&
        ((B = M * (b / T) + A * (-x / T) + (x * y - b * _) / T),
        (X = M * (-v / T) + A * (p / T) - (p * y - v * _) / T),
        (M = B),
        (A = X))
      : ((R = x0(t)),
        (M = R.x + (~E[0].indexOf("%") ? (M / 100) * R.width : M)),
        (A = R.y + (~(E[1] || E[0]).indexOf("%") ? (A / 100) * R.height : A))),
      i || (i !== !1 && l.smooth)
        ? ((_ = M - h),
          (y = A - f),
          (l.xOffset = m + (_ * p + y * x) - _),
          (l.yOffset = g + (_ * v + y * b) - y))
        : (l.xOffset = l.yOffset = 0),
      (l.xOrigin = M),
      (l.yOrigin = A),
      (l.smooth = !!i),
      (l.origin = e),
      (l.originIsAbsolute = !!n),
      (t.style[is] = "0px 0px"),
      o &&
        (rs(o, l, "xOrigin", h, M),
        rs(o, l, "yOrigin", f, A),
        rs(o, l, "xOffset", m, l.xOffset),
        rs(o, l, "yOffset", g, l.yOffset)),
      t.setAttribute("data-svg-origin", M + " " + A);
  },
  el = function (t, e) {
    var n = t._gsap || new n0(t);
    if ("x" in n && !e && !n.uncache) return n;
    var i = t.style,
      r = n.scaleX < 0,
      o = "px",
      l = "deg",
      u = Lr(t, is) || "0",
      h,
      f,
      m,
      g,
      p,
      v,
      x,
      b,
      _,
      y,
      E,
      M,
      A,
      R,
      T,
      B,
      X,
      H,
      O,
      it,
      W,
      q,
      tt,
      V,
      Q,
      st,
      Lt,
      J,
      vt,
      zt,
      ft,
      Mt;
    return (
      (h = f = m = v = x = b = _ = y = E = 0),
      (g = p = 1),
      (n.svg = !!(t.getCTM && y0(t))),
      (R = Xf(t, n.svg)),
      n.svg &&
        ((V =
          (!n.uncache || u === "0px 0px") &&
          !e &&
          t.getAttribute("data-svg-origin")),
        Yf(t, V || u, !!V || n.originIsAbsolute, n.smooth !== !1, R)),
      (M = n.xOrigin || 0),
      (A = n.yOrigin || 0),
      R !== tl &&
        ((H = R[0]),
        (O = R[1]),
        (it = R[2]),
        (W = R[3]),
        (h = q = R[4]),
        (f = tt = R[5]),
        R.length === 6
          ? ((g = Math.sqrt(H * H + O * O)),
            (p = Math.sqrt(W * W + it * it)),
            (v = H || O ? Io(O, H) * Hs : 0),
            (_ = it || W ? Io(it, W) * Hs + v : 0),
            _ && (p *= Math.abs(Math.cos(_ * Po))),
            n.svg && ((h -= M - (M * H + A * it)), (f -= A - (M * O + A * W))))
          : ((Mt = R[6]),
            (zt = R[7]),
            (Lt = R[8]),
            (J = R[9]),
            (vt = R[10]),
            (ft = R[11]),
            (h = R[12]),
            (f = R[13]),
            (m = R[14]),
            (T = Io(Mt, vt)),
            (x = T * Hs),
            T &&
              ((B = Math.cos(-T)),
              (X = Math.sin(-T)),
              (V = q * B + Lt * X),
              (Q = tt * B + J * X),
              (st = Mt * B + vt * X),
              (Lt = q * -X + Lt * B),
              (J = tt * -X + J * B),
              (vt = Mt * -X + vt * B),
              (ft = zt * -X + ft * B),
              (q = V),
              (tt = Q),
              (Mt = st)),
            (T = Io(-it, vt)),
            (b = T * Hs),
            T &&
              ((B = Math.cos(-T)),
              (X = Math.sin(-T)),
              (V = H * B - Lt * X),
              (Q = O * B - J * X),
              (st = it * B - vt * X),
              (ft = W * X + ft * B),
              (H = V),
              (O = Q),
              (it = st)),
            (T = Io(O, H)),
            (v = T * Hs),
            T &&
              ((B = Math.cos(T)),
              (X = Math.sin(T)),
              (V = H * B + O * X),
              (Q = q * B + tt * X),
              (O = O * B - H * X),
              (tt = tt * B - q * X),
              (H = V),
              (q = Q)),
            x &&
              Math.abs(x) + Math.abs(v) > 359.9 &&
              ((x = v = 0), (b = 180 - b)),
            (g = sn(Math.sqrt(H * H + O * O + it * it))),
            (p = sn(Math.sqrt(tt * tt + Mt * Mt))),
            (T = Io(q, tt)),
            (_ = Math.abs(T) > 2e-4 ? T * Hs : 0),
            (E = ft ? 1 / (ft < 0 ? -ft : ft) : 0)),
        n.svg &&
          ((V = t.getAttribute("transform")),
          (n.forceCSS = t.setAttribute("transform", "") || !S0(Lr(t, wn))),
          V && t.setAttribute("transform", V))),
      Math.abs(_) > 90 &&
        Math.abs(_) < 270 &&
        (r
          ? ((g *= -1), (_ += v <= 0 ? 180 : -180), (v += v <= 0 ? 180 : -180))
          : ((p *= -1), (_ += _ <= 0 ? 180 : -180))),
      (n.x =
        h -
        ((n.xPercent =
          h &&
          (n.xPercent ||
            (Math.round(t.offsetWidth / 2) === Math.round(-h) ? -50 : 0)))
          ? (t.offsetWidth * n.xPercent) / 100
          : 0) +
        o),
      (n.y =
        f -
        ((n.yPercent =
          f &&
          (n.yPercent ||
            (Math.round(t.offsetHeight / 2) === Math.round(-f) ? -50 : 0)))
          ? (t.offsetHeight * n.yPercent) / 100
          : 0) +
        o),
      (n.z = m + o),
      (n.scaleX = sn(g)),
      (n.scaleY = sn(p)),
      (n.rotation = sn(v) + l),
      (n.rotationX = sn(x) + l),
      (n.rotationY = sn(b) + l),
      (n.skewX = _ + l),
      (n.skewY = y + l),
      (n.transformPerspective = E + o),
      (n.zOrigin = parseFloat(u.split(" ")[2]) || 0) && (i[is] = kc(u)),
      (n.xOffset = n.yOffset = 0),
      (n.force3D = Zn.force3D),
      (n.renderTransform = n.svg ? $A : g0 ? E0 : JA),
      (n.uncache = 0),
      n
    );
  },
  kc = function (t) {
    return (t = t.split(" "))[0] + " " + t[1];
  },
  qf = function (t, e, n) {
    var i = fi(e);
    return sn(parseFloat(e) + parseFloat(ss(t, "x", n + "px", i))) + i;
  },
  JA = function (t, e) {
    (e.z = "0px"),
      (e.rotationY = e.rotationX = "0deg"),
      (e.force3D = 0),
      E0(t, e);
  },
  Vs = "0deg",
  nl = "0px",
  Ws = ") ",
  E0 = function (t, e) {
    var n = e || this,
      i = n.xPercent,
      r = n.yPercent,
      o = n.x,
      l = n.y,
      u = n.z,
      h = n.rotation,
      f = n.rotationY,
      m = n.rotationX,
      g = n.skewX,
      p = n.skewY,
      v = n.scaleX,
      x = n.scaleY,
      b = n.transformPerspective,
      _ = n.force3D,
      y = n.target,
      E = n.zOrigin,
      M = "",
      A = (_ === "auto" && t && t !== 1) || _ === !0;
    if (E && (m !== Vs || f !== Vs)) {
      var R = parseFloat(f) * Po,
        T = Math.sin(R),
        B = Math.cos(R),
        X;
      (R = parseFloat(m) * Po),
        (X = Math.cos(R)),
        (o = qf(y, o, T * X * -E)),
        (l = qf(y, l, -Math.sin(R) * -E)),
        (u = qf(y, u, B * X * -E + E));
    }
    b !== nl && (M += "perspective(" + b + Ws),
      (i || r) && (M += "translate(" + i + "%, " + r + "%) "),
      (A || o !== nl || l !== nl || u !== nl) &&
        (M +=
          u !== nl || A
            ? "translate3d(" + o + ", " + l + ", " + u + ") "
            : "translate(" + o + ", " + l + Ws),
      h !== Vs && (M += "rotate(" + h + Ws),
      f !== Vs && (M += "rotateY(" + f + Ws),
      m !== Vs && (M += "rotateX(" + m + Ws),
      (g !== Vs || p !== Vs) && (M += "skew(" + g + ", " + p + Ws),
      (v !== 1 || x !== 1) && (M += "scale(" + v + ", " + x + Ws),
      (y.style[wn] = M || "translate(0, 0)");
  },
  $A = function (t, e) {
    var n = e || this,
      i = n.xPercent,
      r = n.yPercent,
      o = n.x,
      l = n.y,
      u = n.rotation,
      h = n.skewX,
      f = n.skewY,
      m = n.scaleX,
      g = n.scaleY,
      p = n.target,
      v = n.xOrigin,
      x = n.yOrigin,
      b = n.xOffset,
      _ = n.yOffset,
      y = n.forceCSS,
      E = parseFloat(o),
      M = parseFloat(l),
      A,
      R,
      T,
      B,
      X;
    (u = parseFloat(u)),
      (h = parseFloat(h)),
      (f = parseFloat(f)),
      f && ((f = parseFloat(f)), (h += f), (u += f)),
      u || h
        ? ((u *= Po),
          (h *= Po),
          (A = Math.cos(u) * m),
          (R = Math.sin(u) * m),
          (T = Math.sin(u - h) * -g),
          (B = Math.cos(u - h) * g),
          h &&
            ((f *= Po),
            (X = Math.tan(h - f)),
            (X = Math.sqrt(1 + X * X)),
            (T *= X),
            (B *= X),
            f &&
              ((X = Math.tan(f)),
              (X = Math.sqrt(1 + X * X)),
              (A *= X),
              (R *= X))),
          (A = sn(A)),
          (R = sn(R)),
          (T = sn(T)),
          (B = sn(B)))
        : ((A = m), (B = g), (R = T = 0)),
      ((E && !~(o + "").indexOf("px")) || (M && !~(l + "").indexOf("px"))) &&
        ((E = ss(p, "x", o, "px")), (M = ss(p, "y", l, "px"))),
      (v || x || b || _) &&
        ((E = sn(E + v - (v * A + x * T) + b)),
        (M = sn(M + x - (v * R + x * B) + _))),
      (i || r) &&
        ((X = p.getBBox()),
        (E = sn(E + (i / 100) * X.width)),
        (M = sn(M + (r / 100) * X.height))),
      (X =
        "matrix(" + A + "," + R + "," + T + "," + B + "," + E + "," + M + ")"),
      p.setAttribute("transform", X),
      y && (p.style[wn] = X);
  },
  KA = function (t, e, n, i, r, o) {
    var l = 360,
      u = yn(r),
      h = parseFloat(r) * (u && ~r.indexOf("rad") ? Hs : 1),
      f = o ? h * o : h - i,
      m = i + f + "deg",
      g,
      p;
    return (
      u &&
        ((g = r.split("_")[1]),
        g === "short" && ((f %= l), f !== f % (l / 2) && (f += f < 0 ? l : -l)),
        g === "cw" && f < 0
          ? (f = ((f + l * h0) % l) - ~~(f / l) * l)
          : g === "ccw" && f > 0 && (f = ((f - l * h0) % l) - ~~(f / l) * l)),
      (t._pt = p = new $n(t._pt, e, n, i, f, zA)),
      (p.e = m),
      (p.u = "deg"),
      t._props.push(n),
      p
    );
  },
  A0 = function (t, e) {
    for (var n in e) t[n] = e[n];
    return t;
  },
  QA = function (t, e, n) {
    var i = A0({}, n._gsap),
      r = "perspective,force3D,transformOrigin,svgOrigin",
      o = n.style,
      l,
      u,
      h,
      f,
      m,
      g,
      p,
      v;
    i.svg
      ? ((h = n.getAttribute("transform")),
        n.setAttribute("transform", ""),
        (o[wn] = e),
        (l = el(n, 1)),
        Qa(n, wn),
        n.setAttribute("transform", h))
      : ((h = getComputedStyle(n)[wn]),
        (o[wn] = e),
        (l = el(n, 1)),
        (o[wn] = h));
    for (u in es)
      (h = i[u]),
        (f = l[u]),
        h !== f &&
          r.indexOf(u) < 0 &&
          ((p = fi(h)),
          (v = fi(f)),
          (m = p !== v ? ss(n, u, h, v) : parseFloat(h)),
          (g = parseFloat(f)),
          (t._pt = new $n(t._pt, l, u, m, g - m, d0)),
          (t._pt.u = v || 0),
          t._props.push(u));
    A0(l, i);
  };
hi("padding,margin,Width,Radius", function (a, t) {
  var e = "Top",
    n = "Right",
    i = "Bottom",
    r = "Left",
    o = (t < 3 ? [e, n, i, r] : [e + r, e + n, i + n, i + r]).map(function (l) {
      return t < 2 ? a + l : "border" + l + a;
    });
  Uc[t > 1 ? "border" + a : a] = function (l, u, h, f, m) {
    var g, p;
    if (arguments.length < 4)
      return (
        (g = o.map(function (v) {
          return Fo(l, v, h);
        })),
        (p = g.join(" ")),
        p.split(g[0]).length === 5 ? g[0] : p
      );
    (g = (f + "").split(" ")),
      (p = {}),
      o.forEach(function (v, x) {
        return (p[v] = g[x] = g[x] || g[((x - 1) / 2) | 0]);
      }),
      l.init(u, p, m);
  };
});
var L0 = {
  name: "css",
  register: Vf,
  targetTest: function (t) {
    return t.style && t.nodeType;
  },
  init: function (t, e, n, i, r) {
    var o = this._props,
      l = t.style,
      u = n.vars.startAt,
      h,
      f,
      m,
      g,
      p,
      v,
      x,
      b,
      _,
      y,
      E,
      M,
      A,
      R,
      T;
    Gf || Vf();
    for (x in e)
      if (x !== "autoRound" && ((f = e[x]), !(ui[x] && i0(x, e, n, i, t, r)))) {
        if (
          ((p = typeof f),
          (v = Uc[x]),
          p === "function" && ((f = f.call(n, i, t, r)), (p = typeof f)),
          p === "string" && ~f.indexOf("random(") && (f = Za(f)),
          v)
        )
          v(this, t, x, f, n) && (T = 1);
        else if (x.substr(0, 2) === "--")
          (h = (getComputedStyle(t).getPropertyValue(x) + "").trim()),
            (f += ""),
            (Kr.lastIndex = 0),
            Kr.test(h) || ((b = fi(h)), (_ = fi(f))),
            _ ? b !== _ && (h = ss(t, x, h, _) + _) : b && (f += b),
            this.add(l, "setProperty", h, f, i, r, 0, 0, x),
            o.push(x);
        else if (p !== "undefined") {
          if (
            (u && x in u
              ? ((h = typeof u[x] == "function" ? u[x].call(n, i, t, r) : u[x]),
                x in Zn.units && !fi(h) && (h += Zn.units[x]),
                yn(h) && ~h.indexOf("random(") && (h = Za(h)),
                (h + "").charAt(1) === "=" && (h = Fo(t, x)))
              : (h = Fo(t, x)),
            (g = parseFloat(h)),
            (y =
              p === "string" && f.charAt(1) === "=" ? +(f.charAt(0) + "1") : 0),
            y && (f = f.substr(2)),
            (m = parseFloat(f)),
            x in ns &&
              (x === "autoAlpha" &&
                (g === 1 && Fo(t, "visibility") === "hidden" && m && (g = 0),
                rs(
                  this,
                  l,
                  "visibility",
                  g ? "inherit" : "hidden",
                  m ? "inherit" : "hidden",
                  !m
                )),
              x !== "scale" &&
                x !== "transform" &&
                ((x = ns[x]), ~x.indexOf(",") && (x = x.split(",")[0]))),
            (E = x in es),
            E)
          ) {
            if (
              (M ||
                ((A = t._gsap),
                (A.renderTransform && !e.parseTransform) ||
                  el(t, e.parseTransform),
                (R = e.smoothOrigin !== !1 && A.smooth),
                (M = this._pt =
                  new $n(this._pt, l, wn, 0, 1, A.renderTransform, A, 0, -1)),
                (M.dep = 1)),
              x === "scale")
            )
              (this._pt = new $n(
                this._pt,
                A,
                "scaleY",
                A.scaleY,
                (y ? y * m : m - A.scaleY) || 0
              )),
                o.push("scaleY", x),
                (x += "X");
            else if (x === "transformOrigin") {
              (f = ZA(f)),
                A.svg
                  ? Yf(t, f, 0, R, 0, this)
                  : ((_ = parseFloat(f.split(" ")[2]) || 0),
                    _ !== A.zOrigin && rs(this, A, "zOrigin", A.zOrigin, _),
                    rs(this, l, x, kc(h), kc(f)));
              continue;
            } else if (x === "svgOrigin") {
              Yf(t, f, 1, R, 0, this);
              continue;
            } else if (x in M0) {
              KA(this, A, x, g, f, y);
              continue;
            } else if (x === "smoothOrigin") {
              rs(this, A, "smooth", A.smooth, f);
              continue;
            } else if (x === "force3D") {
              A[x] = f;
              continue;
            } else if (x === "transform") {
              QA(this, f, t);
              continue;
            }
          } else x in l || (x = Do(x) || x);
          if (E || ((m || m === 0) && (g || g === 0) && !BA.test(f) && x in l))
            (b = (h + "").substr((g + "").length)),
              m || (m = 0),
              (_ = fi(f) || (x in Zn.units ? Zn.units[x] : b)),
              b !== _ && (g = ss(t, x, h, _)),
              (this._pt = new $n(
                this._pt,
                E ? A : l,
                x,
                g,
                y ? y * m : m - g,
                !E && (_ === "px" || x === "zIndex") && e.autoRound !== !1
                  ? kA
                  : d0
              )),
              (this._pt.u = _ || 0),
              b !== _ && _ !== "%" && ((this._pt.b = h), (this._pt.r = UA));
          else if (x in l) qA.call(this, t, x, h, f);
          else if (x in t) this.add(t, x, h || t[x], f, i, r);
          else {
            Mf(x, f);
            continue;
          }
          o.push(x);
        }
      }
    T && l0(this);
  },
  get: Fo,
  aliases: ns,
  getSetter: function (t, e, n) {
    var i = ns[e];
    return (
      i && i.indexOf(",") < 0 && (e = i),
      e in es && e !== is && (t._gsap.x || Fo(t, "x"))
        ? n && u0 === n
          ? e === "scale"
            ? WA
            : VA
          : (u0 = n || {}) && (e === "scale" ? XA : YA)
        : t.style && !vf(t.style[e])
        ? GA
        : ~e.indexOf("-")
        ? HA
        : zf(t, e)
    );
  },
  core: { _removeProperty: Qa, _getMatrix: Xf },
};
nr.utils.checkPrefix = Do;
(function (a, t, e, n) {
  var i = hi(a + "," + t + "," + e, function (r) {
    es[r] = 1;
  });
  hi(t, function (r) {
    (Zn.units[r] = "deg"), (M0[r] = 1);
  }),
    (ns[i[13]] = a + "," + t),
    hi(n, function (r) {
      var o = r.split(":");
      ns[o[1]] = i[o[0]];
    });
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
);
hi(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (a) {
    Zn.units[a] = "px";
  }
);
nr.registerPlugin(L0);
var tL = nr.registerPlugin(L0) || nr;
tL.core.Tween;
/*!
 * ScrollTrigger 3.8.0
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var re,
  Oo,
  Ue,
  Ln,
  Cr,
  tn,
  C0,
  Zf,
  R0,
  jf,
  il,
  Gc,
  Hc,
  Jf,
  Nn,
  Vc,
  $f,
  Bn,
  P0,
  I0,
  No,
  D0,
  Kf,
  F0,
  Qf,
  rl = 1,
  Xs = [],
  Ys = [],
  os = Date.now,
  td = os(),
  Ii = 0,
  O0 = 1,
  Wc = function (t) {
    return t;
  },
  ir = function (t) {
    return il(t)[0] || (Hi(t) ? console.warn("Element not found:", t) : null);
  },
  N0 = function (t) {
    return Math.round(t * 1e5) / 1e5 || 0;
  },
  B0 = function () {
    return typeof window != "undefined";
  },
  z0 = function () {
    return re || (B0() && (re = window.gsap) && re.registerPlugin && re);
  },
  Bo = function (t) {
    return !!~C0.indexOf(t);
  },
  qs = function (t, e) {
    return ~Xs.indexOf(t) && Xs[Xs.indexOf(t) + 1][e];
  },
  Xc = function (t, e) {
    var n = e.s,
      i = e.sc,
      r = Ys.indexOf(t),
      o = i === Un.sc ? 1 : 2;
    return (
      !~r && (r = Ys.push(t) - 1),
      Ys[r + o] ||
        (Ys[r + o] =
          qs(t, n) ||
          (Bo(t)
            ? i
            : function (l) {
                return arguments.length ? (t[n] = l) : t[n];
              }))
    );
  },
  U0 = function (t) {
    return (
      qs(t, "getBoundingClientRect") ||
      (Bo(t)
        ? function () {
            return (lu.width = Ue.innerWidth), (lu.height = Ue.innerHeight), lu;
          }
        : function () {
            return Pr(t);
          })
    );
  },
  eL = function (t, e, n) {
    var i = n.d,
      r = n.d2,
      o = n.a;
    return (o = qs(t, "getBoundingClientRect"))
      ? function () {
          return o()[i];
        }
      : function () {
          return (e ? Ue["inner" + r] : t["client" + r]) || 0;
        };
  },
  nL = function (t, e) {
    return !e || ~Xs.indexOf(t)
      ? U0(t)
      : function () {
          return lu;
        };
  },
  ed = function (t, e) {
    var n = e.s,
      i = e.d2,
      r = e.d,
      o = e.a;
    return (n = "scroll" + i) && (o = qs(t, n))
      ? o() - U0(t)()[r]
      : Bo(t)
      ? (tn[n] || Cr[n]) -
        (Ue["inner" + i] || Cr["client" + i] || tn["client" + i])
      : t[n] - t["offset" + i];
  },
  nd = function (t, e) {
    for (var n = 0; n < No.length; n += 3)
      (!e || ~e.indexOf(No[n + 1])) && t(No[n], No[n + 1], No[n + 2]);
  },
  Hi = function (t) {
    return typeof t == "string";
  },
  rr = function (t) {
    return typeof t == "function";
  },
  sl = function (t) {
    return typeof t == "number";
  },
  id = function (t) {
    return typeof t == "object";
  },
  Yc = function (t) {
    return rr(t) && t();
  },
  k0 = function (t, e) {
    return function () {
      var n = Yc(t),
        i = Yc(e);
      return function () {
        Yc(n), Yc(i);
      };
    };
  },
  ol = function (t, e, n) {
    return t && t.progress(e ? 0 : 1) && n && t.pause();
  },
  rd = function (t, e) {
    var n = e(t);
    n && n.totalTime && (t.callbackAnimation = n);
  },
  zo = Math.abs,
  qc = "scrollLeft",
  Zc = "scrollTop",
  sd = "left",
  od = "top",
  jc = "right",
  Jc = "bottom",
  as = "width",
  ls = "height",
  Uo = "Right",
  ko = "Left",
  Go = "Top",
  Ho = "Bottom",
  on = "padding",
  Di = "margin",
  Zs = "Width",
  $c = "Height",
  zn = "px",
  Vi = {
    s: qc,
    p: sd,
    p2: ko,
    os: jc,
    os2: Uo,
    d: as,
    d2: Zs,
    a: "x",
    sc: function (t) {
      return arguments.length
        ? Ue.scrollTo(t, Un.sc())
        : Ue.pageXOffset || Ln[qc] || Cr[qc] || tn[qc] || 0;
    },
  },
  Un = {
    s: Zc,
    p: od,
    p2: Go,
    os: Jc,
    os2: Ho,
    d: ls,
    d2: $c,
    a: "y",
    op: Vi,
    sc: function (t) {
      return arguments.length
        ? Ue.scrollTo(Vi.sc(), t)
        : Ue.pageYOffset || Ln[Zc] || Cr[Zc] || tn[Zc] || 0;
    },
  },
  Rr = function (t) {
    return Ue.getComputedStyle(t);
  },
  iL = function (t) {
    var e = Rr(t).position;
    t.style.position = e === "absolute" || e === "fixed" ? e : "relative";
  },
  G0 = function (t, e) {
    for (var n in e) n in t || (t[n] = e[n]);
    return t;
  },
  Pr = function (t, e) {
    var n =
        e &&
        Rr(t)[$f] !== "matrix(1, 0, 0, 1, 0, 0)" &&
        re
          .to(t, {
            x: 0,
            y: 0,
            xPercent: 0,
            yPercent: 0,
            rotation: 0,
            rotationX: 0,
            rotationY: 0,
            scale: 1,
            skewX: 0,
            skewY: 0,
          })
          .progress(1),
      i = t.getBoundingClientRect();
    return n && n.progress(0).kill(), i;
  },
  ad = function (t, e) {
    var n = e.d2;
    return t["offset" + n] || t["client" + n] || 0;
  },
  H0 = function (t) {
    var e = [],
      n = t.labels,
      i = t.duration(),
      r;
    for (r in n) e.push(n[r] / i);
    return e;
  },
  rL = function (t) {
    return function (e) {
      return re.utils.snap(H0(t), e);
    };
  },
  ld = function (t) {
    var e = re.utils.snap(t),
      n =
        Array.isArray(t) &&
        t.slice(0).sort(function (i, r) {
          return i - r;
        });
    return n
      ? function (i, r) {
          var o;
          if (!r) return e(i);
          if (r > 0) {
            for (i -= 1e-4, o = 0; o < n.length; o++)
              if (n[o] >= i) return n[o];
            return n[o - 1];
          } else
            for (o = n.length, i += 1e-4; o--; ) if (n[o] <= i) return n[o];
          return n[0];
        }
      : function (i, r) {
          var o = e(i);
          return !r || Math.abs(o - i) < 0.001 || o - i < 0 == r < 0
            ? o
            : e(r < 0 ? i - t : i + t);
        };
  },
  sL = function (t) {
    return function (e, n) {
      return ld(H0(t))(e, n.direction);
    };
  },
  V0 = function (t, e, n, i) {
    return n.split(",").forEach(function (r) {
      return t(e, r, i);
    });
  },
  Kn = function (t, e, n) {
    return t.addEventListener(e, n, { passive: !0 });
  },
  al = function (t, e, n) {
    return t.removeEventListener(e, n);
  },
  W0 = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal",
  },
  cd = { toggleActions: "play", anticipatePin: 0 },
  Kc = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
  Qc = function (t, e) {
    if (Hi(t)) {
      var n = t.indexOf("="),
        i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
      ~n && (t.indexOf("%") > n && (i *= e / 100), (t = t.substr(0, n - 1))),
        (t =
          i +
          (t in Kc
            ? Kc[t] * e
            : ~t.indexOf("%")
            ? (parseFloat(t) * e) / 100
            : parseFloat(t) || 0));
    }
    return t;
  },
  tu = function (t, e, n, i, r, o, l, u) {
    var h = r.startColor,
      f = r.endColor,
      m = r.fontSize,
      g = r.indent,
      p = r.fontWeight,
      v = Ln.createElement("div"),
      x = Bo(n) || qs(n, "pinType") === "fixed",
      b = t.indexOf("scroller") !== -1,
      _ = x ? tn : n,
      y = t.indexOf("start") !== -1,
      E = y ? h : f,
      M =
        "border-color:" +
        E +
        ";font-size:" +
        m +
        ";color:" +
        E +
        ";font-weight:" +
        p +
        ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return (
      (M += "position:" + ((b || u) && x ? "fixed;" : "absolute;")),
      (b || u || !x) &&
        (M += (i === Un ? jc : Jc) + ":" + (o + parseFloat(g)) + "px;"),
      l &&
        (M +=
          "box-sizing:border-box;text-align:left;width:" +
          l.offsetWidth +
          "px;"),
      (v._isStart = y),
      v.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")),
      (v.style.cssText = M),
      (v.innerText = e || e === 0 ? t + "-" + e : t),
      _.children[0] ? _.insertBefore(v, _.children[0]) : _.appendChild(v),
      (v._offset = v["offset" + i.op.d2]),
      eu(v, 0, i, y),
      v
    );
  },
  eu = function (t, e, n, i) {
    var r = { display: "block" },
      o = n[i ? "os2" : "p2"],
      l = n[i ? "p2" : "os2"];
    (t._isFlipped = i),
      (r[n.a + "Percent"] = i ? -100 : 0),
      (r[n.a] = i ? "1px" : 0),
      (r["border" + o + Zs] = 1),
      (r["border" + l + Zs] = 0),
      (r[n.p] = e + "px"),
      re.set(t, r);
  },
  we = [],
  ud = {},
  X0 = function () {
    return os() - Ii > 20 && su();
  },
  nu = function () {
    var t = os();
    Ii !== t ? (su(), Ii || Wo("scrollStart"), (Ii = t)) : jf || (jf = R0(su));
  },
  ll = function () {
    return !Nn && !F0 && !Ln.fullscreenElement && Zf.restart(!0);
  },
  cl = {},
  oL = [],
  $e = [],
  Vo,
  Y0,
  q0 = function (t) {
    var e = re.ticker.frame,
      n = [],
      i = 0,
      r;
    if (Y0 !== e || rl) {
      for (iu(); i < $e.length; i += 4)
        (r = Ue.matchMedia($e[i]).matches),
          r !== $e[i + 3] &&
            (($e[i + 3] = r),
            r ? n.push(i) : iu(1, $e[i]) || (rr($e[i + 2]) && $e[i + 2]()));
      for (j0(), i = 0; i < n.length; i++)
        (r = n[i]), (Vo = $e[r]), ($e[r + 2] = $e[r + 1](t));
      (Vo = 0), Oo && Xo(0, 1), (Y0 = e), Wo("matchMedia");
    }
  },
  Z0 = function a() {
    return al(ke, "scrollEnd", a) || Xo(!0);
  },
  Wo = function (t) {
    return (
      (cl[t] &&
        cl[t].map(function (e) {
          return e();
        })) ||
      oL
    );
  },
  Fi = [],
  j0 = function (t) {
    for (var e = 0; e < Fi.length; e += 5)
      (!t || Fi[e + 4] === t) &&
        ((Fi[e].style.cssText = Fi[e + 1]),
        Fi[e].getBBox && Fi[e].setAttribute("transform", Fi[e + 2] || ""),
        (Fi[e + 3].uncache = 1));
  },
  iu = function (t, e) {
    var n;
    for (Bn = 0; Bn < we.length; Bn++)
      (n = we[Bn]), (!e || n.media === e) && (t ? n.kill(1) : n.revert());
    e && j0(e), e || Wo("revert");
  },
  J0 = function () {
    return Ys.forEach(function (t) {
      return typeof t == "function" && (t.rec = 0);
    });
  },
  hd,
  Xo = function (t, e) {
    if (Ii && !t) {
      Kn(ke, "scrollEnd", Z0);
      return;
    }
    hd = !0;
    var n = Wo("refreshInit");
    D0 && ke.sort(),
      e || iu(),
      we.forEach(function (i) {
        return i.refresh();
      }),
      n.forEach(function (i) {
        return i && i.render && i.render(-1);
      }),
      J0(),
      Zf.pause(),
      (hd = !1),
      Wo("refresh");
  },
  $0 = 0,
  ru = 1,
  su = function () {
    if (!hd) {
      var t = we.length,
        e = os(),
        n = e - td >= 50,
        i = t && we[0].scroll();
      if (
        ((ru = $0 > i ? -1 : 1),
        ($0 = i),
        n &&
          (Ii && !Vc && e - Ii > 200 && ((Ii = 0), Wo("scrollEnd")),
          (Hc = td),
          (td = e)),
        ru < 0)
      ) {
        for (Bn = t; Bn-- > 0; ) we[Bn] && we[Bn].update(0, n);
        ru = 1;
      } else for (Bn = 0; Bn < t; Bn++) we[Bn] && we[Bn].update(0, n);
      jf = 0;
    }
  },
  fd = [
    sd,
    od,
    Jc,
    jc,
    Di + Ho,
    Di + Uo,
    Di + Go,
    Di + ko,
    "display",
    "flexShrink",
    "float",
    "zIndex",
    "grid-column-start",
    "grid-column-end",
    "grid-row-start",
    "grid-row-end",
    "grid-area",
    "justify-self",
    "align-self",
    "place-self",
  ],
  ou = fd.concat([
    as,
    ls,
    "boxSizing",
    "max" + Zs,
    "max" + $c,
    "position",
    Di,
    on,
    on + Go,
    on + Uo,
    on + Ho,
    on + ko,
  ]),
  aL = function (t, e, n) {
    ul(n);
    var i = t._gsap;
    if (i.spacerIsNative) ul(i.spacerState);
    else if (t.parentNode === e) {
      var r = e.parentNode;
      r && (r.insertBefore(t, e), r.removeChild(e));
    }
  },
  dd = function (t, e, n, i) {
    if (t.parentNode !== e) {
      for (var r = fd.length, o = e.style, l = t.style, u; r--; )
        (u = fd[r]), (o[u] = n[u]);
      (o.position = n.position === "absolute" ? "absolute" : "relative"),
        n.display === "inline" && (o.display = "inline-block"),
        (l[Jc] = l[jc] = "auto"),
        (o.overflow = "visible"),
        (o.boxSizing = "border-box"),
        (o[as] = ad(t, Vi) + zn),
        (o[ls] = ad(t, Un) + zn),
        (o[on] = l[Di] = l[od] = l[sd] = "0"),
        ul(i),
        (l[as] = l["max" + Zs] = n[as]),
        (l[ls] = l["max" + $c] = n[ls]),
        (l[on] = n[on]),
        t.parentNode.insertBefore(e, t),
        e.appendChild(t);
    }
  },
  lL = /([A-Z])/g,
  ul = function (t) {
    if (t) {
      var e = t.t.style,
        n = t.length,
        i = 0,
        r,
        o;
      for ((t.t._gsap || re.core.getCache(t.t)).uncache = 1; i < n; i += 2)
        (o = t[i + 1]),
          (r = t[i]),
          o
            ? (e[r] = o)
            : e[r] && e.removeProperty(r.replace(lL, "-$1").toLowerCase());
    }
  },
  au = function (t) {
    for (var e = ou.length, n = t.style, i = [], r = 0; r < e; r++)
      i.push(ou[r], n[ou[r]]);
    return (i.t = t), i;
  },
  cL = function (t, e, n) {
    for (var i = [], r = t.length, o = n ? 8 : 0, l; o < r; o += 2)
      (l = t[o]), i.push(l, l in e ? e[l] : t[o + 1]);
    return (i.t = t.t), i;
  },
  lu = { left: 0, top: 0 },
  K0 = function (t, e, n, i, r, o, l, u, h, f, m, g, p) {
    rr(t) && (t = t(u)),
      Hi(t) &&
        t.substr(0, 3) === "max" &&
        (t = g + (t.charAt(4) === "=" ? Qc("0" + t.substr(3), n) : 0));
    var v = p ? p.time() : 0,
      x,
      b,
      _;
    if ((p && p.seek(0), sl(t))) l && eu(l, n, i, !0);
    else {
      rr(e) && (e = e(u));
      var y = t.split(" "),
        E,
        M,
        A,
        R;
      (_ = ir(e) || tn),
        (E = Pr(_) || {}),
        (!E || (!E.left && !E.top)) &&
          Rr(_).display === "none" &&
          ((R = _.style.display),
          (_.style.display = "block"),
          (E = Pr(_)),
          R ? (_.style.display = R) : _.style.removeProperty("display")),
        (M = Qc(y[0], E[i.d])),
        (A = Qc(y[1] || "0", n)),
        (t = E[i.p] - h[i.p] - f + M + r - A),
        l && eu(l, A, i, n - A < 20 || (l._isStart && A > 20)),
        (n -= n - A);
    }
    if (o) {
      var T = t + n,
        B = o._isStart;
      (x = "scroll" + i.d2),
        eu(
          o,
          T,
          i,
          (B && T > 20) ||
            (!B && (m ? Math.max(tn[x], Cr[x]) : o.parentNode[x]) <= T + 1)
        ),
        m &&
          ((h = Pr(l)),
          m && (o.style[i.op.p] = h[i.op.p] - i.op.m - o._offset + zn));
    }
    return (
      p &&
        _ &&
        ((x = Pr(_)),
        p.seek(g),
        (b = Pr(_)),
        (p._caScrollDist = x[i.p] - b[i.p]),
        (t = (t / p._caScrollDist) * g)),
      p && p.seek(v),
      p ? t : Math.round(t)
    );
  },
  uL = /(?:webkit|moz|length|cssText|inset)/i,
  Q0 = function (t, e, n, i) {
    if (t.parentNode !== e) {
      var r = t.style,
        o,
        l;
      if (e === tn) {
        (t._stOrig = r.cssText), (l = Rr(t));
        for (o in l)
          !+o &&
            !uL.test(o) &&
            l[o] &&
            typeof r[o] == "string" &&
            o !== "0" &&
            (r[o] = l[o]);
        (r.top = n), (r.left = i);
      } else r.cssText = t._stOrig;
      (re.core.getCache(t).uncache = 1), e.appendChild(t);
    }
  },
  tv = function (t, e) {
    var n = Xc(t, e),
      i = "_scroll" + e.p2,
      r,
      o,
      l = function u(h, f, m, g, p) {
        var v = u.tween,
          x = f.onComplete,
          b = {};
        return (
          v && v.kill(),
          (r = Math.round(m)),
          (f[i] = h),
          (f.modifiers = b),
          (b[i] = function (_) {
            return (
              (_ = N0(n())),
              _ !== r && _ !== o && Math.abs(_ - r) > 2
                ? (v.kill(), (u.tween = 0))
                : (_ = m + g * v.ratio + p * v.ratio * v.ratio),
              (o = r),
              (r = N0(_))
            );
          }),
          (f.onComplete = function () {
            (u.tween = 0), x && x.call(v);
          }),
          (v = u.tween = re.to(t, f)),
          v
        );
      };
    return (
      (t[i] = n),
      t.addEventListener(
        "wheel",
        function () {
          return l.tween && l.tween.kill() && (l.tween = 0);
        },
        { passive: !0 }
      ),
      l
    );
  };
Vi.op = Un;
var ke = (function () {
  function a(e, n) {
    Oo ||
      a.register(re) ||
      console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
      this.init(e, n);
  }
  var t = a.prototype;
  return (
    (t.init = function (n, i) {
      if (((this.progress = this.start = 0), this.vars && this.kill(1), !O0)) {
        this.update = this.refresh = this.kill = Wc;
        return;
      }
      n = G0(Hi(n) || sl(n) || n.nodeType ? { trigger: n } : n, cd);
      var r = n,
        o = r.onUpdate,
        l = r.toggleClass,
        u = r.id,
        h = r.onToggle,
        f = r.onRefresh,
        m = r.scrub,
        g = r.trigger,
        p = r.pin,
        v = r.pinSpacing,
        x = r.invalidateOnRefresh,
        b = r.anticipatePin,
        _ = r.onScrubComplete,
        y = r.onSnapComplete,
        E = r.once,
        M = r.snap,
        A = r.pinReparent,
        R = r.pinSpacer,
        T = r.containerAnimation,
        B = r.fastScrollEnd,
        X = r.preventOverlaps,
        H =
          n.horizontal || (n.containerAnimation && n.horizontal !== !1)
            ? Vi
            : Un,
        O = !m && m !== 0,
        it = ir(n.scroller || Ue),
        W = re.core.getCache(it),
        q = Bo(it),
        tt =
          ("pinType" in n ? n.pinType : qs(it, "pinType") || (q && "fixed")) ===
          "fixed",
        V = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack],
        Q = O && n.toggleActions.split(" "),
        st = "markers" in n ? n.markers : cd.markers,
        Lt = q ? 0 : parseFloat(Rr(it)["border" + H.p2 + Zs]) || 0,
        J = this,
        vt =
          n.onRefreshInit &&
          function () {
            return n.onRefreshInit(J);
          },
        zt = eL(it, q, H),
        ft = nL(it, q),
        Mt = 0,
        Tt = Xc(it, H),
        z,
        F,
        U,
        et,
        dt,
        gt,
        j,
        ot,
        ct,
        St,
        xt,
        I,
        P,
        lt,
        yt,
        wt,
        At,
        Ht,
        Ut,
        Vt,
        Nt,
        Y,
        Ct,
        _t,
        Bt,
        Ft,
        ee,
        Be,
        He,
        Te,
        ve,
        je,
        rn,
        hr,
        Zi,
        fr,
        Hn;
      if (
        ((J.media = Vo),
        (b *= 45),
        (J.scroller = it),
        (J.scroll = T ? T.time.bind(T) : Tt),
        (et = Tt()),
        (J.vars = n),
        (i = i || n.animation),
        "refreshPriority" in n && (D0 = 1),
        (W.tweenScroll = W.tweenScroll || {
          top: tv(it, Un),
          left: tv(it, Vi),
        }),
        (J.tweenTo = z = W.tweenScroll[H.p]),
        i &&
          ((i.vars.lazy = !1),
          i._initted ||
            (i.vars.immediateRender !== !1 &&
              n.immediateRender !== !1 &&
              i.render(0, !0, !0)),
          (J.animation = i.pause()),
          (i.scrollTrigger = J),
          (ve = sl(m) && m),
          ve &&
            (Te = re.to(i, {
              ease: "power3",
              duration: ve,
              onComplete: function () {
                return _ && _(J);
              },
            })),
          (Be = 0),
          u || (u = i.vars.id)),
        we.push(J),
        M &&
          ((!id(M) || M.push) && (M = { snapTo: M }),
          "scrollBehavior" in tn.style &&
            re.set(q ? [tn, Cr] : it, { scrollBehavior: "auto" }),
          (U = rr(M.snapTo)
            ? M.snapTo
            : M.snapTo === "labels"
            ? rL(i)
            : M.snapTo === "labelsDirectional"
            ? sL(i)
            : M.directional !== !1
            ? function (me, fe) {
                return ld(M.snapTo)(me, fe.direction);
              }
            : re.utils.snap(M.snapTo)),
          (je = M.duration || { min: 0.1, max: 2 }),
          (je = id(je) ? Gc(je.min, je.max) : Gc(je, je)),
          (rn = re
            .delayedCall(M.delay || ve / 2 || 0.1, function () {
              if (Math.abs(J.getVelocity()) < 10 && !Vc && Mt !== Tt()) {
                var me = i && !O ? i.totalProgress() : J.progress,
                  fe = ((me - He) / (os() - Hc)) * 1e3 || 0,
                  ge = re.utils.clamp(
                    -J.progress,
                    1 - J.progress,
                    (zo(fe / 2) * fe) / 0.185
                  ),
                  de = J.progress + (M.inertia === !1 ? 0 : ge),
                  _n = Gc(0, 1, U(de, J)),
                  Kt = Tt(),
                  Ce = Math.round(gt + _n * P),
                  Re = M,
                  D = Re.onStart,
                  K = Re.onInterrupt,
                  at = Re.onComplete,
                  nt = z.tween;
                if (Kt <= j && Kt >= gt && Ce !== Kt) {
                  if (nt && !nt._initted && nt.data <= zo(Ce - Kt)) return;
                  M.inertia === !1 && (ge = _n - J.progress),
                    z(
                      Ce,
                      {
                        duration: je(
                          zo(
                            (Math.max(zo(de - me), zo(_n - me)) * 0.185) /
                              fe /
                              0.05 || 0
                          )
                        ),
                        ease: M.ease || "power3",
                        data: zo(Ce - Kt),
                        onInterrupt: function () {
                          return rn.restart(!0) && K && K(J);
                        },
                        onComplete: function () {
                          (Mt = Tt()),
                            (Be = He =
                              i && !O ? i.totalProgress() : J.progress),
                            y && y(J),
                            at && at(J);
                        },
                      },
                      Kt,
                      ge * P,
                      Ce - Kt - ge * P
                    ),
                    D && D(J, z.tween);
                }
              } else J.isActive && rn.restart(!0);
            })
            .pause())),
        u && (ud[u] = J),
        (g = J.trigger = ir(g || p)),
        (p = p === !0 ? g : ir(p)),
        Hi(l) && (l = { targets: g, className: l }),
        p &&
          (v === !1 ||
            v === Di ||
            (v = !v && Rr(p.parentNode).display === "flex" ? !1 : on),
          (J.pin = p),
          n.force3D !== !1 && re.set(p, { force3D: !0 }),
          (F = re.core.getCache(p)),
          F.spacer
            ? (lt = F.pinState)
            : (R &&
                ((R = ir(R)),
                R && !R.nodeType && (R = R.current || R.nativeElement),
                (F.spacerIsNative = !!R),
                R && (F.spacerState = au(R))),
              (F.spacer = At = R || Ln.createElement("div")),
              At.classList.add("pin-spacer"),
              u && At.classList.add("pin-spacer-" + u),
              (F.pinState = lt = au(p))),
          (J.spacer = At = F.spacer),
          (ee = Rr(p)),
          (Ct = ee[v + H.os2]),
          (Ut = re.getProperty(p)),
          (Vt = re.quickSetter(p, H.a, zn)),
          dd(p, At, ee),
          (wt = au(p))),
        st &&
          ((I = id(st) ? G0(st, W0) : W0),
          (St = tu("scroller-start", u, it, H, I, 0)),
          (xt = tu("scroller-end", u, it, H, I, 0, St)),
          (Ht = St["offset" + H.op.d2]),
          (ot = tu("start", u, it, H, I, Ht, 0, T)),
          (ct = tu("end", u, it, H, I, Ht, 0, T)),
          T && (Hn = re.quickSetter([ot, ct], H.a, zn)),
          !tt &&
            !(Xs.length && qs(it, "fixedMarkers") === !0) &&
            (iL(q ? tn : it),
            re.set([St, xt], { force3D: !0 }),
            (Bt = re.quickSetter(St, H.a, zn)),
            (Ft = re.quickSetter(xt, H.a, zn)))),
        T)
      ) {
        var As = T.vars.onUpdate,
          ro = T.vars.onUpdateParams;
        T.eventCallback("onUpdate", function () {
          J.update(0, 0, 1), As && As.apply(ro || []);
        });
      }
      (J.previous = function () {
        return we[we.indexOf(J) - 1];
      }),
        (J.next = function () {
          return we[we.indexOf(J) + 1];
        }),
        (J.revert = function (me) {
          var fe = me !== !1 || !J.enabled,
            ge = Nn;
          fe !== J.isReverted &&
            (fe &&
              (J.scroll.rec || (J.scroll.rec = Tt()),
              (Zi = Math.max(Tt(), J.scroll.rec || 0)),
              (hr = J.progress),
              (fr = i && i.progress())),
            ot &&
              [ot, ct, St, xt].forEach(function (de) {
                return (de.style.display = fe ? "none" : "block");
              }),
            fe && (Nn = 1),
            J.update(fe),
            (Nn = ge),
            p &&
              (fe
                ? aL(p, At, lt)
                : (!A || !J.isActive) && dd(p, At, Rr(p), _t)),
            (J.isReverted = fe));
        }),
        (J.refresh = function (me, fe) {
          if (!((Nn || !J.enabled) && !fe)) {
            if (p && me && Ii) {
              Kn(a, "scrollEnd", Z0);
              return;
            }
            (Nn = 1),
              Te && Te.pause(),
              x && i && i.progress(0).invalidate(),
              J.isReverted || J.revert();
            for (
              var ge = zt(),
                de = ft(),
                _n = T ? T.duration() : ed(it, H),
                Kt = 0,
                Ce = 0,
                Re = n.end,
                D = n.endTrigger || g,
                K = n.start || (n.start === 0 || !g ? 0 : p ? "0 0" : "0 100%"),
                at = n.pinnedContainer && ir(n.pinnedContainer),
                nt = (g && Math.max(0, we.indexOf(J))) || 0,
                ut = nt,
                Ot,
                It,
                Gt,
                $t,
                Yt,
                Wt,
                Qt,
                Ee,
                _i,
                oe;
              ut--;

            )
              (Wt = we[ut]),
                Wt.end || Wt.refresh(0, 1) || (Nn = 1),
                (Qt = Wt.pin),
                Qt &&
                  (Qt === g || Qt === p) &&
                  !Wt.isReverted &&
                  (oe || (oe = []), oe.unshift(Wt), Wt.revert());
            for (
              rr(K) && (K = K(J)),
                gt =
                  K0(K, g, ge, H, Tt(), ot, St, J, de, Lt, tt, _n, T) ||
                  (p ? -0.001 : 0),
                rr(Re) && (Re = Re(J)),
                Hi(Re) &&
                  !Re.indexOf("+=") &&
                  (~Re.indexOf(" ")
                    ? (Re = (Hi(K) ? K.split(" ")[0] : "") + Re)
                    : ((Kt = Qc(Re.substr(2), ge)),
                      (Re = Hi(K) ? K : gt + Kt),
                      (D = g))),
                j =
                  Math.max(
                    gt,
                    K0(
                      Re || (D ? "100% 0" : _n),
                      D,
                      ge,
                      H,
                      Tt() + Kt,
                      ct,
                      xt,
                      J,
                      de,
                      Lt,
                      tt,
                      _n,
                      T
                    )
                  ) || -0.001,
                P = j - gt || ((gt -= 0.01) && 0.001),
                Kt = 0,
                ut = nt;
              ut--;

            )
              (Wt = we[ut]),
                (Qt = Wt.pin),
                Qt &&
                  Wt.start - Wt._pinPush < gt &&
                  !T &&
                  ((Ot = Wt.end - Wt.start),
                  (Qt === g || Qt === at) && !sl(K) && (Kt += Ot),
                  Qt === p && (Ce += Ot));
            if (
              ((gt += Kt),
              (j += Kt),
              (J._pinPush = Ce),
              ot &&
                Kt &&
                ((Ot = {}),
                (Ot[H.a] = "+=" + Kt),
                at && (Ot[H.p] = "-=" + Tt()),
                re.set([ot, ct], Ot)),
              p)
            )
              (Ot = Rr(p)),
                ($t = H === Un),
                (Gt = Tt()),
                (Nt = parseFloat(Ut(H.a)) + Ce),
                !_n &&
                  j > 1 &&
                  ((q ? tn : it).style["overflow-" + H.a] = "scroll"),
                dd(p, At, Ot),
                (wt = au(p)),
                (It = Pr(p, !0)),
                (Ee = tt && Xc(it, $t ? Vi : Un)()),
                v &&
                  ((_t = [v + H.os2, P + Ce + zn]),
                  (_t.t = At),
                  (ut = v === on ? ad(p, H) + P + Ce : 0),
                  ut && _t.push(H.d, ut + zn),
                  ul(_t),
                  tt && Tt(Zi)),
                tt &&
                  ((Yt = {
                    top: It.top + ($t ? Gt - gt : Ee) + zn,
                    left: It.left + ($t ? Ee : Gt - gt) + zn,
                    boxSizing: "border-box",
                    position: "fixed",
                  }),
                  (Yt[as] = Yt["max" + Zs] = Math.ceil(It.width) + zn),
                  (Yt[ls] = Yt["max" + $c] = Math.ceil(It.height) + zn),
                  (Yt[Di] =
                    Yt[Di + Go] =
                    Yt[Di + Uo] =
                    Yt[Di + Ho] =
                    Yt[Di + ko] =
                      "0"),
                  (Yt[on] = Ot[on]),
                  (Yt[on + Go] = Ot[on + Go]),
                  (Yt[on + Uo] = Ot[on + Uo]),
                  (Yt[on + Ho] = Ot[on + Ho]),
                  (Yt[on + ko] = Ot[on + ko]),
                  (yt = cL(lt, Yt, A))),
                i
                  ? ((_i = i._initted),
                    Kf(1),
                    i.render(i.duration(), !0, !0),
                    (Y = Ut(H.a) - Nt + P + Ce),
                    P !== Y && yt.splice(yt.length - 2, 2),
                    i.render(0, !0, !0),
                    _i || i.invalidate(),
                    Kf(0))
                  : (Y = P);
            else if (g && Tt() && !T)
              for (It = g.parentNode; It && It !== tn; )
                It._pinOffset && ((gt -= It._pinOffset), (j -= It._pinOffset)),
                  (It = It.parentNode);
            oe &&
              oe.forEach(function (dr) {
                return dr.revert(!1);
              }),
              (J.start = gt),
              (J.end = j),
              (et = dt = Tt()),
              T || (et < Zi && Tt(Zi), (J.scroll.rec = 0)),
              J.revert(!1),
              (Nn = 0),
              i &&
                O &&
                i._initted &&
                i.progress() !== fr &&
                i.progress(fr, !0).render(i.time(), !0, !0),
              hr !== J.progress &&
                (i && !O && i.totalProgress(hr, !0),
                (J.progress = hr),
                J.update(0, 0, 1)),
              p && v && (At._pinOffset = Math.round(J.progress * Y)),
              f && f(J);
          }
        }),
        (J.getVelocity = function () {
          return ((Tt() - dt) / (os() - Hc)) * 1e3 || 0;
        }),
        (J.endAnimation = function () {
          ol(J.callbackAnimation),
            i &&
              (Te
                ? Te.progress(1)
                : i.paused()
                ? O || ol(i, J.direction < 0, 1)
                : ol(i, i.reversed()));
        }),
        (J.getTrailing = function (me) {
          var fe = we.indexOf(J),
            ge = J.direction > 0 ? we.slice(0, fe).reverse() : we.slice(fe + 1);
          return Hi(me)
            ? ge.filter(function (de) {
                return de.vars.preventOverlaps === me;
              })
            : ge;
        }),
        (J.update = function (me, fe, ge) {
          if (!(T && !ge && !me)) {
            var de = J.scroll(),
              _n = me ? 0 : (de - gt) / P,
              Kt = _n < 0 ? 0 : _n > 1 ? 1 : _n || 0,
              Ce = J.progress,
              Re,
              D,
              K,
              at,
              nt,
              ut,
              Ot,
              It;
            if (
              (fe &&
                ((dt = et),
                (et = T ? Tt() : de),
                M && ((He = Be), (Be = i && !O ? i.totalProgress() : Kt))),
              b &&
                !Kt &&
                p &&
                !Nn &&
                !rl &&
                Ii &&
                gt < de + ((de - dt) / (os() - Hc)) * b &&
                (Kt = 1e-4),
              Kt !== Ce && J.enabled)
            ) {
              if (
                ((Re = J.isActive = !!Kt && Kt < 1),
                (D = !!Ce && Ce < 1),
                (ut = Re !== D),
                (nt = ut || !!Kt != !!Ce),
                (J.direction = Kt > Ce ? 1 : -1),
                (J.progress = Kt),
                nt &&
                  !Nn &&
                  ((K = Kt && !Ce ? 0 : Kt === 1 ? 1 : Ce === 1 ? 2 : 3),
                  O &&
                    ((at = (!ut && Q[K + 1] !== "none" && Q[K + 1]) || Q[K]),
                    (It =
                      i && (at === "complete" || at === "reset" || at in i)))),
                X &&
                  ut &&
                  (It || m || !i) &&
                  (rr(X)
                    ? X(J)
                    : J.getTrailing(X).forEach(function (Wt) {
                        return Wt.endAnimation();
                      })),
                O ||
                  (Te && !Nn && !rl
                    ? ((Te.vars.totalProgress = Kt), Te.invalidate().restart())
                    : i && i.totalProgress(Kt, !!Nn)),
                p)
              ) {
                if ((me && v && (At.style[v + H.os2] = Ct), !tt))
                  Vt(Nt + Y * Kt);
                else if (nt) {
                  if (
                    ((Ot = !me && Kt > Ce && j + 1 > de && de + 1 >= ed(it, H)),
                    A)
                  )
                    if (!me && (Re || Ot)) {
                      var Gt = Pr(p, !0),
                        $t = de - gt;
                      Q0(
                        p,
                        tn,
                        Gt.top + (H === Un ? $t : 0) + zn,
                        Gt.left + (H === Un ? 0 : $t) + zn
                      );
                    } else Q0(p, At);
                  ul(Re || Ot ? yt : wt),
                    (Y !== P && Kt < 1 && Re) ||
                      Vt(Nt + (Kt === 1 && !Ot ? Y : 0));
                }
              }
              M && !z.tween && !Nn && !rl && rn.restart(!0),
                l &&
                  (ut || (E && Kt && (Kt < 1 || !Qf))) &&
                  il(l.targets).forEach(function (Wt) {
                    return Wt.classList[Re || E ? "add" : "remove"](
                      l.className
                    );
                  }),
                o && !O && !me && o(J),
                nt && !Nn
                  ? (O &&
                      (It &&
                        (at === "complete"
                          ? i.pause().totalProgress(1)
                          : at === "reset"
                          ? i.restart(!0).pause()
                          : at === "restart"
                          ? i.restart(!0)
                          : i[at]()),
                      o && o(J)),
                    (ut || !Qf) &&
                      (h && ut && rd(J, h),
                      V[K] && rd(J, V[K]),
                      E && (Kt === 1 ? J.kill(!1, 1) : (V[K] = 0)),
                      ut || ((K = Kt === 1 ? 1 : 3), V[K] && rd(J, V[K]))),
                    B &&
                      !Re &&
                      Math.abs(J.getVelocity()) > (sl(B) ? B : 2500) &&
                      (ol(J.callbackAnimation),
                      Te ? Te.progress(1) : ol(i, !Kt, 1)))
                  : O && o && !Nn && o(J);
            }
            if (Ft) {
              var Yt = T ? (de / T.duration()) * (T._caScrollDist || 0) : de;
              Bt(Yt + (St._isFlipped ? 1 : 0)), Ft(Yt);
            }
            Hn && Hn((-de / T.duration()) * (T._caScrollDist || 0));
          }
        }),
        (J.enable = function (me, fe) {
          J.enabled ||
            ((J.enabled = !0),
            Kn(it, "resize", ll),
            Kn(it, "scroll", nu),
            vt && Kn(a, "refreshInit", vt),
            me !== !1 && ((J.progress = hr = 0), (et = dt = Mt = Tt())),
            fe !== !1 && J.refresh());
        }),
        (J.getTween = function (me) {
          return me && z ? z.tween : Te;
        }),
        (J.disable = function (me, fe) {
          if (
            J.enabled &&
            (me !== !1 && J.revert(),
            (J.enabled = J.isActive = !1),
            fe || (Te && Te.pause()),
            (Zi = 0),
            F && (F.uncache = 1),
            vt && al(a, "refreshInit", vt),
            rn && (rn.pause(), z.tween && z.tween.kill() && (z.tween = 0)),
            !q)
          ) {
            for (var ge = we.length; ge--; )
              if (we[ge].scroller === it && we[ge] !== J) return;
            al(it, "resize", ll), al(it, "scroll", nu);
          }
        }),
        (J.kill = function (me, fe) {
          J.disable(me, fe), Te && Te.kill(), u && delete ud[u];
          var ge = we.indexOf(J);
          we.splice(ge, 1),
            ge === Bn && ru > 0 && Bn--,
            (ge = 0),
            we.forEach(function (de) {
              return de.scroller === J.scroller && (ge = 1);
            }),
            ge || (J.scroll.rec = 0),
            i && ((i.scrollTrigger = null), me && i.render(-1), fe || i.kill()),
            ot &&
              [ot, ct, St, xt].forEach(function (de) {
                return de.parentNode && de.parentNode.removeChild(de);
              }),
            p &&
              (F && (F.uncache = 1),
              (ge = 0),
              we.forEach(function (de) {
                return de.pin === p && ge++;
              }),
              ge || (F.spacer = 0));
        }),
        J.enable(!1, !1),
        !i || !i.add || P
          ? J.refresh()
          : re.delayedCall(0.01, function () {
              return gt || j || J.refresh();
            }) &&
            (P = 0.01) &&
            (gt = j = 0);
    }),
    (a.register = function (n) {
      if (
        !Oo &&
        ((re = n || z0()),
        B0() &&
          window.document &&
          ((Ue = window),
          (Ln = document),
          (Cr = Ln.documentElement),
          (tn = Ln.body)),
        re &&
          ((il = re.utils.toArray),
          (Gc = re.utils.clamp),
          (Kf = re.core.suppressOverwrites || Wc),
          re.core.globals("ScrollTrigger", a),
          tn))
      ) {
        (R0 =
          Ue.requestAnimationFrame ||
          function (l) {
            return setTimeout(l, 16);
          }),
          Kn(Ue, "wheel", nu),
          (C0 = [Ue, Ln, Cr, tn]),
          Kn(Ln, "scroll", nu);
        var i = tn.style,
          r = i.borderTopStyle,
          o;
        (i.borderTopStyle = "solid"),
          (o = Pr(tn)),
          (Un.m = Math.round(o.top + Un.sc()) || 0),
          (Vi.m = Math.round(o.left + Vi.sc()) || 0),
          r ? (i.borderTopStyle = r) : i.removeProperty("border-top-style"),
          (Jf = setInterval(X0, 200)),
          re.delayedCall(0.5, function () {
            return (rl = 0);
          }),
          Kn(Ln, "touchcancel", Wc),
          Kn(tn, "touchstart", Wc),
          V0(Kn, Ln, "pointerdown,touchstart,mousedown", function () {
            return (Vc = 1);
          }),
          V0(Kn, Ln, "pointerup,touchend,mouseup", function () {
            return (Vc = 0);
          }),
          ($f = re.utils.checkPrefix("transform")),
          ou.push($f),
          (Oo = os()),
          (Zf = re.delayedCall(0.2, Xo).pause()),
          (No = [
            Ln,
            "visibilitychange",
            function () {
              var l = Ue.innerWidth,
                u = Ue.innerHeight;
              Ln.hidden ? ((P0 = l), (I0 = u)) : (P0 !== l || I0 !== u) && ll();
            },
            Ln,
            "DOMContentLoaded",
            Xo,
            Ue,
            "load",
            function () {
              return Ii || Xo();
            },
            Ue,
            "resize",
            ll,
          ]),
          nd(Kn);
      }
      return Oo;
    }),
    (a.defaults = function (n) {
      for (var i in n) cd[i] = n[i];
    }),
    (a.kill = function () {
      (O0 = 0),
        we.slice(0).forEach(function (n) {
          return n.kill(1);
        });
    }),
    (a.config = function (n) {
      "limitCallbacks" in n && (Qf = !!n.limitCallbacks);
      var i = n.syncInterval;
      (i && clearInterval(Jf)) || ((Jf = i) && setInterval(X0, i)),
        "autoRefreshEvents" in n &&
          (nd(al) || nd(Kn, n.autoRefreshEvents || "none"),
          (F0 = (n.autoRefreshEvents + "").indexOf("resize") === -1));
    }),
    (a.scrollerProxy = function (n, i) {
      var r = ir(n),
        o = Ys.indexOf(r),
        l = Bo(r);
      ~o && Ys.splice(o, l ? 6 : 2),
        l ? Xs.unshift(Ue, i, tn, i, Cr, i) : Xs.unshift(r, i);
    }),
    (a.matchMedia = function (n) {
      var i, r, o, l, u;
      for (r in n)
        (o = $e.indexOf(r)),
          (l = n[r]),
          (Vo = r),
          r === "all"
            ? l()
            : ((i = Ue.matchMedia(r)),
              i &&
                (i.matches && (u = l()),
                ~o
                  ? (($e[o + 1] = k0($e[o + 1], l)),
                    ($e[o + 2] = k0($e[o + 2], u)))
                  : ((o = $e.length),
                    $e.push(r, l, u),
                    i.addListener
                      ? i.addListener(q0)
                      : i.addEventListener("change", q0)),
                ($e[o + 3] = i.matches))),
          (Vo = 0);
      return $e;
    }),
    (a.clearMatchMedia = function (n) {
      n || ($e.length = 0), (n = $e.indexOf(n)), n >= 0 && $e.splice(n, 4);
    }),
    (a.isInViewport = function (n, i, r) {
      var o = (Hi(n) ? ir(n) : n).getBoundingClientRect(),
        l = o[r ? as : ls] * i || 0;
      return r
        ? o.right - l > 0 && o.left + l < Ue.innerWidth
        : o.bottom - l > 0 && o.top + l < Ue.innerHeight;
    }),
    (a.positionInViewport = function (n, i, r) {
      Hi(n) && (n = ir(n));
      var o = n.getBoundingClientRect(),
        l = o[r ? as : ls],
        u =
          i == null
            ? l / 2
            : i in Kc
            ? Kc[i] * l
            : ~i.indexOf("%")
            ? (parseFloat(i) * l) / 100
            : parseFloat(i) || 0;
      return r ? (o.left + u) / Ue.innerWidth : (o.top + u) / Ue.innerHeight;
    }),
    a
  );
})();
ke.version = "3.8.0";
ke.saveStyles = function (a) {
  return a
    ? il(a).forEach(function (t) {
        if (t && t.style) {
          var e = Fi.indexOf(t);
          e >= 0 && Fi.splice(e, 5),
            Fi.push(
              t,
              t.style.cssText,
              t.getBBox && t.getAttribute("transform"),
              re.core.getCache(t),
              Vo
            );
        }
      })
    : Fi;
};
ke.revert = function (a, t) {
  return iu(!a, t);
};
ke.create = function (a, t) {
  return new ke(a, t);
};
ke.refresh = function (a) {
  return a ? ll() : (Oo || ke.register()) && Xo(!0);
};
ke.update = su;
ke.clearScrollMemory = J0;
ke.maxScroll = function (a, t) {
  return ed(a, t ? Vi : Un);
};
ke.getScrollFunc = function (a, t) {
  return Xc(ir(a), t ? Vi : Un);
};
ke.getById = function (a) {
  return ud[a];
};
ke.getAll = function () {
  return we.slice(0);
};
ke.isScrolling = function () {
  return !!Ii;
};
ke.snapDirectional = ld;
ke.addEventListener = function (a, t) {
  var e = cl[a] || (cl[a] = []);
  ~e.indexOf(t) || e.push(t);
};
ke.removeEventListener = function (a, t) {
  var e = cl[a],
    n = e && e.indexOf(t);
  n >= 0 && e.splice(n, 1);
};
ke.batch = function (a, t) {
  var e = [],
    n = {},
    i = t.interval || 0.016,
    r = t.batchMax || 1e9,
    o = function (h, f) {
      var m = [],
        g = [],
        p = re
          .delayedCall(i, function () {
            f(m, g), (m = []), (g = []);
          })
          .pause();
      return function (v) {
        m.length || p.restart(!0),
          m.push(v.trigger),
          g.push(v),
          r <= m.length && p.progress(1);
      };
    },
    l;
  for (l in t)
    n[l] =
      l.substr(0, 2) === "on" && rr(t[l]) && l !== "onRefreshInit"
        ? o(l, t[l])
        : t[l];
  return (
    rr(r) &&
      ((r = r()),
      Kn(ke, "refresh", function () {
        return (r = t.batchMax());
      })),
    il(a).forEach(function (u) {
      var h = {};
      for (l in n) h[l] = n[l];
      (h.trigger = u), e.push(ke.create(h));
    }),
    e
  );
};
ke.sort = function (a) {
  return we.sort(
    a ||
      function (t, e) {
        return (
          (t.vars.refreshPriority || 0) * -1e6 +
          t.start -
          (e.start + (e.vars.refreshPriority || 0) * -1e6)
        );
      }
  );
};
z0() && re.registerPlugin(ke);
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const ev = "134",
  hL = 0,
  nv = 1,
  fL = 2,
  iv = 1,
  dL = 2,
  hl = 3,
  fl = 0,
  un = 1,
  Yo = 2,
  rv = 1,
  cs = 0,
  dl = 1,
  sv = 2,
  ov = 3,
  av = 4,
  pL = 5,
  qo = 100,
  mL = 101,
  gL = 102,
  lv = 103,
  cv = 104,
  _L = 200,
  vL = 201,
  xL = 202,
  yL = 203,
  uv = 204,
  hv = 205,
  wL = 206,
  bL = 207,
  ML = 208,
  SL = 209,
  TL = 210,
  EL = 0,
  AL = 1,
  LL = 2,
  pd = 3,
  CL = 4,
  RL = 5,
  PL = 6,
  IL = 7,
  cu = 0,
  DL = 1,
  FL = 2,
  js = 0,
  OL = 1,
  NL = 2,
  BL = 3,
  zL = 4,
  UL = 5,
  fv = 300,
  pl = 301,
  ml = 302,
  md = 303,
  gd = 304,
  uu = 306,
  _d = 307,
  vd = 1e3,
  di = 1001,
  xd = 1002,
  mn = 1003,
  dv = 1004,
  pv = 1005,
  Oi = 1006,
  kL = 1007,
  hu = 1008,
  us = 1009,
  GL = 1010,
  HL = 1011,
  fu = 1012,
  VL = 1013,
  du = 1014,
  hs = 1015,
  Zo = 1016,
  WL = 1017,
  XL = 1018,
  YL = 1019,
  gl = 1020,
  qL = 1021,
  jo = 1022,
  kn = 1023,
  ZL = 1024,
  jL = 1025,
  JL = kn,
  Jo = 1026,
  _l = 1027,
  $L = 1028,
  KL = 1029,
  QL = 1030,
  tC = 1031,
  eC = 1032,
  nC = 1033,
  mv = 33776,
  gv = 33777,
  _v = 33778,
  vv = 33779,
  xv = 35840,
  yv = 35841,
  wv = 35842,
  bv = 35843,
  iC = 36196,
  Mv = 37492,
  Sv = 37496,
  rC = 37808,
  sC = 37809,
  oC = 37810,
  aC = 37811,
  lC = 37812,
  cC = 37813,
  uC = 37814,
  hC = 37815,
  fC = 37816,
  dC = 37817,
  pC = 37818,
  mC = 37819,
  gC = 37820,
  _C = 37821,
  vC = 36492,
  xC = 37840,
  yC = 37841,
  wC = 37842,
  bC = 37843,
  MC = 37844,
  SC = 37845,
  TC = 37846,
  EC = 37847,
  AC = 37848,
  LC = 37849,
  CC = 37850,
  RC = 37851,
  PC = 37852,
  IC = 37853,
  DC = 2200,
  FC = 2201,
  OC = 2202,
  pu = 2300,
  mu = 2301,
  yd = 2302,
  $o = 2400,
  Ko = 2401,
  gu = 2402,
  wd = 2500,
  Tv = 2501,
  NC = 0,
  Cn = 3e3,
  Js = 3001,
  bd = 3007,
  Md = 3002,
  BC = 3003,
  Ev = 3004,
  Av = 3005,
  Lv = 3006,
  zC = 3200,
  UC = 3201,
  Qo = 0,
  kC = 1,
  Sd = 7680,
  GC = 519,
  vl = 35044,
  _u = 35048,
  Cv = "300 es";
class $s {
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  }
  hasEventListener(t, e) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[t] !== void 0 && n[t].indexOf(e) !== -1;
  }
  removeEventListener(t, e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[t];
    if (i !== void 0) {
      const r = i.indexOf(e);
      r !== -1 && i.splice(r, 1);
    }
  }
  dispatchEvent(t) {
    if (this._listeners === void 0) return;
    const n = this._listeners[t.type];
    if (n !== void 0) {
      t.target = this;
      const i = n.slice(0);
      for (let r = 0, o = i.length; r < o; r++) i[r].call(this, t);
      t.target = null;
    }
  }
}
const Td = Math.PI / 180,
  Ed = 180 / Math.PI,
  bn = [];
for (let a = 0; a < 256; a++) bn[a] = (a < 16 ? "0" : "") + a.toString(16);
const HC = typeof crypto != "undefined" && "randomUUID" in crypto;
function sr() {
  if (HC) return crypto.randomUUID().toUpperCase();
  const a = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    bn[a & 255] +
    bn[(a >> 8) & 255] +
    bn[(a >> 16) & 255] +
    bn[(a >> 24) & 255] +
    "-" +
    bn[t & 255] +
    bn[(t >> 8) & 255] +
    "-" +
    bn[((t >> 16) & 15) | 64] +
    bn[(t >> 24) & 255] +
    "-" +
    bn[(e & 63) | 128] +
    bn[(e >> 8) & 255] +
    "-" +
    bn[(e >> 16) & 255] +
    bn[(e >> 24) & 255] +
    bn[n & 255] +
    bn[(n >> 8) & 255] +
    bn[(n >> 16) & 255] +
    bn[(n >> 24) & 255]
  ).toUpperCase();
}
function pi(a, t, e) {
  return Math.max(t, Math.min(e, a));
}
function VC(a, t) {
  return ((a % t) + t) % t;
}
function Ad(a, t, e) {
  return (1 - e) * a + e * t;
}
function Rv(a) {
  return (a & (a - 1)) == 0 && a !== 0;
}
function WC(a) {
  return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
}
class Et {
  constructor(t = 0, e = 0) {
    (this.x = t), (this.y = e);
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return (this.x = t), (this.y = e), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), this;
  }
  add(t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(t, e))
      : ((this.x += t.x), (this.y += t.y), this);
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), this;
  }
  addVectors(t, e) {
    return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), this;
  }
  sub(t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x), (this.y -= t.y), this);
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), this;
  }
  subVectors(t, e) {
    return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
  }
  multiply(t) {
    return (this.x *= t.x), (this.y *= t.y), this;
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), this;
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      i = t.elements;
    return (
      (this.x = i[0] * e + i[3] * n + i[6]),
      (this.y = i[1] * e + i[4] * n + i[7]),
      this
    );
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      this
    );
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(t, Math.min(e, n))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y;
    return e * e + n * n;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
    );
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), t;
  }
  fromBufferAttribute(t, e, n) {
    return (
      n !== void 0 &&
        console.warn(
          "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      this
    );
  }
  rotateAround(t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      r = this.x - t.x,
      o = this.y - t.y;
    return (this.x = r * n - o * i + t.x), (this.y = r * i + o * n + t.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
Et.prototype.isVector2 = !0;
class Mn {
  constructor() {
    (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
        );
  }
  set(t, e, n, i, r, o, l, u, h) {
    const f = this.elements;
    return (
      (f[0] = t),
      (f[1] = i),
      (f[2] = l),
      (f[3] = e),
      (f[4] = r),
      (f[5] = u),
      (f[6] = n),
      (f[7] = o),
      (f[8] = h),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(t) {
    const e = this.elements,
      n = t.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      this
    );
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrix3Column(this, 0),
      e.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return (
      this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    );
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      i = e.elements,
      r = this.elements,
      o = n[0],
      l = n[3],
      u = n[6],
      h = n[1],
      f = n[4],
      m = n[7],
      g = n[2],
      p = n[5],
      v = n[8],
      x = i[0],
      b = i[3],
      _ = i[6],
      y = i[1],
      E = i[4],
      M = i[7],
      A = i[2],
      R = i[5],
      T = i[8];
    return (
      (r[0] = o * x + l * y + u * A),
      (r[3] = o * b + l * E + u * R),
      (r[6] = o * _ + l * M + u * T),
      (r[1] = h * x + f * y + m * A),
      (r[4] = h * b + f * E + m * R),
      (r[7] = h * _ + f * M + m * T),
      (r[2] = g * x + p * y + v * A),
      (r[5] = g * b + p * E + v * R),
      (r[8] = g * _ + p * M + v * T),
      this
    );
  }
  multiplyScalar(t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[3] *= t),
      (e[6] *= t),
      (e[1] *= t),
      (e[4] *= t),
      (e[7] *= t),
      (e[2] *= t),
      (e[5] *= t),
      (e[8] *= t),
      this
    );
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      r = t[3],
      o = t[4],
      l = t[5],
      u = t[6],
      h = t[7],
      f = t[8];
    return (
      e * o * f - e * l * h - n * r * f + n * l * u + i * r * h - i * o * u
    );
  }
  invert() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      r = t[3],
      o = t[4],
      l = t[5],
      u = t[6],
      h = t[7],
      f = t[8],
      m = f * o - l * h,
      g = l * u - f * r,
      p = h * r - o * u,
      v = e * m + n * g + i * p;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / v;
    return (
      (t[0] = m * x),
      (t[1] = (i * h - f * n) * x),
      (t[2] = (l * n - i * o) * x),
      (t[3] = g * x),
      (t[4] = (f * e - i * u) * x),
      (t[5] = (i * r - l * e) * x),
      (t[6] = p * x),
      (t[7] = (n * u - h * e) * x),
      (t[8] = (o * e - n * r) * x),
      this
    );
  }
  transpose() {
    let t;
    const e = this.elements;
    return (
      (t = e[1]),
      (e[1] = e[3]),
      (e[3] = t),
      (t = e[2]),
      (e[2] = e[6]),
      (e[6] = t),
      (t = e[5]),
      (e[5] = e[7]),
      (e[7] = t),
      this
    );
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return (
      (t[0] = e[0]),
      (t[1] = e[3]),
      (t[2] = e[6]),
      (t[3] = e[1]),
      (t[4] = e[4]),
      (t[5] = e[7]),
      (t[6] = e[2]),
      (t[7] = e[5]),
      (t[8] = e[8]),
      this
    );
  }
  setUvTransform(t, e, n, i, r, o, l) {
    const u = Math.cos(r),
      h = Math.sin(r);
    return (
      this.set(
        n * u,
        n * h,
        -n * (u * o + h * l) + o + t,
        -i * h,
        i * u,
        -i * (-h * o + u * l) + l + e,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(t, e) {
    const n = this.elements;
    return (
      (n[0] *= t),
      (n[3] *= t),
      (n[6] *= t),
      (n[1] *= e),
      (n[4] *= e),
      (n[7] *= e),
      this
    );
  }
  rotate(t) {
    const e = Math.cos(t),
      n = Math.sin(t),
      i = this.elements,
      r = i[0],
      o = i[3],
      l = i[6],
      u = i[1],
      h = i[4],
      f = i[7];
    return (
      (i[0] = e * r + n * u),
      (i[3] = e * o + n * h),
      (i[6] = e * l + n * f),
      (i[1] = -n * r + e * u),
      (i[4] = -n * o + e * h),
      (i[7] = -n * l + e * f),
      this
    );
  }
  translate(t, e) {
    const n = this.elements;
    return (
      (n[0] += t * n[2]),
      (n[3] += t * n[5]),
      (n[6] += t * n[8]),
      (n[1] += e * n[2]),
      (n[4] += e * n[5]),
      (n[7] += e * n[8]),
      this
    );
  }
  equals(t) {
    const e = this.elements,
      n = t.elements;
    for (let i = 0; i < 9; i++) if (e[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.elements;
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      t
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
Mn.prototype.isMatrix3 = !0;
function Pv(a) {
  if (a.length === 0) return -1 / 0;
  let t = a[0];
  for (let e = 1, n = a.length; e < n; ++e) a[e] > t && (t = a[e]);
  return t;
}
function vu(a) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", a);
}
function Iv(a, t = 0) {
  let e = 3735928559 ^ t,
    n = 1103547991 ^ t;
  for (let i = 0, r; i < a.length; i++)
    (r = a.charCodeAt(i)),
      (e = Math.imul(e ^ r, 2654435761)),
      (n = Math.imul(n ^ r, 1597334677));
  return (
    (e =
      Math.imul(e ^ (e >>> 16), 2246822507) ^
      Math.imul(n ^ (n >>> 13), 3266489909)),
    (n =
      Math.imul(n ^ (n >>> 16), 2246822507) ^
      Math.imul(e ^ (e >>> 13), 3266489909)),
    4294967296 * (2097151 & n) + (e >>> 0)
  );
}
let ta;
class ea {
  static getDataURL(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement == "undefined")
      return t.src;
    let e;
    if (t instanceof HTMLCanvasElement) e = t;
    else {
      ta === void 0 && (ta = vu("canvas")),
        (ta.width = t.width),
        (ta.height = t.height);
      const n = ta.getContext("2d");
      t instanceof ImageData
        ? n.putImageData(t, 0, 0)
        : n.drawImage(t, 0, 0, t.width, t.height),
        (e = ta);
    }
    return e.width > 2048 || e.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          t
        ),
        e.toDataURL("image/jpeg", 0.6))
      : e.toDataURL("image/png");
  }
}
let XC = 0;
class Sn extends $s {
  constructor(
    t = Sn.DEFAULT_IMAGE,
    e = Sn.DEFAULT_MAPPING,
    n = di,
    i = di,
    r = Oi,
    o = hu,
    l = kn,
    u = us,
    h = 1,
    f = Cn
  ) {
    super();
    Object.defineProperty(this, "id", { value: XC++ }),
      (this.uuid = sr()),
      (this.name = ""),
      (this.image = t),
      (this.mipmaps = []),
      (this.mapping = e),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = r),
      (this.minFilter = o),
      (this.anisotropy = h),
      (this.format = l),
      (this.internalFormat = null),
      (this.type = u),
      (this.offset = new Et(0, 0)),
      (this.repeat = new Et(1, 1)),
      (this.center = new Et(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Mn()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = f),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1);
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.image = t.image),
      (this.mipmaps = t.mipmaps.slice(0)),
      (this.mapping = t.mapping),
      (this.wrapS = t.wrapS),
      (this.wrapT = t.wrapT),
      (this.magFilter = t.magFilter),
      (this.minFilter = t.minFilter),
      (this.anisotropy = t.anisotropy),
      (this.format = t.format),
      (this.internalFormat = t.internalFormat),
      (this.type = t.type),
      this.offset.copy(t.offset),
      this.repeat.copy(t.repeat),
      this.center.copy(t.center),
      (this.rotation = t.rotation),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this.matrix.copy(t.matrix),
      (this.generateMipmaps = t.generateMipmaps),
      (this.premultiplyAlpha = t.premultiplyAlpha),
      (this.flipY = t.flipY),
      (this.unpackAlignment = t.unpackAlignment),
      (this.encoding = t.encoding),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    );
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
    const n = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    if (this.image !== void 0) {
      const i = this.image;
      if (
        (i.uuid === void 0 && (i.uuid = sr()),
        !e && t.images[i.uuid] === void 0)
      ) {
        let r;
        if (Array.isArray(i)) {
          r = [];
          for (let o = 0, l = i.length; o < l; o++)
            i[o].isDataTexture ? r.push(Ld(i[o].image)) : r.push(Ld(i[o]));
        } else r = Ld(i);
        t.images[i.uuid] = { uuid: i.uuid, url: r };
      }
      n.image = i.uuid;
    }
    return (
      JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData),
      e || (t.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t) {
    if (this.mapping !== fv) return t;
    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
      switch (this.wrapS) {
        case vd:
          t.x = t.x - Math.floor(t.x);
          break;
        case di:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case xd:
          Math.abs(Math.floor(t.x) % 2) === 1
            ? (t.x = Math.ceil(t.x) - t.x)
            : (t.x = t.x - Math.floor(t.x));
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case vd:
          t.y = t.y - Math.floor(t.y);
          break;
        case di:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case xd:
          Math.abs(Math.floor(t.y) % 2) === 1
            ? (t.y = Math.ceil(t.y) - t.y)
            : (t.y = t.y - Math.floor(t.y));
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
}
Sn.DEFAULT_IMAGE = void 0;
Sn.DEFAULT_MAPPING = fv;
Sn.prototype.isTexture = !0;
function Ld(a) {
  return (typeof HTMLImageElement != "undefined" &&
    a instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement != "undefined" &&
      a instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap != "undefined" && a instanceof ImageBitmap)
    ? ea.getDataURL(a)
    : a.data
    ? {
        data: Array.prototype.slice.call(a.data),
        width: a.width,
        height: a.height,
        type: a.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
class Fe {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    (this.x = t), (this.y = e), (this.z = n), (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, n, i) {
    return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setZ(t) {
    return (this.z = t), this;
  }
  setW(t) {
    return (this.w = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return (
      (this.x = t.x),
      (this.y = t.y),
      (this.z = t.z),
      (this.w = t.w !== void 0 ? t.w : 1),
      this
    );
  }
  add(t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(t, e))
      : ((this.x += t.x),
        (this.y += t.y),
        (this.z += t.z),
        (this.w += t.w),
        this);
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x),
      (this.y = t.y + e.y),
      (this.z = t.z + e.z),
      (this.w = t.w + e.w),
      this
    );
  }
  addScaledVector(t, e) {
    return (
      (this.x += t.x * e),
      (this.y += t.y * e),
      (this.z += t.z * e),
      (this.w += t.w * e),
      this
    );
  }
  sub(t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x),
        (this.y -= t.y),
        (this.z -= t.z),
        (this.w -= t.w),
        this);
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x),
      (this.y = t.y - e.y),
      (this.z = t.z - e.z),
      (this.w = t.w - e.w),
      this
    );
  }
  multiply(t) {
    return (
      (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
    );
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = this.w,
      o = t.elements;
    return (
      (this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r),
      (this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r),
      (this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r),
      (this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r),
      this
    );
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return (
      e < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, n, i, r;
    const o = 0.01,
      l = 0.1,
      u = t.elements,
      h = u[0],
      f = u[4],
      m = u[8],
      g = u[1],
      p = u[5],
      v = u[9],
      x = u[2],
      b = u[6],
      _ = u[10];
    if (Math.abs(f - g) < o && Math.abs(m - x) < o && Math.abs(v - b) < o) {
      if (
        Math.abs(f + g) < l &&
        Math.abs(m + x) < l &&
        Math.abs(v + b) < l &&
        Math.abs(h + p + _ - 3) < l
      )
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const E = (h + 1) / 2,
        M = (p + 1) / 2,
        A = (_ + 1) / 2,
        R = (f + g) / 4,
        T = (m + x) / 4,
        B = (v + b) / 4;
      return (
        E > M && E > A
          ? E < o
            ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
            : ((n = Math.sqrt(E)), (i = R / n), (r = T / n))
          : M > A
          ? M < o
            ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
            : ((i = Math.sqrt(M)), (n = R / i), (r = B / i))
          : A < o
          ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
          : ((r = Math.sqrt(A)), (n = T / r), (i = B / r)),
        this.set(n, i, r, e),
        this
      );
    }
    let y = Math.sqrt(
      (b - v) * (b - v) + (m - x) * (m - x) + (g - f) * (g - f)
    );
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (b - v) / y),
      (this.y = (m - x) / y),
      (this.z = (g - f) / y),
      (this.w = Math.acos((h + p + _ - 1) / 2)),
      this
    );
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      (this.w = Math.min(this.w, t.w)),
      this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      (this.w = Math.max(this.w, t.w)),
      this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      (this.w = Math.max(t.w, Math.min(e.w, this.w))),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      (this.w = Math.max(t, Math.min(e, this.w))),
      this
    );
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(t, Math.min(e, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      (this.w += (t.w - this.w) * e),
      this
    );
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      (this.w = t.w + (e.w - t.w) * n),
      this
    );
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return (
      (this.x = t[e]),
      (this.y = t[e + 1]),
      (this.z = t[e + 2]),
      (this.w = t[e + 3]),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this.x),
      (t[e + 1] = this.y),
      (t[e + 2] = this.z),
      (t[e + 3] = this.w),
      t
    );
  }
  fromBufferAttribute(t, e, n) {
    return (
      n !== void 0 &&
        console.warn(
          "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      (this.w = t.getW(e)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
Fe.prototype.isVector4 = !0;
class or extends $s {
  constructor(t, e, n = {}) {
    super();
    (this.width = t),
      (this.height = e),
      (this.depth = 1),
      (this.scissor = new Fe(0, 0, t, e)),
      (this.scissorTest = !1),
      (this.viewport = new Fe(0, 0, t, e)),
      (this.texture = new Sn(
        void 0,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.encoding
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.image = { width: t, height: e, depth: 1 }),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.internalFormat =
        n.internalFormat !== void 0 ? n.internalFormat : null),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Oi),
      (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
      (this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
      (this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null);
  }
  setTexture(t) {
    (t.image = { width: this.width, height: this.height, depth: this.depth }),
      (this.texture = t);
  }
  setSize(t, e, n = 1) {
    (this.width !== t || this.height !== e || this.depth !== n) &&
      ((this.width = t),
      (this.height = e),
      (this.depth = n),
      (this.texture.image.width = t),
      (this.texture.image.height = e),
      (this.texture.image.depth = n),
      this.dispose()),
      this.viewport.set(0, 0, t, e),
      this.scissor.set(0, 0, t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (
      (this.width = t.width),
      (this.height = t.height),
      (this.depth = t.depth),
      this.viewport.copy(t.viewport),
      (this.texture = t.texture.clone()),
      (this.texture.image = s_({}, this.texture.image)),
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      (this.depthTexture = t.depthTexture),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
or.prototype.isWebGLRenderTarget = !0;
class YC extends or {
  constructor(t, e, n) {
    super(t, e);
    const i = this.texture;
    this.texture = [];
    for (let r = 0; r < n; r++) this.texture[r] = i.clone();
  }
  setSize(t, e, n = 1) {
    if (this.width !== t || this.height !== e || this.depth !== n) {
      (this.width = t), (this.height = e), (this.depth = n);
      for (let i = 0, r = this.texture.length; i < r; i++)
        (this.texture[i].image.width = t),
          (this.texture[i].image.height = e),
          (this.texture[i].image.depth = n);
      this.dispose();
    }
    return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this;
  }
  copy(t) {
    this.dispose(),
      (this.width = t.width),
      (this.height = t.height),
      (this.depth = t.depth),
      this.viewport.set(0, 0, this.width, this.height),
      this.scissor.set(0, 0, this.width, this.height),
      (this.depthBuffer = t.depthBuffer),
      (this.stencilBuffer = t.stencilBuffer),
      (this.depthTexture = t.depthTexture),
      (this.texture.length = 0);
    for (let e = 0, n = t.texture.length; e < n; e++)
      this.texture[e] = t.texture[e].clone();
    return this;
  }
}
YC.prototype.isWebGLMultipleRenderTargets = !0;
class Dv extends or {
  constructor(t, e, n) {
    super(t, e, n);
    this.samples = 4;
  }
  copy(t) {
    return super.copy.call(this, t), (this.samples = t.samples), this;
  }
}
Dv.prototype.isWebGLMultisampleRenderTarget = !0;
class Qn {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    (this._x = t), (this._y = e), (this._z = n), (this._w = i);
  }
  static slerp(t, e, n, i) {
    return (
      console.warn(
        "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
      ),
      n.slerpQuaternions(t, e, i)
    );
  }
  static slerpFlat(t, e, n, i, r, o, l) {
    let u = n[i + 0],
      h = n[i + 1],
      f = n[i + 2],
      m = n[i + 3];
    const g = r[o + 0],
      p = r[o + 1],
      v = r[o + 2],
      x = r[o + 3];
    if (l === 0) {
      (t[e + 0] = u), (t[e + 1] = h), (t[e + 2] = f), (t[e + 3] = m);
      return;
    }
    if (l === 1) {
      (t[e + 0] = g), (t[e + 1] = p), (t[e + 2] = v), (t[e + 3] = x);
      return;
    }
    if (m !== x || u !== g || h !== p || f !== v) {
      let b = 1 - l;
      const _ = u * g + h * p + f * v + m * x,
        y = _ >= 0 ? 1 : -1,
        E = 1 - _ * _;
      if (E > Number.EPSILON) {
        const A = Math.sqrt(E),
          R = Math.atan2(A, _ * y);
        (b = Math.sin(b * R) / A), (l = Math.sin(l * R) / A);
      }
      const M = l * y;
      if (
        ((u = u * b + g * M),
        (h = h * b + p * M),
        (f = f * b + v * M),
        (m = m * b + x * M),
        b === 1 - l)
      ) {
        const A = 1 / Math.sqrt(u * u + h * h + f * f + m * m);
        (u *= A), (h *= A), (f *= A), (m *= A);
      }
    }
    (t[e] = u), (t[e + 1] = h), (t[e + 2] = f), (t[e + 3] = m);
  }
  static multiplyQuaternionsFlat(t, e, n, i, r, o) {
    const l = n[i],
      u = n[i + 1],
      h = n[i + 2],
      f = n[i + 3],
      m = r[o],
      g = r[o + 1],
      p = r[o + 2],
      v = r[o + 3];
    return (
      (t[e] = l * v + f * m + u * p - h * g),
      (t[e + 1] = u * v + f * g + h * m - l * p),
      (t[e + 2] = h * v + f * p + l * g - u * m),
      (t[e + 3] = f * v - l * m - u * g - h * p),
      t
    );
  }
  get x() {
    return this._x;
  }
  set x(t) {
    (this._x = t), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    (this._y = t), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    (this._z = t), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    (this._w = t), this._onChangeCallback();
  }
  set(t, e, n, i) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return (
      (this._x = t.x),
      (this._y = t.y),
      (this._z = t.z),
      (this._w = t.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(t, e) {
    if (!(t && t.isEuler))
      throw new Error(
        "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
      );
    const n = t._x,
      i = t._y,
      r = t._z,
      o = t._order,
      l = Math.cos,
      u = Math.sin,
      h = l(n / 2),
      f = l(i / 2),
      m = l(r / 2),
      g = u(n / 2),
      p = u(i / 2),
      v = u(r / 2);
    switch (o) {
      case "XYZ":
        (this._x = g * f * m + h * p * v),
          (this._y = h * p * m - g * f * v),
          (this._z = h * f * v + g * p * m),
          (this._w = h * f * m - g * p * v);
        break;
      case "YXZ":
        (this._x = g * f * m + h * p * v),
          (this._y = h * p * m - g * f * v),
          (this._z = h * f * v - g * p * m),
          (this._w = h * f * m + g * p * v);
        break;
      case "ZXY":
        (this._x = g * f * m - h * p * v),
          (this._y = h * p * m + g * f * v),
          (this._z = h * f * v + g * p * m),
          (this._w = h * f * m - g * p * v);
        break;
      case "ZYX":
        (this._x = g * f * m - h * p * v),
          (this._y = h * p * m + g * f * v),
          (this._z = h * f * v - g * p * m),
          (this._w = h * f * m + g * p * v);
        break;
      case "YZX":
        (this._x = g * f * m + h * p * v),
          (this._y = h * p * m + g * f * v),
          (this._z = h * f * v - g * p * m),
          (this._w = h * f * m - g * p * v);
        break;
      case "XZY":
        (this._x = g * f * m - h * p * v),
          (this._y = h * p * m - g * f * v),
          (this._z = h * f * v + g * p * m),
          (this._w = h * f * m + g * p * v);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return e !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const n = e / 2,
      i = Math.sin(n);
    return (
      (this._x = t.x * i),
      (this._y = t.y * i),
      (this._z = t.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(t) {
    const e = t.elements,
      n = e[0],
      i = e[4],
      r = e[8],
      o = e[1],
      l = e[5],
      u = e[9],
      h = e[2],
      f = e[6],
      m = e[10],
      g = n + l + m;
    if (g > 0) {
      const p = 0.5 / Math.sqrt(g + 1);
      (this._w = 0.25 / p),
        (this._x = (f - u) * p),
        (this._y = (r - h) * p),
        (this._z = (o - i) * p);
    } else if (n > l && n > m) {
      const p = 2 * Math.sqrt(1 + n - l - m);
      (this._w = (f - u) / p),
        (this._x = 0.25 * p),
        (this._y = (i + o) / p),
        (this._z = (r + h) / p);
    } else if (l > m) {
      const p = 2 * Math.sqrt(1 + l - n - m);
      (this._w = (r - h) / p),
        (this._x = (i + o) / p),
        (this._y = 0.25 * p),
        (this._z = (u + f) / p);
    } else {
      const p = 2 * Math.sqrt(1 + m - n - l);
      (this._w = (o - i) / p),
        (this._x = (r + h) / p),
        (this._y = (u + f) / p),
        (this._z = 0.25 * p);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let n = t.dot(e) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(t.x) > Math.abs(t.z)
            ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = n)))
        : ((this._x = t.y * e.z - t.z * e.y),
          (this._y = t.z * e.x - t.x * e.z),
          (this._z = t.x * e.y - t.y * e.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(pi(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const n = this.angleTo(t);
    if (n === 0) return this;
    const i = Math.min(1, e / n);
    return this.slerp(t, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let t = this.length();
    return (
      t === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((t = 1 / t),
          (this._x = this._x * t),
          (this._y = this._y * t),
          (this._z = this._z * t),
          (this._w = this._w * t)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
        ),
        this.multiplyQuaternions(t, e))
      : this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const n = t._x,
      i = t._y,
      r = t._z,
      o = t._w,
      l = e._x,
      u = e._y,
      h = e._z,
      f = e._w;
    return (
      (this._x = n * f + o * l + i * h - r * u),
      (this._y = i * f + o * u + r * l - n * h),
      (this._z = r * f + o * h + n * u - i * l),
      (this._w = o * f - n * l - i * u - r * h),
      this._onChangeCallback(),
      this
    );
  }
  slerp(t, e) {
    if (e === 0) return this;
    if (e === 1) return this.copy(t);
    const n = this._x,
      i = this._y,
      r = this._z,
      o = this._w;
    let l = o * t._w + n * t._x + i * t._y + r * t._z;
    if (
      (l < 0
        ? ((this._w = -t._w),
          (this._x = -t._x),
          (this._y = -t._y),
          (this._z = -t._z),
          (l = -l))
        : this.copy(t),
      l >= 1)
    )
      return (this._w = o), (this._x = n), (this._y = i), (this._z = r), this;
    const u = 1 - l * l;
    if (u <= Number.EPSILON) {
      const p = 1 - e;
      return (
        (this._w = p * o + e * this._w),
        (this._x = p * n + e * this._x),
        (this._y = p * i + e * this._y),
        (this._z = p * r + e * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const h = Math.sqrt(u),
      f = Math.atan2(h, l),
      m = Math.sin((1 - e) * f) / h,
      g = Math.sin(e * f) / h;
    return (
      (this._w = o * m + this._w * g),
      (this._x = n * m + this._x * g),
      (this._y = i * m + this._y * g),
      (this._z = r * m + this._z * g),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(t, e, n) {
    this.copy(t).slerp(e, n);
  }
  random() {
    const t = Math.random(),
      e = Math.sqrt(1 - t),
      n = Math.sqrt(t),
      i = 2 * Math.PI * Math.random(),
      r = 2 * Math.PI * Math.random();
    return this.set(
      e * Math.cos(i),
      n * Math.sin(r),
      n * Math.cos(r),
      e * Math.sin(i)
    );
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._w === this._w
    );
  }
  fromArray(t, e = 0) {
    return (
      (this._x = t[e]),
      (this._y = t[e + 1]),
      (this._z = t[e + 2]),
      (this._w = t[e + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._w),
      t
    );
  }
  fromBufferAttribute(t, e) {
    return (
      (this._x = t.getX(e)),
      (this._y = t.getY(e)),
      (this._z = t.getZ(e)),
      (this._w = t.getW(e)),
      this
    );
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this;
  }
  _onChangeCallback() {}
}
Qn.prototype.isQuaternion = !0;
class k {
  constructor(t = 0, e = 0, n = 0) {
    (this.x = t), (this.y = e), (this.z = n);
  }
  set(t, e, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = t),
      (this.y = e),
      (this.z = n),
      this
    );
  }
  setScalar(t) {
    return (this.x = t), (this.y = t), (this.z = t), this;
  }
  setX(t) {
    return (this.x = t), this;
  }
  setY(t) {
    return (this.y = t), this;
  }
  setZ(t) {
    return (this.z = t), this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
  }
  add(t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(t, e))
      : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
  }
  addScalar(t) {
    return (this.x += t), (this.y += t), (this.z += t), this;
  }
  addVectors(t, e) {
    return (
      (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
    );
  }
  addScaledVector(t, e) {
    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
  }
  sub(t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(t, e))
      : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
  }
  subScalar(t) {
    return (this.x -= t), (this.y -= t), (this.z -= t), this;
  }
  subVectors(t, e) {
    return (
      (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
    );
  }
  multiply(t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
        ),
        this.multiplyVectors(t, e))
      : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
  }
  multiplyScalar(t) {
    return (this.x *= t), (this.y *= t), (this.z *= t), this;
  }
  multiplyVectors(t, e) {
    return (
      (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
    );
  }
  applyEuler(t) {
    return (
      (t && t.isEuler) ||
        console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        ),
      this.applyQuaternion(Fv.setFromEuler(t))
    );
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(Fv.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.elements;
    return (
      (this.x = r[0] * e + r[3] * n + r[6] * i),
      (this.y = r[1] * e + r[4] * n + r[7] * i),
      (this.z = r[2] * e + r[5] * n + r[8] * i),
      this
    );
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.elements,
      o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
    return (
      (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o),
      (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o),
      (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o),
      this
    );
  }
  applyQuaternion(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.x,
      o = t.y,
      l = t.z,
      u = t.w,
      h = u * e + o * i - l * n,
      f = u * n + l * e - r * i,
      m = u * i + r * n - o * e,
      g = -r * e - o * n - l * i;
    return (
      (this.x = h * u + g * -r + f * -l - m * -o),
      (this.y = f * u + g * -o + m * -r - h * -l),
      (this.z = m * u + g * -l + h * -o - f * -r),
      this
    );
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
      t.projectionMatrix
    );
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
      t.matrixWorld
    );
  }
  transformDirection(t) {
    const e = this.x,
      n = this.y,
      i = this.z,
      r = t.elements;
    return (
      (this.x = r[0] * e + r[4] * n + r[8] * i),
      (this.y = r[1] * e + r[5] * n + r[9] * i),
      (this.z = r[2] * e + r[6] * n + r[10] * i),
      this.normalize()
    );
  }
  divide(t) {
    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return (
      (this.x = Math.min(this.x, t.x)),
      (this.y = Math.min(this.y, t.y)),
      (this.z = Math.min(this.z, t.z)),
      this
    );
  }
  max(t) {
    return (
      (this.x = Math.max(this.x, t.x)),
      (this.y = Math.max(this.y, t.y)),
      (this.z = Math.max(this.z, t.z)),
      this
    );
  }
  clamp(t, e) {
    return (
      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
      this
    );
  }
  clampScalar(t, e) {
    return (
      (this.x = Math.max(t, Math.min(e, this.x))),
      (this.y = Math.max(t, Math.min(e, this.y))),
      (this.z = Math.max(t, Math.min(e, this.z))),
      this
    );
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(t, Math.min(e, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return (
      (this.x += (t.x - this.x) * e),
      (this.y += (t.y - this.y) * e),
      (this.z += (t.z - this.z) * e),
      this
    );
  }
  lerpVectors(t, e, n) {
    return (
      (this.x = t.x + (e.x - t.x) * n),
      (this.y = t.y + (e.y - t.y) * n),
      (this.z = t.z + (e.z - t.z) * n),
      this
    );
  }
  cross(t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
        ),
        this.crossVectors(t, e))
      : this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const n = t.x,
      i = t.y,
      r = t.z,
      o = e.x,
      l = e.y,
      u = e.z;
    return (
      (this.x = i * u - r * l),
      (this.y = r * o - n * u),
      (this.z = n * l - i * o),
      this
    );
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0) return this.set(0, 0, 0);
    const n = t.dot(this) / e;
    return this.copy(t).multiplyScalar(n);
  }
  projectOnPlane(t) {
    return Cd.copy(this).projectOnVector(t), this.sub(Cd);
  }
  reflect(t) {
    return this.sub(Cd.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0) return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(pi(n, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x,
      n = this.y - t.y,
      i = this.z - t.z;
    return e * e + n * n + i * i;
  }
  manhattanDistanceTo(t) {
    return (
      Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    );
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, n) {
    const i = Math.sin(e) * t;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(e) * t),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, n) {
    return (
      (this.x = t * Math.sin(e)), (this.y = n), (this.z = t * Math.cos(e)), this
    );
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(),
      n = this.setFromMatrixColumn(t, 1).length(),
      i = this.setFromMatrixColumn(t, 2).length();
    return (this.x = e), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
  }
  fromBufferAttribute(t, e, n) {
    return (
      n !== void 0 &&
        console.warn(
          "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = t.getX(e)),
      (this.y = t.getY(e)),
      (this.z = t.getZ(e)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const t = (Math.random() - 0.5) * 2,
      e = Math.random() * Math.PI * 2,
      n = Math.sqrt(1 - t ** 2);
    return (
      (this.x = n * Math.cos(e)), (this.y = n * Math.sin(e)), (this.z = t), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
k.prototype.isVector3 = !0;
const Cd = new k(),
  Fv = new Qn();
class Wi {
  constructor(
    t = new k(1 / 0, 1 / 0, 1 / 0),
    e = new k(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.min = t), (this.max = e);
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    let e = 1 / 0,
      n = 1 / 0,
      i = 1 / 0,
      r = -1 / 0,
      o = -1 / 0,
      l = -1 / 0;
    for (let u = 0, h = t.length; u < h; u += 3) {
      const f = t[u],
        m = t[u + 1],
        g = t[u + 2];
      f < e && (e = f),
        m < n && (n = m),
        g < i && (i = g),
        f > r && (r = f),
        m > o && (o = m),
        g > l && (l = g);
    }
    return this.min.set(e, n, i), this.max.set(r, o, l), this;
  }
  setFromBufferAttribute(t) {
    let e = 1 / 0,
      n = 1 / 0,
      i = 1 / 0,
      r = -1 / 0,
      o = -1 / 0,
      l = -1 / 0;
    for (let u = 0, h = t.count; u < h; u++) {
      const f = t.getX(u),
        m = t.getY(u),
        g = t.getZ(u);
      f < e && (e = f),
        m < n && (n = m),
        g < i && (i = g),
        f > r && (r = f),
        m > o && (o = m),
        g > l && (l = g);
    }
    return this.min.set(e, n, i), this.max.set(r, o, l), this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const n = xl.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  }
  setFromObject(t) {
    return this.makeEmpty(), this.expandByObject(t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(t) {
    return this.isEmpty()
      ? t.set(0, 0, 0)
      : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t) {
    t.updateWorldMatrix(!1, !1);
    const e = t.geometry;
    e !== void 0 &&
      (e.boundingBox === null && e.computeBoundingBox(),
      Rd.copy(e.boundingBox),
      Rd.applyMatrix4(t.matrixWorld),
      this.union(Rd));
    const n = t.children;
    for (let i = 0, r = n.length; i < r; i++) this.expandByObject(n[i]);
    return this;
  }
  containsPoint(t) {
    return !(
      t.x < this.min.x ||
      t.x > this.max.x ||
      t.y < this.min.y ||
      t.y > this.max.y ||
      t.z < this.min.z ||
      t.z > this.max.z
    );
  }
  containsBox(t) {
    return (
      this.min.x <= t.min.x &&
      t.max.x <= this.max.x &&
      this.min.y <= t.min.y &&
      t.max.y <= this.max.y &&
      this.min.z <= t.min.z &&
      t.max.z <= this.max.z
    );
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(t) {
    return !(
      t.max.x < this.min.x ||
      t.min.x > this.max.x ||
      t.max.y < this.min.y ||
      t.min.y > this.max.y ||
      t.max.z < this.min.z ||
      t.min.z > this.max.z
    );
  }
  intersectsSphere(t) {
    return (
      this.clampPoint(t.center, xl),
      xl.distanceToSquared(t.center) <= t.radius * t.radius
    );
  }
  intersectsPlane(t) {
    let e, n;
    return (
      t.normal.x > 0
        ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
        : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
      t.normal.y > 0
        ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
        : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
      t.normal.z > 0
        ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
        : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
      e <= -t.constant && n >= -t.constant
    );
  }
  intersectsTriangle(t) {
    if (this.isEmpty()) return !1;
    this.getCenter(yl),
      xu.subVectors(this.max, yl),
      na.subVectors(t.a, yl),
      ia.subVectors(t.b, yl),
      ra.subVectors(t.c, yl),
      fs.subVectors(ia, na),
      ds.subVectors(ra, ia),
      Ks.subVectors(na, ra);
    let e = [
      0,
      -fs.z,
      fs.y,
      0,
      -ds.z,
      ds.y,
      0,
      -Ks.z,
      Ks.y,
      fs.z,
      0,
      -fs.x,
      ds.z,
      0,
      -ds.x,
      Ks.z,
      0,
      -Ks.x,
      -fs.y,
      fs.x,
      0,
      -ds.y,
      ds.x,
      0,
      -Ks.y,
      Ks.x,
      0,
    ];
    return !Pd(e, na, ia, ra, xu) ||
      ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Pd(e, na, ia, ra, xu))
      ? !1
      : (yu.crossVectors(fs, ds),
        (e = [yu.x, yu.y, yu.z]),
        Pd(e, na, ia, ra, xu));
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return xl.copy(t).clamp(this.min, this.max).sub(t).length();
  }
  getBoundingSphere(t) {
    return (
      this.getCenter(t.center), (t.radius = this.getSize(xl).length() * 0.5), t
    );
  }
  intersect(t) {
    return (
      this.min.max(t.min),
      this.max.min(t.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return this.isEmpty()
      ? this
      : (Ir[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
        Ir[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
        Ir[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
        Ir[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
        Ir[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
        Ir[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
        Ir[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
        Ir[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
        this.setFromPoints(Ir),
        this);
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
Wi.prototype.isBox3 = !0;
const Ir = [
    new k(),
    new k(),
    new k(),
    new k(),
    new k(),
    new k(),
    new k(),
    new k(),
  ],
  xl = new k(),
  Rd = new Wi(),
  na = new k(),
  ia = new k(),
  ra = new k(),
  fs = new k(),
  ds = new k(),
  Ks = new k(),
  yl = new k(),
  xu = new k(),
  yu = new k(),
  Qs = new k();
function Pd(a, t, e, n, i) {
  for (let r = 0, o = a.length - 3; r <= o; r += 3) {
    Qs.fromArray(a, r);
    const l =
        i.x * Math.abs(Qs.x) + i.y * Math.abs(Qs.y) + i.z * Math.abs(Qs.z),
      u = t.dot(Qs),
      h = e.dot(Qs),
      f = n.dot(Qs);
    if (Math.max(-Math.max(u, h, f), Math.min(u, h, f)) > l) return !1;
  }
  return !0;
}
const qC = new Wi(),
  Ov = new k(),
  Id = new k(),
  Dd = new k();
class sa {
  constructor(t = new k(), e = -1) {
    (this.center = t), (this.radius = e);
  }
  set(t, e) {
    return this.center.copy(t), (this.radius = e), this;
  }
  setFromPoints(t, e) {
    const n = this.center;
    e !== void 0 ? n.copy(e) : qC.setFromPoints(t).getCenter(n);
    let i = 0;
    for (let r = 0, o = t.length; r < o; r++)
      i = Math.max(i, n.distanceToSquared(t[r]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(t) {
    return this.center.copy(t.center), (this.radius = t.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    const n = this.center.distanceToSquared(t);
    return (
      e.copy(t),
      n > this.radius * this.radius &&
        (e.sub(this.center).normalize(),
        e.multiplyScalar(this.radius).add(this.center)),
      e
    );
  }
  getBoundingBox(t) {
    return this.isEmpty()
      ? (t.makeEmpty(), t)
      : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return (
      this.center.applyMatrix4(t),
      (this.radius = this.radius * t.getMaxScaleOnAxis()),
      this
    );
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    Dd.subVectors(t, this.center);
    const e = Dd.lengthSq();
    if (e > this.radius * this.radius) {
      const n = Math.sqrt(e),
        i = (n - this.radius) * 0.5;
      this.center.add(Dd.multiplyScalar(i / n)), (this.radius += i);
    }
    return this;
  }
  union(t) {
    return (
      Id.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius),
      this.expandByPoint(Ov.copy(t.center).add(Id)),
      this.expandByPoint(Ov.copy(t.center).sub(Id)),
      this
    );
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Dr = new k(),
  Fd = new k(),
  wu = new k(),
  ps = new k(),
  Od = new k(),
  bu = new k(),
  Nd = new k();
class to {
  constructor(t = new k(), e = new k(0, 0, -1)) {
    (this.origin = t), (this.direction = e);
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return e.copy(this.direction).multiplyScalar(t).add(this.origin);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, Dr)), this;
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin);
    const n = e.dot(this.direction);
    return n < 0
      ? e.copy(this.origin)
      : e.copy(this.direction).multiplyScalar(n).add(this.origin);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const e = Dr.subVectors(t, this.origin).dot(this.direction);
    return e < 0
      ? this.origin.distanceToSquared(t)
      : (Dr.copy(this.direction).multiplyScalar(e).add(this.origin),
        Dr.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, n, i) {
    Fd.copy(t).add(e).multiplyScalar(0.5),
      wu.copy(e).sub(t).normalize(),
      ps.copy(this.origin).sub(Fd);
    const r = t.distanceTo(e) * 0.5,
      o = -this.direction.dot(wu),
      l = ps.dot(this.direction),
      u = -ps.dot(wu),
      h = ps.lengthSq(),
      f = Math.abs(1 - o * o);
    let m, g, p, v;
    if (f > 0)
      if (((m = o * u - l), (g = o * l - u), (v = r * f), m >= 0))
        if (g >= -v)
          if (g <= v) {
            const x = 1 / f;
            (m *= x),
              (g *= x),
              (p = m * (m + o * g + 2 * l) + g * (o * m + g + 2 * u) + h);
          } else
            (g = r),
              (m = Math.max(0, -(o * g + l))),
              (p = -m * m + g * (g + 2 * u) + h);
        else
          (g = -r),
            (m = Math.max(0, -(o * g + l))),
            (p = -m * m + g * (g + 2 * u) + h);
      else
        g <= -v
          ? ((m = Math.max(0, -(-o * r + l))),
            (g = m > 0 ? -r : Math.min(Math.max(-r, -u), r)),
            (p = -m * m + g * (g + 2 * u) + h))
          : g <= v
          ? ((m = 0),
            (g = Math.min(Math.max(-r, -u), r)),
            (p = g * (g + 2 * u) + h))
          : ((m = Math.max(0, -(o * r + l))),
            (g = m > 0 ? r : Math.min(Math.max(-r, -u), r)),
            (p = -m * m + g * (g + 2 * u) + h));
    else
      (g = o > 0 ? -r : r),
        (m = Math.max(0, -(o * g + l))),
        (p = -m * m + g * (g + 2 * u) + h);
    return (
      n && n.copy(this.direction).multiplyScalar(m).add(this.origin),
      i && i.copy(wu).multiplyScalar(g).add(Fd),
      p
    );
  }
  intersectSphere(t, e) {
    Dr.subVectors(t.center, this.origin);
    const n = Dr.dot(this.direction),
      i = Dr.dot(Dr) - n * n,
      r = t.radius * t.radius;
    if (i > r) return null;
    const o = Math.sqrt(r - i),
      l = n - o,
      u = n + o;
    return l < 0 && u < 0 ? null : l < 0 ? this.at(u, e) : this.at(l, e);
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction);
    if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(t.normal) + t.constant) / e;
    return n >= 0 ? n : null;
  }
  intersectPlane(t, e) {
    const n = this.distanceToPlane(t);
    return n === null ? null : this.at(n, e);
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin);
    return e === 0 || t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let n, i, r, o, l, u;
    const h = 1 / this.direction.x,
      f = 1 / this.direction.y,
      m = 1 / this.direction.z,
      g = this.origin;
    return (
      h >= 0
        ? ((n = (t.min.x - g.x) * h), (i = (t.max.x - g.x) * h))
        : ((n = (t.max.x - g.x) * h), (i = (t.min.x - g.x) * h)),
      f >= 0
        ? ((r = (t.min.y - g.y) * f), (o = (t.max.y - g.y) * f))
        : ((r = (t.max.y - g.y) * f), (o = (t.min.y - g.y) * f)),
      n > o ||
      r > i ||
      ((r > n || n !== n) && (n = r),
      (o < i || i !== i) && (i = o),
      m >= 0
        ? ((l = (t.min.z - g.z) * m), (u = (t.max.z - g.z) * m))
        : ((l = (t.max.z - g.z) * m), (u = (t.min.z - g.z) * m)),
      n > u || l > i) ||
      ((l > n || n !== n) && (n = l), (u < i || i !== i) && (i = u), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, e)
    );
  }
  intersectsBox(t) {
    return this.intersectBox(t, Dr) !== null;
  }
  intersectTriangle(t, e, n, i, r) {
    Od.subVectors(e, t), bu.subVectors(n, t), Nd.crossVectors(Od, bu);
    let o = this.direction.dot(Nd),
      l;
    if (o > 0) {
      if (i) return null;
      l = 1;
    } else if (o < 0) (l = -1), (o = -o);
    else return null;
    ps.subVectors(this.origin, t);
    const u = l * this.direction.dot(bu.crossVectors(ps, bu));
    if (u < 0) return null;
    const h = l * this.direction.dot(Od.cross(ps));
    if (h < 0 || u + h > o) return null;
    const f = -l * ps.dot(Nd);
    return f < 0 ? null : this.at(f / o, r);
  }
  applyMatrix4(t) {
    return (
      this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    );
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Jt {
  constructor() {
    (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
        );
  }
  set(t, e, n, i, r, o, l, u, h, f, m, g, p, v, x, b) {
    const _ = this.elements;
    return (
      (_[0] = t),
      (_[4] = e),
      (_[8] = n),
      (_[12] = i),
      (_[1] = r),
      (_[5] = o),
      (_[9] = l),
      (_[13] = u),
      (_[2] = h),
      (_[6] = f),
      (_[10] = m),
      (_[14] = g),
      (_[3] = p),
      (_[7] = v),
      (_[11] = x),
      (_[15] = b),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Jt().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements,
      n = t.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[1]),
      (e[2] = n[2]),
      (e[3] = n[3]),
      (e[4] = n[4]),
      (e[5] = n[5]),
      (e[6] = n[6]),
      (e[7] = n[7]),
      (e[8] = n[8]),
      (e[9] = n[9]),
      (e[10] = n[10]),
      (e[11] = n[11]),
      (e[12] = n[12]),
      (e[13] = n[13]),
      (e[14] = n[14]),
      (e[15] = n[15]),
      this
    );
  }
  copyPosition(t) {
    const e = this.elements,
      n = t.elements;
    return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return (
      this.set(
        e[0],
        e[3],
        e[6],
        0,
        e[1],
        e[4],
        e[7],
        0,
        e[2],
        e[5],
        e[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(t, e, n) {
    return (
      t.setFromMatrixColumn(this, 0),
      e.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(t, e, n) {
    return (
      this.set(
        t.x,
        e.x,
        n.x,
        0,
        t.y,
        e.y,
        n.y,
        0,
        t.z,
        e.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(t) {
    const e = this.elements,
      n = t.elements,
      i = 1 / oa.setFromMatrixColumn(t, 0).length(),
      r = 1 / oa.setFromMatrixColumn(t, 1).length(),
      o = 1 / oa.setFromMatrixColumn(t, 2).length();
    return (
      (e[0] = n[0] * i),
      (e[1] = n[1] * i),
      (e[2] = n[2] * i),
      (e[3] = 0),
      (e[4] = n[4] * r),
      (e[5] = n[5] * r),
      (e[6] = n[6] * r),
      (e[7] = 0),
      (e[8] = n[8] * o),
      (e[9] = n[9] * o),
      (e[10] = n[10] * o),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  }
  makeRotationFromEuler(t) {
    (t && t.isEuler) ||
      console.error(
        "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
      );
    const e = this.elements,
      n = t.x,
      i = t.y,
      r = t.z,
      o = Math.cos(n),
      l = Math.sin(n),
      u = Math.cos(i),
      h = Math.sin(i),
      f = Math.cos(r),
      m = Math.sin(r);
    if (t.order === "XYZ") {
      const g = o * f,
        p = o * m,
        v = l * f,
        x = l * m;
      (e[0] = u * f),
        (e[4] = -u * m),
        (e[8] = h),
        (e[1] = p + v * h),
        (e[5] = g - x * h),
        (e[9] = -l * u),
        (e[2] = x - g * h),
        (e[6] = v + p * h),
        (e[10] = o * u);
    } else if (t.order === "YXZ") {
      const g = u * f,
        p = u * m,
        v = h * f,
        x = h * m;
      (e[0] = g + x * l),
        (e[4] = v * l - p),
        (e[8] = o * h),
        (e[1] = o * m),
        (e[5] = o * f),
        (e[9] = -l),
        (e[2] = p * l - v),
        (e[6] = x + g * l),
        (e[10] = o * u);
    } else if (t.order === "ZXY") {
      const g = u * f,
        p = u * m,
        v = h * f,
        x = h * m;
      (e[0] = g - x * l),
        (e[4] = -o * m),
        (e[8] = v + p * l),
        (e[1] = p + v * l),
        (e[5] = o * f),
        (e[9] = x - g * l),
        (e[2] = -o * h),
        (e[6] = l),
        (e[10] = o * u);
    } else if (t.order === "ZYX") {
      const g = o * f,
        p = o * m,
        v = l * f,
        x = l * m;
      (e[0] = u * f),
        (e[4] = v * h - p),
        (e[8] = g * h + x),
        (e[1] = u * m),
        (e[5] = x * h + g),
        (e[9] = p * h - v),
        (e[2] = -h),
        (e[6] = l * u),
        (e[10] = o * u);
    } else if (t.order === "YZX") {
      const g = o * u,
        p = o * h,
        v = l * u,
        x = l * h;
      (e[0] = u * f),
        (e[4] = x - g * m),
        (e[8] = v * m + p),
        (e[1] = m),
        (e[5] = o * f),
        (e[9] = -l * f),
        (e[2] = -h * f),
        (e[6] = p * m + v),
        (e[10] = g - x * m);
    } else if (t.order === "XZY") {
      const g = o * u,
        p = o * h,
        v = l * u,
        x = l * h;
      (e[0] = u * f),
        (e[4] = -m),
        (e[8] = h * f),
        (e[1] = g * m + x),
        (e[5] = o * f),
        (e[9] = p * m - v),
        (e[2] = v * m - p),
        (e[6] = l * f),
        (e[10] = x * m + g);
    }
    return (
      (e[3] = 0),
      (e[7] = 0),
      (e[11] = 0),
      (e[12] = 0),
      (e[13] = 0),
      (e[14] = 0),
      (e[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(t) {
    return this.compose(ZC, t, jC);
  }
  lookAt(t, e, n) {
    const i = this.elements;
    return (
      mi.subVectors(t, e),
      mi.lengthSq() === 0 && (mi.z = 1),
      mi.normalize(),
      ms.crossVectors(n, mi),
      ms.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (mi.x += 1e-4) : (mi.z += 1e-4),
        mi.normalize(),
        ms.crossVectors(n, mi)),
      ms.normalize(),
      Mu.crossVectors(mi, ms),
      (i[0] = ms.x),
      (i[4] = Mu.x),
      (i[8] = mi.x),
      (i[1] = ms.y),
      (i[5] = Mu.y),
      (i[9] = mi.y),
      (i[2] = ms.z),
      (i[6] = Mu.z),
      (i[10] = mi.z),
      this
    );
  }
  multiply(t, e) {
    return e !== void 0
      ? (console.warn(
          "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
        ),
        this.multiplyMatrices(t, e))
      : this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements,
      i = e.elements,
      r = this.elements,
      o = n[0],
      l = n[4],
      u = n[8],
      h = n[12],
      f = n[1],
      m = n[5],
      g = n[9],
      p = n[13],
      v = n[2],
      x = n[6],
      b = n[10],
      _ = n[14],
      y = n[3],
      E = n[7],
      M = n[11],
      A = n[15],
      R = i[0],
      T = i[4],
      B = i[8],
      X = i[12],
      H = i[1],
      O = i[5],
      it = i[9],
      W = i[13],
      q = i[2],
      tt = i[6],
      V = i[10],
      Q = i[14],
      st = i[3],
      Lt = i[7],
      J = i[11],
      vt = i[15];
    return (
      (r[0] = o * R + l * H + u * q + h * st),
      (r[4] = o * T + l * O + u * tt + h * Lt),
      (r[8] = o * B + l * it + u * V + h * J),
      (r[12] = o * X + l * W + u * Q + h * vt),
      (r[1] = f * R + m * H + g * q + p * st),
      (r[5] = f * T + m * O + g * tt + p * Lt),
      (r[9] = f * B + m * it + g * V + p * J),
      (r[13] = f * X + m * W + g * Q + p * vt),
      (r[2] = v * R + x * H + b * q + _ * st),
      (r[6] = v * T + x * O + b * tt + _ * Lt),
      (r[10] = v * B + x * it + b * V + _ * J),
      (r[14] = v * X + x * W + b * Q + _ * vt),
      (r[3] = y * R + E * H + M * q + A * st),
      (r[7] = y * T + E * O + M * tt + A * Lt),
      (r[11] = y * B + E * it + M * V + A * J),
      (r[15] = y * X + E * W + M * Q + A * vt),
      this
    );
  }
  multiplyScalar(t) {
    const e = this.elements;
    return (
      (e[0] *= t),
      (e[4] *= t),
      (e[8] *= t),
      (e[12] *= t),
      (e[1] *= t),
      (e[5] *= t),
      (e[9] *= t),
      (e[13] *= t),
      (e[2] *= t),
      (e[6] *= t),
      (e[10] *= t),
      (e[14] *= t),
      (e[3] *= t),
      (e[7] *= t),
      (e[11] *= t),
      (e[15] *= t),
      this
    );
  }
  determinant() {
    const t = this.elements,
      e = t[0],
      n = t[4],
      i = t[8],
      r = t[12],
      o = t[1],
      l = t[5],
      u = t[9],
      h = t[13],
      f = t[2],
      m = t[6],
      g = t[10],
      p = t[14],
      v = t[3],
      x = t[7],
      b = t[11],
      _ = t[15];
    return (
      v *
        (+r * u * m -
          i * h * m -
          r * l * g +
          n * h * g +
          i * l * p -
          n * u * p) +
      x *
        (+e * u * p -
          e * h * g +
          r * o * g -
          i * o * p +
          i * h * f -
          r * u * f) +
      b *
        (+e * h * m -
          e * l * p -
          r * o * m +
          n * o * p +
          r * l * f -
          n * h * f) +
      _ *
        (-i * l * f - e * u * m + e * l * g + i * o * m - n * o * g + n * u * f)
    );
  }
  transpose() {
    const t = this.elements;
    let e;
    return (
      (e = t[1]),
      (t[1] = t[4]),
      (t[4] = e),
      (e = t[2]),
      (t[2] = t[8]),
      (t[8] = e),
      (e = t[6]),
      (t[6] = t[9]),
      (t[9] = e),
      (e = t[3]),
      (t[3] = t[12]),
      (t[12] = e),
      (e = t[7]),
      (t[7] = t[13]),
      (t[13] = e),
      (e = t[11]),
      (t[11] = t[14]),
      (t[14] = e),
      this
    );
  }
  setPosition(t, e, n) {
    const i = this.elements;
    return (
      t.isVector3
        ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
        : ((i[12] = t), (i[13] = e), (i[14] = n)),
      this
    );
  }
  invert() {
    const t = this.elements,
      e = t[0],
      n = t[1],
      i = t[2],
      r = t[3],
      o = t[4],
      l = t[5],
      u = t[6],
      h = t[7],
      f = t[8],
      m = t[9],
      g = t[10],
      p = t[11],
      v = t[12],
      x = t[13],
      b = t[14],
      _ = t[15],
      y = m * b * h - x * g * h + x * u * p - l * b * p - m * u * _ + l * g * _,
      E = v * g * h - f * b * h - v * u * p + o * b * p + f * u * _ - o * g * _,
      M = f * x * h - v * m * h + v * l * p - o * x * p - f * l * _ + o * m * _,
      A = v * m * u - f * x * u - v * l * g + o * x * g + f * l * b - o * m * b,
      R = e * y + n * E + i * M + r * A;
    if (R === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / R;
    return (
      (t[0] = y * T),
      (t[1] =
        (x * g * r -
          m * b * r -
          x * i * p +
          n * b * p +
          m * i * _ -
          n * g * _) *
        T),
      (t[2] =
        (l * b * r -
          x * u * r +
          x * i * h -
          n * b * h -
          l * i * _ +
          n * u * _) *
        T),
      (t[3] =
        (m * u * r -
          l * g * r -
          m * i * h +
          n * g * h +
          l * i * p -
          n * u * p) *
        T),
      (t[4] = E * T),
      (t[5] =
        (f * b * r -
          v * g * r +
          v * i * p -
          e * b * p -
          f * i * _ +
          e * g * _) *
        T),
      (t[6] =
        (v * u * r -
          o * b * r -
          v * i * h +
          e * b * h +
          o * i * _ -
          e * u * _) *
        T),
      (t[7] =
        (o * g * r -
          f * u * r +
          f * i * h -
          e * g * h -
          o * i * p +
          e * u * p) *
        T),
      (t[8] = M * T),
      (t[9] =
        (v * m * r -
          f * x * r -
          v * n * p +
          e * x * p +
          f * n * _ -
          e * m * _) *
        T),
      (t[10] =
        (o * x * r -
          v * l * r +
          v * n * h -
          e * x * h -
          o * n * _ +
          e * l * _) *
        T),
      (t[11] =
        (f * l * r -
          o * m * r -
          f * n * h +
          e * m * h +
          o * n * p -
          e * l * p) *
        T),
      (t[12] = A * T),
      (t[13] =
        (f * x * i -
          v * m * i +
          v * n * g -
          e * x * g -
          f * n * b +
          e * m * b) *
        T),
      (t[14] =
        (v * l * i -
          o * x * i -
          v * n * u +
          e * x * u +
          o * n * b -
          e * l * b) *
        T),
      (t[15] =
        (o * m * i -
          f * l * i +
          f * n * u -
          e * m * u -
          o * n * g +
          e * l * g) *
        T),
      this
    );
  }
  scale(t) {
    const e = this.elements,
      n = t.x,
      i = t.y,
      r = t.z;
    return (
      (e[0] *= n),
      (e[4] *= i),
      (e[8] *= r),
      (e[1] *= n),
      (e[5] *= i),
      (e[9] *= r),
      (e[2] *= n),
      (e[6] *= i),
      (e[10] *= r),
      (e[3] *= n),
      (e[7] *= i),
      (e[11] *= r),
      this
    );
  }
  getMaxScaleOnAxis() {
    const t = this.elements,
      e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
      n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
      i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, n, i));
  }
  makeTranslation(t, e, n) {
    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
  }
  makeRotationX(t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t),
      n = Math.sin(t);
    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t, e) {
    const n = Math.cos(e),
      i = Math.sin(e),
      r = 1 - n,
      o = t.x,
      l = t.y,
      u = t.z,
      h = r * o,
      f = r * l;
    return (
      this.set(
        h * o + n,
        h * l - i * u,
        h * u + i * l,
        0,
        h * l + i * u,
        f * l + n,
        f * u - i * o,
        0,
        h * u - i * l,
        f * u + i * o,
        r * u * u + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(t, e, n) {
    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(t, e, n, i, r, o) {
    return this.set(1, n, r, 0, t, 1, o, 0, e, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t, e, n) {
    const i = this.elements,
      r = e._x,
      o = e._y,
      l = e._z,
      u = e._w,
      h = r + r,
      f = o + o,
      m = l + l,
      g = r * h,
      p = r * f,
      v = r * m,
      x = o * f,
      b = o * m,
      _ = l * m,
      y = u * h,
      E = u * f,
      M = u * m,
      A = n.x,
      R = n.y,
      T = n.z;
    return (
      (i[0] = (1 - (x + _)) * A),
      (i[1] = (p + M) * A),
      (i[2] = (v - E) * A),
      (i[3] = 0),
      (i[4] = (p - M) * R),
      (i[5] = (1 - (g + _)) * R),
      (i[6] = (b + y) * R),
      (i[7] = 0),
      (i[8] = (v + E) * T),
      (i[9] = (b - y) * T),
      (i[10] = (1 - (g + x)) * T),
      (i[11] = 0),
      (i[12] = t.x),
      (i[13] = t.y),
      (i[14] = t.z),
      (i[15] = 1),
      this
    );
  }
  decompose(t, e, n) {
    const i = this.elements;
    let r = oa.set(i[0], i[1], i[2]).length();
    const o = oa.set(i[4], i[5], i[6]).length(),
      l = oa.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r),
      (t.x = i[12]),
      (t.y = i[13]),
      (t.z = i[14]),
      Xi.copy(this);
    const h = 1 / r,
      f = 1 / o,
      m = 1 / l;
    return (
      (Xi.elements[0] *= h),
      (Xi.elements[1] *= h),
      (Xi.elements[2] *= h),
      (Xi.elements[4] *= f),
      (Xi.elements[5] *= f),
      (Xi.elements[6] *= f),
      (Xi.elements[8] *= m),
      (Xi.elements[9] *= m),
      (Xi.elements[10] *= m),
      e.setFromRotationMatrix(Xi),
      (n.x = r),
      (n.y = o),
      (n.z = l),
      this
    );
  }
  makePerspective(t, e, n, i, r, o) {
    o === void 0 &&
      console.warn(
        "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
      );
    const l = this.elements,
      u = (2 * r) / (e - t),
      h = (2 * r) / (n - i),
      f = (e + t) / (e - t),
      m = (n + i) / (n - i),
      g = -(o + r) / (o - r),
      p = (-2 * o * r) / (o - r);
    return (
      (l[0] = u),
      (l[4] = 0),
      (l[8] = f),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = h),
      (l[9] = m),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = g),
      (l[14] = p),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(t, e, n, i, r, o) {
    const l = this.elements,
      u = 1 / (e - t),
      h = 1 / (n - i),
      f = 1 / (o - r),
      m = (e + t) * u,
      g = (n + i) * h,
      p = (o + r) * f;
    return (
      (l[0] = 2 * u),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -m),
      (l[1] = 0),
      (l[5] = 2 * h),
      (l[9] = 0),
      (l[13] = -g),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = -2 * f),
      (l[14] = -p),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(t) {
    const e = this.elements,
      n = t.elements;
    for (let i = 0; i < 16; i++) if (e[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.elements;
    return (
      (t[e] = n[0]),
      (t[e + 1] = n[1]),
      (t[e + 2] = n[2]),
      (t[e + 3] = n[3]),
      (t[e + 4] = n[4]),
      (t[e + 5] = n[5]),
      (t[e + 6] = n[6]),
      (t[e + 7] = n[7]),
      (t[e + 8] = n[8]),
      (t[e + 9] = n[9]),
      (t[e + 10] = n[10]),
      (t[e + 11] = n[11]),
      (t[e + 12] = n[12]),
      (t[e + 13] = n[13]),
      (t[e + 14] = n[14]),
      (t[e + 15] = n[15]),
      t
    );
  }
}
Jt.prototype.isMatrix4 = !0;
const oa = new k(),
  Xi = new Jt(),
  ZC = new k(0, 0, 0),
  jC = new k(1, 1, 1),
  ms = new k(),
  Mu = new k(),
  mi = new k(),
  Nv = new Jt(),
  Bv = new Qn();
class aa {
  constructor(t = 0, e = 0, n = 0, i = aa.DefaultOrder) {
    (this._x = t), (this._y = e), (this._z = n), (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(t) {
    (this._x = t), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    (this._y = t), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    (this._z = t), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    (this._order = t), this._onChangeCallback();
  }
  set(t, e, n, i = this._order) {
    return (
      (this._x = t),
      (this._y = e),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return (
      (this._x = t._x),
      (this._y = t._y),
      (this._z = t._z),
      (this._order = t._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(t, e = this._order, n = !0) {
    const i = t.elements,
      r = i[0],
      o = i[4],
      l = i[8],
      u = i[1],
      h = i[5],
      f = i[9],
      m = i[2],
      g = i[6],
      p = i[10];
    switch (e) {
      case "XYZ":
        (this._y = Math.asin(pi(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-f, p)), (this._z = Math.atan2(-o, r)))
            : ((this._x = Math.atan2(g, h)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-pi(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._y = Math.atan2(l, p)), (this._z = Math.atan2(u, h)))
            : ((this._y = Math.atan2(-m, r)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(pi(g, -1, 1))),
          Math.abs(g) < 0.9999999
            ? ((this._y = Math.atan2(-m, p)), (this._z = Math.atan2(-o, h)))
            : ((this._y = 0), (this._z = Math.atan2(u, r)));
        break;
      case "ZYX":
        (this._y = Math.asin(-pi(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._x = Math.atan2(g, p)), (this._z = Math.atan2(u, r)))
            : ((this._x = 0), (this._z = Math.atan2(-o, h)));
        break;
      case "YZX":
        (this._z = Math.asin(pi(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._x = Math.atan2(-f, h)), (this._y = Math.atan2(-m, r)))
            : ((this._x = 0), (this._y = Math.atan2(l, p)));
        break;
      case "XZY":
        (this._z = Math.asin(-pi(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(g, h)), (this._y = Math.atan2(l, r)))
            : ((this._x = Math.atan2(-f, p)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            e
        );
    }
    return (this._order = e), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, n) {
    return (
      Nv.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Nv, e, n)
    );
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return Bv.setFromEuler(this), this.setFromQuaternion(Bv, t);
  }
  equals(t) {
    return (
      t._x === this._x &&
      t._y === this._y &&
      t._z === this._z &&
      t._order === this._order
    );
  }
  fromArray(t) {
    return (
      (this._x = t[0]),
      (this._y = t[1]),
      (this._z = t[2]),
      t[3] !== void 0 && (this._order = t[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(t = [], e = 0) {
    return (
      (t[e] = this._x),
      (t[e + 1] = this._y),
      (t[e + 2] = this._z),
      (t[e + 3] = this._order),
      t
    );
  }
  toVector3(t) {
    return t
      ? t.set(this._x, this._y, this._z)
      : new k(this._x, this._y, this._z);
  }
  _onChange(t) {
    return (this._onChangeCallback = t), this;
  }
  _onChangeCallback() {}
}
aa.prototype.isEuler = !0;
aa.DefaultOrder = "XYZ";
aa.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class zv {
  constructor() {
    this.mask = 1 | 0;
  }
  set(t) {
    this.mask = (1 << t) | 0;
  }
  enable(t) {
    this.mask |= (1 << t) | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(t) {
    this.mask ^= (1 << t) | 0;
  }
  disable(t) {
    this.mask &= ~((1 << t) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return (this.mask & t.mask) != 0;
  }
}
let JC = 0;
const Uv = new k(),
  la = new Qn(),
  Fr = new Jt(),
  Su = new k(),
  wl = new k(),
  $C = new k(),
  KC = new Qn(),
  kv = new k(1, 0, 0),
  Gv = new k(0, 1, 0),
  Hv = new k(0, 0, 1),
  QC = { type: "added" },
  Vv = { type: "removed" };
class Me extends $s {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: JC++ }),
      (this.uuid = sr()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Me.DefaultUp.clone());
    const t = new k(),
      e = new aa(),
      n = new Qn(),
      i = new k(1, 1, 1);
    function r() {
      n.setFromEuler(e, !1);
    }
    function o() {
      e.setFromQuaternion(n, void 0, !1);
    }
    e._onChange(r),
      n._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: t },
        rotation: { configurable: !0, enumerable: !0, value: e },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Jt() },
        normalMatrix: { value: new Mn() },
      }),
      (this.matrix = new Jt()),
      (this.matrixWorld = new Jt()),
      (this.matrixAutoUpdate = Me.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new zv()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(t),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this;
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0);
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t);
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t);
  }
  rotateOnAxis(t, e) {
    return la.setFromAxisAngle(t, e), this.quaternion.multiply(la), this;
  }
  rotateOnWorldAxis(t, e) {
    return la.setFromAxisAngle(t, e), this.quaternion.premultiply(la), this;
  }
  rotateX(t) {
    return this.rotateOnAxis(kv, t);
  }
  rotateY(t) {
    return this.rotateOnAxis(Gv, t);
  }
  rotateZ(t) {
    return this.rotateOnAxis(Hv, t);
  }
  translateOnAxis(t, e) {
    return (
      Uv.copy(t).applyQuaternion(this.quaternion),
      this.position.add(Uv.multiplyScalar(e)),
      this
    );
  }
  translateX(t) {
    return this.translateOnAxis(kv, t);
  }
  translateY(t) {
    return this.translateOnAxis(Gv, t);
  }
  translateZ(t) {
    return this.translateOnAxis(Hv, t);
  }
  localToWorld(t) {
    return t.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t) {
    return t.applyMatrix4(Fr.copy(this.matrixWorld).invert());
  }
  lookAt(t, e, n) {
    t.isVector3 ? Su.copy(t) : Su.set(t, e, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      wl.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Fr.lookAt(wl, Su, this.up)
        : Fr.lookAt(Su, wl, this.up),
      this.quaternion.setFromRotationMatrix(Fr),
      i &&
        (Fr.extractRotation(i.matrixWorld),
        la.setFromRotationMatrix(Fr),
        this.quaternion.premultiply(la.invert()));
  }
  add(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
      return this;
    }
    return t === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          t
        ),
        this)
      : (t && t.isObject3D
          ? (t.parent !== null && t.parent.remove(t),
            (t.parent = this),
            this.children.push(t),
            t.dispatchEvent(QC))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              t
            ),
        this);
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const e = this.children.indexOf(t);
    return (
      e !== -1 &&
        ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(Vv)),
      this
    );
  }
  removeFromParent() {
    const t = this.parent;
    return t !== null && t.remove(this), this;
  }
  clear() {
    for (let t = 0; t < this.children.length; t++) {
      const e = this.children[t];
      (e.parent = null), e.dispatchEvent(Vv);
    }
    return (this.children.length = 0), this;
  }
  attach(t) {
    return (
      this.updateWorldMatrix(!0, !1),
      Fr.copy(this.matrixWorld).invert(),
      t.parent !== null &&
        (t.parent.updateWorldMatrix(!0, !1), Fr.multiply(t.parent.matrixWorld)),
      t.applyMatrix4(Fr),
      this.add(t),
      t.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(t) {
    return this.getObjectByProperty("id", t);
  }
  getObjectByName(t) {
    return this.getObjectByProperty("name", t);
  }
  getObjectByProperty(t, e) {
    if (this[t] === e) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const o = this.children[n].getObjectByProperty(t, e);
      if (o !== void 0) return o;
    }
  }
  getWorldPosition(t) {
    return (
      this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(t) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(wl, t, $C), t
    );
  }
  getWorldScale(t) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(wl, KC, t), t
    );
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {}
  traverse(t) {
    t(this);
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
  }
  traverseVisible(t) {
    if (this.visible === !1) return;
    t(this);
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
  }
  traverseAncestors(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || t) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (t = !0));
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
  }
  updateWorldMatrix(t, e) {
    const n = this.parent;
    if (
      (t === !0 && n !== null && n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      e === !0)
    ) {
      const i = this.children;
      for (let r = 0, o = i.length; r < o; r++) i[r].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string",
      n = {};
    e &&
      ((t = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
      }),
      (n.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON()));
    function r(l, u) {
      return l[u.uuid] === void 0 && (l[u.uuid] = u.toJSON(t)), u.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(t).uuid)),
        this.environment &&
          this.environment.isTexture &&
          (i.environment = this.environment.toJSON(t).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(t.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const u = l.shapes;
        if (Array.isArray(u))
          for (let h = 0, f = u.length; h < f; h++) {
            const m = u[h];
            r(t.shapes, m);
          }
        else r(t.shapes, u);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const l = [];
        for (let u = 0, h = this.material.length; u < h; u++)
          l.push(r(t.materials, this.material[u]));
        i.material = l;
      } else i.material = r(t.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let l = 0; l < this.children.length; l++)
        i.children.push(this.children[l].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const u = this.animations[l];
        i.animations.push(r(t.animations, u));
      }
    }
    if (e) {
      const l = o(t.geometries),
        u = o(t.materials),
        h = o(t.textures),
        f = o(t.images),
        m = o(t.shapes),
        g = o(t.skeletons),
        p = o(t.animations);
      l.length > 0 && (n.geometries = l),
        u.length > 0 && (n.materials = u),
        h.length > 0 && (n.textures = h),
        f.length > 0 && (n.images = f),
        m.length > 0 && (n.shapes = m),
        g.length > 0 && (n.skeletons = g),
        p.length > 0 && (n.animations = p);
    }
    return (n.object = i), n;
    function o(l) {
      const u = [];
      for (const h in l) {
        const f = l[h];
        delete f.metadata, u.push(f);
      }
      return u;
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, e = !0) {
    if (
      ((this.name = t.name),
      this.up.copy(t.up),
      this.position.copy(t.position),
      (this.rotation.order = t.rotation.order),
      this.quaternion.copy(t.quaternion),
      this.scale.copy(t.scale),
      this.matrix.copy(t.matrix),
      this.matrixWorld.copy(t.matrixWorld),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
      (this.layers.mask = t.layers.mask),
      (this.visible = t.visible),
      (this.castShadow = t.castShadow),
      (this.receiveShadow = t.receiveShadow),
      (this.frustumCulled = t.frustumCulled),
      (this.renderOrder = t.renderOrder),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      e === !0)
    )
      for (let n = 0; n < t.children.length; n++) {
        const i = t.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
Me.DefaultUp = new k(0, 1, 0);
Me.DefaultMatrixAutoUpdate = !0;
Me.prototype.isObject3D = !0;
const Yi = new k(),
  Or = new k(),
  Bd = new k(),
  Nr = new k(),
  ca = new k(),
  ua = new k(),
  Wv = new k(),
  zd = new k(),
  Ud = new k(),
  kd = new k();
class an {
  constructor(t = new k(), e = new k(), n = new k()) {
    (this.a = t), (this.b = e), (this.c = n);
  }
  static getNormal(t, e, n, i) {
    i.subVectors(n, e), Yi.subVectors(t, e), i.cross(Yi);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  }
  static getBarycoord(t, e, n, i, r) {
    Yi.subVectors(i, e), Or.subVectors(n, e), Bd.subVectors(t, e);
    const o = Yi.dot(Yi),
      l = Yi.dot(Or),
      u = Yi.dot(Bd),
      h = Or.dot(Or),
      f = Or.dot(Bd),
      m = o * h - l * l;
    if (m === 0) return r.set(-2, -1, -1);
    const g = 1 / m,
      p = (h * u - l * f) * g,
      v = (o * f - l * u) * g;
    return r.set(1 - p - v, v, p);
  }
  static containsPoint(t, e, n, i) {
    return (
      this.getBarycoord(t, e, n, i, Nr),
      Nr.x >= 0 && Nr.y >= 0 && Nr.x + Nr.y <= 1
    );
  }
  static getUV(t, e, n, i, r, o, l, u) {
    return (
      this.getBarycoord(t, e, n, i, Nr),
      u.set(0, 0),
      u.addScaledVector(r, Nr.x),
      u.addScaledVector(o, Nr.y),
      u.addScaledVector(l, Nr.z),
      u
    );
  }
  static isFrontFacing(t, e, n, i) {
    return Yi.subVectors(n, e), Or.subVectors(t, e), Yi.cross(Or).dot(i) < 0;
  }
  set(t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
  }
  setFromPointsAndIndices(t, e, n, i) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
  }
  setFromAttributeAndIndices(t, e, n, i) {
    return (
      this.a.fromBufferAttribute(t, e),
      this.b.fromBufferAttribute(t, n),
      this.c.fromBufferAttribute(t, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return (
      Yi.subVectors(this.c, this.b),
      Or.subVectors(this.a, this.b),
      Yi.cross(Or).length() * 0.5
    );
  }
  getMidpoint(t) {
    return t
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return an.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, e) {
    return an.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getUV(t, e, n, i, r) {
    return an.getUV(t, this.a, this.b, this.c, e, n, i, r);
  }
  containsPoint(t) {
    return an.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return an.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    const n = this.a,
      i = this.b,
      r = this.c;
    let o, l;
    ca.subVectors(i, n), ua.subVectors(r, n), zd.subVectors(t, n);
    const u = ca.dot(zd),
      h = ua.dot(zd);
    if (u <= 0 && h <= 0) return e.copy(n);
    Ud.subVectors(t, i);
    const f = ca.dot(Ud),
      m = ua.dot(Ud);
    if (f >= 0 && m <= f) return e.copy(i);
    const g = u * m - f * h;
    if (g <= 0 && u >= 0 && f <= 0)
      return (o = u / (u - f)), e.copy(n).addScaledVector(ca, o);
    kd.subVectors(t, r);
    const p = ca.dot(kd),
      v = ua.dot(kd);
    if (v >= 0 && p <= v) return e.copy(r);
    const x = p * h - u * v;
    if (x <= 0 && h >= 0 && v <= 0)
      return (l = h / (h - v)), e.copy(n).addScaledVector(ua, l);
    const b = f * v - p * m;
    if (b <= 0 && m - f >= 0 && p - v >= 0)
      return (
        Wv.subVectors(r, i),
        (l = (m - f) / (m - f + (p - v))),
        e.copy(i).addScaledVector(Wv, l)
      );
    const _ = 1 / (b + x + g);
    return (
      (o = x * _),
      (l = g * _),
      e.copy(n).addScaledVector(ca, o).addScaledVector(ua, l)
    );
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
}
let tR = 0;
class Rn extends $s {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: tR++ }),
      (this.uuid = sr()),
      (this.name = ""),
      (this.type = "Material"),
      (this.fog = !0),
      (this.blending = dl),
      (this.side = fl),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.format = kn),
      (this.transparent = !1),
      (this.blendSrc = uv),
      (this.blendDst = hv),
      (this.blendEquation = qo),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = pd),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = GC),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Sd),
      (this.stencilZFail = Sd),
      (this.stencilZPass = Sd),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (t !== void 0)
      for (const e in t) {
        const n = t[e];
        if (n === void 0) {
          console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          continue;
        }
        if (e === "shading") {
          console.warn(
            "THREE." +
              this.type +
              ": .shading has been removed. Use the boolean .flatShading instead."
          ),
            (this.flatShading = n === rv);
          continue;
        }
        const i = this[e];
        if (i === void 0) {
          console.warn(
            "THREE." +
              this.type +
              ": '" +
              e +
              "' is not a property of this material."
          );
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[e] = n);
      }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(t).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(t).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(t).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(t).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(t).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(t).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(t).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(t).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
      this.attenuationDistance !== void 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== dl && (n.blending = this.blending),
      this.side !== fl && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.format !== kn && (n.format = this.format),
      this.transparent === !0 && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.colorWrite = this.colorWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      this.rotation && this.rotation !== 0 && (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth && this.linewidth !== 1 && (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (n.premultipliedAlpha = this.premultipliedAlpha),
      this.wireframe === !0 && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = this.flatShading),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);
    function i(r) {
      const o = [];
      for (const l in r) {
        const u = r[l];
        delete u.metadata, o.push(u);
      }
      return o;
    }
    if (e) {
      const r = i(t.textures),
        o = i(t.images);
      r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    (this.name = t.name),
      (this.fog = t.fog),
      (this.blending = t.blending),
      (this.side = t.side),
      (this.vertexColors = t.vertexColors),
      (this.opacity = t.opacity),
      (this.format = t.format),
      (this.transparent = t.transparent),
      (this.blendSrc = t.blendSrc),
      (this.blendDst = t.blendDst),
      (this.blendEquation = t.blendEquation),
      (this.blendSrcAlpha = t.blendSrcAlpha),
      (this.blendDstAlpha = t.blendDstAlpha),
      (this.blendEquationAlpha = t.blendEquationAlpha),
      (this.depthFunc = t.depthFunc),
      (this.depthTest = t.depthTest),
      (this.depthWrite = t.depthWrite),
      (this.stencilWriteMask = t.stencilWriteMask),
      (this.stencilFunc = t.stencilFunc),
      (this.stencilRef = t.stencilRef),
      (this.stencilFuncMask = t.stencilFuncMask),
      (this.stencilFail = t.stencilFail),
      (this.stencilZFail = t.stencilZFail),
      (this.stencilZPass = t.stencilZPass),
      (this.stencilWrite = t.stencilWrite);
    const e = t.clippingPlanes;
    let n = null;
    if (e !== null) {
      const i = e.length;
      n = new Array(i);
      for (let r = 0; r !== i; ++r) n[r] = e[r].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = t.clipIntersection),
      (this.clipShadows = t.clipShadows),
      (this.shadowSide = t.shadowSide),
      (this.colorWrite = t.colorWrite),
      (this.precision = t.precision),
      (this.polygonOffset = t.polygonOffset),
      (this.polygonOffsetFactor = t.polygonOffsetFactor),
      (this.polygonOffsetUnits = t.polygonOffsetUnits),
      (this.dithering = t.dithering),
      (this.alphaTest = t.alphaTest),
      (this.alphaToCoverage = t.alphaToCoverage),
      (this.premultipliedAlpha = t.premultipliedAlpha),
      (this.visible = t.visible),
      (this.toneMapped = t.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(t.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
}
Rn.prototype.isMaterial = !0;
const Xv = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  qi = { h: 0, s: 0, l: 0 },
  Tu = { h: 0, s: 0, l: 0 };
function Gd(a, t, e) {
  return (
    e < 0 && (e += 1),
    e > 1 && (e -= 1),
    e < 1 / 6
      ? a + (t - a) * 6 * e
      : e < 1 / 2
      ? t
      : e < 2 / 3
      ? a + (t - a) * 6 * (2 / 3 - e)
      : a
  );
}
function Hd(a) {
  return a < 0.04045
    ? a * 0.0773993808
    : Math.pow(a * 0.9478672986 + 0.0521327014, 2.4);
}
function Vd(a) {
  return a < 0.0031308 ? a * 12.92 : 1.055 * Math.pow(a, 0.41666) - 0.055;
}
class Xt {
  constructor(t, e, n) {
    return e === void 0 && n === void 0 ? this.set(t) : this.setRGB(t, e, n);
  }
  set(t) {
    return (
      t && t.isColor
        ? this.copy(t)
        : typeof t == "number"
        ? this.setHex(t)
        : typeof t == "string" && this.setStyle(t),
      this
    );
  }
  setScalar(t) {
    return (this.r = t), (this.g = t), (this.b = t), this;
  }
  setHex(t) {
    return (
      (t = Math.floor(t)),
      (this.r = ((t >> 16) & 255) / 255),
      (this.g = ((t >> 8) & 255) / 255),
      (this.b = (t & 255) / 255),
      this
    );
  }
  setRGB(t, e, n) {
    return (this.r = t), (this.g = e), (this.b = n), this;
  }
  setHSL(t, e, n) {
    if (((t = VC(t, 1)), (e = pi(e, 0, 1)), (n = pi(n, 0, 1)), e === 0))
      this.r = this.g = this.b = n;
    else {
      const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
        r = 2 * n - i;
      (this.r = Gd(r, i, t + 1 / 3)),
        (this.g = Gd(r, i, t)),
        (this.b = Gd(r, i, t - 1 / 3));
    }
    return this;
  }
  setStyle(t) {
    function e(i) {
      i !== void 0 &&
        parseFloat(i) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + t + " will be ignored."
        );
    }
    let n;
    if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
      let i;
      const r = n[1],
        o = n[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (
            (i =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
              e(i[4]),
              this
            );
          if (
            (i =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
              e(i[4]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (i =
              /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          ) {
            const l = parseFloat(i[1]) / 360,
              u = parseInt(i[2], 10) / 100,
              h = parseInt(i[3], 10) / 100;
            return e(i[4]), this.setHSL(l, u, h);
          }
          break;
      }
    } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
      const i = n[1],
        r = i.length;
      if (r === 3)
        return (
          (this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255),
          (this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255),
          (this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255),
          this
        );
      if (r === 6)
        return (
          (this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255),
          (this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255),
          (this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255),
          this
        );
    }
    return t && t.length > 0 ? this.setColorName(t) : this;
  }
  setColorName(t) {
    const e = Xv[t.toLowerCase()];
    return (
      e !== void 0
        ? this.setHex(e)
        : console.warn("THREE.Color: Unknown color " + t),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
  }
  copyGammaToLinear(t, e = 2) {
    return (
      (this.r = Math.pow(t.r, e)),
      (this.g = Math.pow(t.g, e)),
      (this.b = Math.pow(t.b, e)),
      this
    );
  }
  copyLinearToGamma(t, e = 2) {
    const n = e > 0 ? 1 / e : 1;
    return (
      (this.r = Math.pow(t.r, n)),
      (this.g = Math.pow(t.g, n)),
      (this.b = Math.pow(t.b, n)),
      this
    );
  }
  convertGammaToLinear(t) {
    return this.copyGammaToLinear(this, t), this;
  }
  convertLinearToGamma(t) {
    return this.copyLinearToGamma(this, t), this;
  }
  copySRGBToLinear(t) {
    return (this.r = Hd(t.r)), (this.g = Hd(t.g)), (this.b = Hd(t.b)), this;
  }
  copyLinearToSRGB(t) {
    return (this.r = Vd(t.r)), (this.g = Vd(t.g)), (this.b = Vd(t.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return (
      ((this.r * 255) << 16) ^ ((this.g * 255) << 8) ^ ((this.b * 255) << 0)
    );
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(t) {
    const e = this.r,
      n = this.g,
      i = this.b,
      r = Math.max(e, n, i),
      o = Math.min(e, n, i);
    let l, u;
    const h = (o + r) / 2;
    if (o === r) (l = 0), (u = 0);
    else {
      const f = r - o;
      switch (((u = h <= 0.5 ? f / (r + o) : f / (2 - r - o)), r)) {
        case e:
          l = (n - i) / f + (n < i ? 6 : 0);
          break;
        case n:
          l = (i - e) / f + 2;
          break;
        case i:
          l = (e - n) / f + 4;
          break;
      }
      l /= 6;
    }
    return (t.h = l), (t.s = u), (t.l = h), t;
  }
  getStyle() {
    return (
      "rgb(" +
      ((this.r * 255) | 0) +
      "," +
      ((this.g * 255) | 0) +
      "," +
      ((this.b * 255) | 0) +
      ")"
    );
  }
  offsetHSL(t, e, n) {
    return (
      this.getHSL(qi),
      (qi.h += t),
      (qi.s += e),
      (qi.l += n),
      this.setHSL(qi.h, qi.s, qi.l),
      this
    );
  }
  add(t) {
    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
  }
  addColors(t, e) {
    return (
      (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
    );
  }
  addScalar(t) {
    return (this.r += t), (this.g += t), (this.b += t), this;
  }
  sub(t) {
    return (
      (this.r = Math.max(0, this.r - t.r)),
      (this.g = Math.max(0, this.g - t.g)),
      (this.b = Math.max(0, this.b - t.b)),
      this
    );
  }
  multiply(t) {
    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
  }
  multiplyScalar(t) {
    return (this.r *= t), (this.g *= t), (this.b *= t), this;
  }
  lerp(t, e) {
    return (
      (this.r += (t.r - this.r) * e),
      (this.g += (t.g - this.g) * e),
      (this.b += (t.b - this.b) * e),
      this
    );
  }
  lerpColors(t, e, n) {
    return (
      (this.r = t.r + (e.r - t.r) * n),
      (this.g = t.g + (e.g - t.g) * n),
      (this.b = t.b + (e.b - t.b) * n),
      this
    );
  }
  lerpHSL(t, e) {
    this.getHSL(qi), t.getHSL(Tu);
    const n = Ad(qi.h, Tu.h, e),
      i = Ad(qi.s, Tu.s, e),
      r = Ad(qi.l, Tu.l, e);
    return this.setHSL(n, i, r), this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
  }
  toArray(t = [], e = 0) {
    return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
  }
  fromBufferAttribute(t, e) {
    return (
      (this.r = t.getX(e)),
      (this.g = t.getY(e)),
      (this.b = t.getZ(e)),
      t.normalized === !0 &&
        ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
}
Xt.NAMES = Xv;
Xt.prototype.isColor = !0;
Xt.prototype.r = 1;
Xt.prototype.g = 1;
Xt.prototype.b = 1;
class Wd extends Rn {
  constructor(t) {
    super();
    (this.type = "MeshBasicMaterial"),
      (this.color = new Xt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = cu),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      this
    );
  }
}
Wd.prototype.isMeshBasicMaterial = !0;
const Ne = new k(),
  Eu = new Et();
class hn {
  constructor(t, e, n) {
    if (Array.isArray(t))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.name = ""),
      (this.array = t),
      (this.itemSize = e),
      (this.count = t !== void 0 ? t.length / e : 0),
      (this.normalized = n === !0),
      (this.usage = vl),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  setUsage(t) {
    return (this.usage = t), this;
  }
  copy(t) {
    return (
      (this.name = t.name),
      (this.array = new t.array.constructor(t.array)),
      (this.itemSize = t.itemSize),
      (this.count = t.count),
      (this.normalized = t.normalized),
      (this.usage = t.usage),
      this
    );
  }
  copyAt(t, e, n) {
    (t *= this.itemSize), (n *= e.itemSize);
    for (let i = 0, r = this.itemSize; i < r; i++)
      this.array[t + i] = e.array[n + i];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  copyColorsArray(t) {
    const e = this.array;
    let n = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      let o = t[i];
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyColorsArray(): color is undefined",
          i
        ),
        (o = new Xt())),
        (e[n++] = o.r),
        (e[n++] = o.g),
        (e[n++] = o.b);
    }
    return this;
  }
  copyVector2sArray(t) {
    const e = this.array;
    let n = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      let o = t[i];
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
          i
        ),
        (o = new Et())),
        (e[n++] = o.x),
        (e[n++] = o.y);
    }
    return this;
  }
  copyVector3sArray(t) {
    const e = this.array;
    let n = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      let o = t[i];
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
          i
        ),
        (o = new k())),
        (e[n++] = o.x),
        (e[n++] = o.y),
        (e[n++] = o.z);
    }
    return this;
  }
  copyVector4sArray(t) {
    const e = this.array;
    let n = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      let o = t[i];
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
          i
        ),
        (o = new Fe())),
        (e[n++] = o.x),
        (e[n++] = o.y),
        (e[n++] = o.z),
        (e[n++] = o.w);
    }
    return this;
  }
  applyMatrix3(t) {
    if (this.itemSize === 2)
      for (let e = 0, n = this.count; e < n; e++)
        Eu.fromBufferAttribute(this, e),
          Eu.applyMatrix3(t),
          this.setXY(e, Eu.x, Eu.y);
    else if (this.itemSize === 3)
      for (let e = 0, n = this.count; e < n; e++)
        Ne.fromBufferAttribute(this, e),
          Ne.applyMatrix3(t),
          this.setXYZ(e, Ne.x, Ne.y, Ne.z);
    return this;
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.count; e < n; e++)
      (Ne.x = this.getX(e)),
        (Ne.y = this.getY(e)),
        (Ne.z = this.getZ(e)),
        Ne.applyMatrix4(t),
        this.setXYZ(e, Ne.x, Ne.y, Ne.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      (Ne.x = this.getX(e)),
        (Ne.y = this.getY(e)),
        (Ne.z = this.getZ(e)),
        Ne.applyNormalMatrix(t),
        this.setXYZ(e, Ne.x, Ne.y, Ne.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      (Ne.x = this.getX(e)),
        (Ne.y = this.getY(e)),
        (Ne.z = this.getZ(e)),
        Ne.transformDirection(t),
        this.setXYZ(e, Ne.x, Ne.y, Ne.z);
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  getX(t) {
    return this.array[t * this.itemSize];
  }
  setX(t, e) {
    return (this.array[t * this.itemSize] = e), this;
  }
  getY(t) {
    return this.array[t * this.itemSize + 1];
  }
  setY(t, e) {
    return (this.array[t * this.itemSize + 1] = e), this;
  }
  getZ(t) {
    return this.array[t * this.itemSize + 2];
  }
  setZ(t, e) {
    return (this.array[t * this.itemSize + 2] = e), this;
  }
  getW(t) {
    return this.array[t * this.itemSize + 3];
  }
  setW(t, e) {
    return (this.array[t * this.itemSize + 3] = e), this;
  }
  setXY(t, e, n) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      this
    );
  }
  setXYZ(t, e, n, i) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = i),
      this
    );
  }
  setXYZW(t, e, n, i, r) {
    return (
      (t *= this.itemSize),
      (this.array[t + 0] = e),
      (this.array[t + 1] = n),
      (this.array[t + 2] = i),
      (this.array[t + 3] = r),
      this
    );
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (t.name = this.name),
      this.usage !== vl && (t.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (t.updateRange = this.updateRange),
      t
    );
  }
}
hn.prototype.isBufferAttribute = !0;
class Yv extends hn {
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n);
  }
}
class qv extends hn {
  constructor(t, e, n) {
    super(new Uint32Array(t), e, n);
  }
}
class eR extends hn {
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n);
  }
}
eR.prototype.isFloat16BufferAttribute = !0;
class en extends hn {
  constructor(t, e, n) {
    super(new Float32Array(t), e, n);
  }
}
let nR = 0;
const Ni = new Jt(),
  Xd = new Me(),
  ha = new k(),
  gi = new Wi(),
  bl = new Wi(),
  gn = new k();
class Ge extends $s {
  constructor() {
    super();
    Object.defineProperty(this, "id", { value: nR++ }),
      (this.uuid = sr()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return (
      Array.isArray(t)
        ? (this.index = new (Pv(t) > 65535 ? qv : Yv)(t, 1))
        : (this.index = t),
      this
    );
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, e) {
    return (this.attributes[t] = e), this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0;
  }
  addGroup(t, e, n = 0) {
    this.groups.push({ start: t, count: e, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, e) {
    (this.drawRange.start = t), (this.drawRange.count = e);
  }
  applyMatrix4(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), (e.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new Mn().getNormalMatrix(t);
      n.applyNormalMatrix(r), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(t), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(t) {
    return Ni.makeRotationFromQuaternion(t), this.applyMatrix4(Ni), this;
  }
  rotateX(t) {
    return Ni.makeRotationX(t), this.applyMatrix4(Ni), this;
  }
  rotateY(t) {
    return Ni.makeRotationY(t), this.applyMatrix4(Ni), this;
  }
  rotateZ(t) {
    return Ni.makeRotationZ(t), this.applyMatrix4(Ni), this;
  }
  translate(t, e, n) {
    return Ni.makeTranslation(t, e, n), this.applyMatrix4(Ni), this;
  }
  scale(t, e, n) {
    return Ni.makeScale(t, e, n), this.applyMatrix4(Ni), this;
  }
  lookAt(t) {
    return Xd.lookAt(t), Xd.updateMatrix(), this.applyMatrix4(Xd.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(ha).negate(),
      this.translate(ha.x, ha.y, ha.z),
      this
    );
  }
  setFromPoints(t) {
    const e = [];
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      e.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new en(e, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Wi());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new k(-1 / 0, -1 / 0, -1 / 0),
          new k(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (t !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(t), e))
        for (let n = 0, i = e.length; n < i; n++) {
          const r = e[n];
          gi.setFromBufferAttribute(r),
            this.morphTargetsRelative
              ? (gn.addVectors(this.boundingBox.min, gi.min),
                this.boundingBox.expandByPoint(gn),
                gn.addVectors(this.boundingBox.max, gi.max),
                this.boundingBox.expandByPoint(gn))
              : (this.boundingBox.expandByPoint(gi.min),
                this.boundingBox.expandByPoint(gi.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new sa());
    const t = this.attributes.position,
      e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new k(), 1 / 0);
      return;
    }
    if (t) {
      const n = this.boundingSphere.center;
      if ((gi.setFromBufferAttribute(t), e))
        for (let r = 0, o = e.length; r < o; r++) {
          const l = e[r];
          bl.setFromBufferAttribute(l),
            this.morphTargetsRelative
              ? (gn.addVectors(gi.min, bl.min),
                gi.expandByPoint(gn),
                gn.addVectors(gi.max, bl.max),
                gi.expandByPoint(gn))
              : (gi.expandByPoint(bl.min), gi.expandByPoint(bl.max));
        }
      gi.getCenter(n);
      let i = 0;
      for (let r = 0, o = t.count; r < o; r++)
        gn.fromBufferAttribute(t, r),
          (i = Math.max(i, n.distanceToSquared(gn)));
      if (e)
        for (let r = 0, o = e.length; r < o; r++) {
          const l = e[r],
            u = this.morphTargetsRelative;
          for (let h = 0, f = l.count; h < f; h++)
            gn.fromBufferAttribute(l, h),
              u && (ha.fromBufferAttribute(t, h), gn.add(ha)),
              (i = Math.max(i, n.distanceToSquared(gn)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const t = this.index,
      e = this.attributes;
    if (
      t === null ||
      e.position === void 0 ||
      e.normal === void 0 ||
      e.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const n = t.array,
      i = e.position.array,
      r = e.normal.array,
      o = e.uv.array,
      l = i.length / 3;
    e.tangent === void 0 &&
      this.setAttribute("tangent", new hn(new Float32Array(4 * l), 4));
    const u = e.tangent.array,
      h = [],
      f = [];
    for (let H = 0; H < l; H++) (h[H] = new k()), (f[H] = new k());
    const m = new k(),
      g = new k(),
      p = new k(),
      v = new Et(),
      x = new Et(),
      b = new Et(),
      _ = new k(),
      y = new k();
    function E(H, O, it) {
      m.fromArray(i, H * 3),
        g.fromArray(i, O * 3),
        p.fromArray(i, it * 3),
        v.fromArray(o, H * 2),
        x.fromArray(o, O * 2),
        b.fromArray(o, it * 2),
        g.sub(m),
        p.sub(m),
        x.sub(v),
        b.sub(v);
      const W = 1 / (x.x * b.y - b.x * x.y);
      !isFinite(W) ||
        (_.copy(g)
          .multiplyScalar(b.y)
          .addScaledVector(p, -x.y)
          .multiplyScalar(W),
        y
          .copy(p)
          .multiplyScalar(x.x)
          .addScaledVector(g, -b.x)
          .multiplyScalar(W),
        h[H].add(_),
        h[O].add(_),
        h[it].add(_),
        f[H].add(y),
        f[O].add(y),
        f[it].add(y));
    }
    let M = this.groups;
    M.length === 0 && (M = [{ start: 0, count: n.length }]);
    for (let H = 0, O = M.length; H < O; ++H) {
      const it = M[H],
        W = it.start,
        q = it.count;
      for (let tt = W, V = W + q; tt < V; tt += 3)
        E(n[tt + 0], n[tt + 1], n[tt + 2]);
    }
    const A = new k(),
      R = new k(),
      T = new k(),
      B = new k();
    function X(H) {
      T.fromArray(r, H * 3), B.copy(T);
      const O = h[H];
      A.copy(O),
        A.sub(T.multiplyScalar(T.dot(O))).normalize(),
        R.crossVectors(B, O);
      const W = R.dot(f[H]) < 0 ? -1 : 1;
      (u[H * 4] = A.x),
        (u[H * 4 + 1] = A.y),
        (u[H * 4 + 2] = A.z),
        (u[H * 4 + 3] = W);
    }
    for (let H = 0, O = M.length; H < O; ++H) {
      const it = M[H],
        W = it.start,
        q = it.count;
      for (let tt = W, V = W + q; tt < V; tt += 3)
        X(n[tt + 0]), X(n[tt + 1]), X(n[tt + 2]);
    }
  }
  computeVertexNormals() {
    const t = this.index,
      e = this.getAttribute("position");
    if (e !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new hn(new Float32Array(e.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let g = 0, p = n.count; g < p; g++) n.setXYZ(g, 0, 0, 0);
      const i = new k(),
        r = new k(),
        o = new k(),
        l = new k(),
        u = new k(),
        h = new k(),
        f = new k(),
        m = new k();
      if (t)
        for (let g = 0, p = t.count; g < p; g += 3) {
          const v = t.getX(g + 0),
            x = t.getX(g + 1),
            b = t.getX(g + 2);
          i.fromBufferAttribute(e, v),
            r.fromBufferAttribute(e, x),
            o.fromBufferAttribute(e, b),
            f.subVectors(o, r),
            m.subVectors(i, r),
            f.cross(m),
            l.fromBufferAttribute(n, v),
            u.fromBufferAttribute(n, x),
            h.fromBufferAttribute(n, b),
            l.add(f),
            u.add(f),
            h.add(f),
            n.setXYZ(v, l.x, l.y, l.z),
            n.setXYZ(x, u.x, u.y, u.z),
            n.setXYZ(b, h.x, h.y, h.z);
        }
      else
        for (let g = 0, p = e.count; g < p; g += 3)
          i.fromBufferAttribute(e, g + 0),
            r.fromBufferAttribute(e, g + 1),
            o.fromBufferAttribute(e, g + 2),
            f.subVectors(o, r),
            m.subVectors(i, r),
            f.cross(m),
            n.setXYZ(g + 0, f.x, f.y, f.z),
            n.setXYZ(g + 1, f.x, f.y, f.z),
            n.setXYZ(g + 2, f.x, f.y, f.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  merge(t, e) {
    if (!(t && t.isBufferGeometry)) {
      console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
        t
      );
      return;
    }
    e === void 0 &&
      ((e = 0),
      console.warn(
        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
      ));
    const n = this.attributes;
    for (const i in n) {
      if (t.attributes[i] === void 0) continue;
      const o = n[i].array,
        l = t.attributes[i],
        u = l.array,
        h = l.itemSize * e,
        f = Math.min(u.length, o.length - h);
      for (let m = 0, g = h; m < f; m++, g++) o[g] = u[m];
    }
    return this;
  }
  normalizeNormals() {
    const t = this.attributes.normal;
    for (let e = 0, n = t.count; e < n; e++)
      gn.fromBufferAttribute(t, e),
        gn.normalize(),
        t.setXYZ(e, gn.x, gn.y, gn.z);
  }
  toNonIndexed() {
    function t(l, u) {
      const h = l.array,
        f = l.itemSize,
        m = l.normalized,
        g = new h.constructor(u.length * f);
      let p = 0,
        v = 0;
      for (let x = 0, b = u.length; x < b; x++) {
        l.isInterleavedBufferAttribute
          ? (p = u[x] * l.data.stride + l.offset)
          : (p = u[x] * f);
        for (let _ = 0; _ < f; _++) g[v++] = h[p++];
      }
      return new hn(g, f, m);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const e = new Ge(),
      n = this.index.array,
      i = this.attributes;
    for (const l in i) {
      const u = i[l],
        h = t(u, n);
      e.setAttribute(l, h);
    }
    const r = this.morphAttributes;
    for (const l in r) {
      const u = [],
        h = r[l];
      for (let f = 0, m = h.length; f < m; f++) {
        const g = h[f],
          p = t(g, n);
        u.push(p);
      }
      e.morphAttributes[l] = u;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let l = 0, u = o.length; l < u; l++) {
      const h = o[l];
      e.addGroup(h.start, h.count, h.materialIndex);
    }
    return e;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((t.uuid = this.uuid),
      (t.type = this.type),
      this.name !== "" && (t.name = this.name),
      Object.keys(this.userData).length > 0 && (t.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const u = this.parameters;
      for (const h in u) u[h] !== void 0 && (t[h] = u[h]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null &&
      (t.data.index = {
        type: e.array.constructor.name,
        array: Array.prototype.slice.call(e.array),
      });
    const n = this.attributes;
    for (const u in n) {
      const h = n[u];
      t.data.attributes[u] = h.toJSON(t.data);
    }
    const i = {};
    let r = !1;
    for (const u in this.morphAttributes) {
      const h = this.morphAttributes[u],
        f = [];
      for (let m = 0, g = h.length; m < g; m++) {
        const p = h[m];
        f.push(p.toJSON(t.data));
      }
      f.length > 0 && ((i[u] = f), (r = !0));
    }
    r &&
      ((t.data.morphAttributes = i),
      (t.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
    const l = this.boundingSphere;
    return (
      l !== null &&
        (t.data.boundingSphere = {
          center: l.center.toArray(),
          radius: l.radius,
        }),
      t
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const e = {};
    this.name = t.name;
    const n = t.index;
    n !== null && this.setIndex(n.clone(e));
    const i = t.attributes;
    for (const h in i) {
      const f = i[h];
      this.setAttribute(h, f.clone(e));
    }
    const r = t.morphAttributes;
    for (const h in r) {
      const f = [],
        m = r[h];
      for (let g = 0, p = m.length; g < p; g++) f.push(m[g].clone(e));
      this.morphAttributes[h] = f;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const o = t.groups;
    for (let h = 0, f = o.length; h < f; h++) {
      const m = o[h];
      this.addGroup(m.start, m.count, m.materialIndex);
    }
    const l = t.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const u = t.boundingSphere;
    return (
      u !== null && (this.boundingSphere = u.clone()),
      (this.drawRange.start = t.drawRange.start),
      (this.drawRange.count = t.drawRange.count),
      (this.userData = t.userData),
      t.parameters !== void 0 &&
        (this.parameters = Object.assign({}, t.parameters)),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
Ge.prototype.isBufferGeometry = !0;
const Zv = new Jt(),
  fa = new to(),
  Yd = new sa(),
  gs = new k(),
  _s = new k(),
  vs = new k(),
  qd = new k(),
  Zd = new k(),
  jd = new k(),
  Au = new k(),
  Lu = new k(),
  Cu = new k(),
  Ru = new Et(),
  Pu = new Et(),
  Iu = new Et(),
  Jd = new k(),
  Du = new k();
class ti extends Me {
  constructor(t = new Ge(), e = new Wd()) {
    super();
    (this.type = "Mesh"),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets();
  }
  copy(t) {
    return (
      super.copy(t),
      t.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
      t.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          t.morphTargetDictionary
        )),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e);
      if (n.length > 0) {
        const i = e[n[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, o = i.length; r < o; r++) {
            const l = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[l] = r);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 &&
        e.length > 0 &&
        console.error(
          "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.material,
      r = this.matrixWorld;
    if (
      i === void 0 ||
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Yd.copy(n.boundingSphere),
      Yd.applyMatrix4(r),
      t.ray.intersectsSphere(Yd) === !1) ||
      (Zv.copy(r).invert(),
      fa.copy(t.ray).applyMatrix4(Zv),
      n.boundingBox !== null && fa.intersectsBox(n.boundingBox) === !1)
    )
      return;
    let o;
    if (n.isBufferGeometry) {
      const l = n.index,
        u = n.attributes.position,
        h = n.morphAttributes.position,
        f = n.morphTargetsRelative,
        m = n.attributes.uv,
        g = n.attributes.uv2,
        p = n.groups,
        v = n.drawRange;
      if (l !== null)
        if (Array.isArray(i))
          for (let x = 0, b = p.length; x < b; x++) {
            const _ = p[x],
              y = i[_.materialIndex],
              E = Math.max(_.start, v.start),
              M = Math.min(
                l.count,
                Math.min(_.start + _.count, v.start + v.count)
              );
            for (let A = E, R = M; A < R; A += 3) {
              const T = l.getX(A),
                B = l.getX(A + 1),
                X = l.getX(A + 2);
              (o = Fu(this, y, t, fa, u, h, f, m, g, T, B, X)),
                o &&
                  ((o.faceIndex = Math.floor(A / 3)),
                  (o.face.materialIndex = _.materialIndex),
                  e.push(o));
            }
          }
        else {
          const x = Math.max(0, v.start),
            b = Math.min(l.count, v.start + v.count);
          for (let _ = x, y = b; _ < y; _ += 3) {
            const E = l.getX(_),
              M = l.getX(_ + 1),
              A = l.getX(_ + 2);
            (o = Fu(this, i, t, fa, u, h, f, m, g, E, M, A)),
              o && ((o.faceIndex = Math.floor(_ / 3)), e.push(o));
          }
        }
      else if (u !== void 0)
        if (Array.isArray(i))
          for (let x = 0, b = p.length; x < b; x++) {
            const _ = p[x],
              y = i[_.materialIndex],
              E = Math.max(_.start, v.start),
              M = Math.min(
                u.count,
                Math.min(_.start + _.count, v.start + v.count)
              );
            for (let A = E, R = M; A < R; A += 3) {
              const T = A,
                B = A + 1,
                X = A + 2;
              (o = Fu(this, y, t, fa, u, h, f, m, g, T, B, X)),
                o &&
                  ((o.faceIndex = Math.floor(A / 3)),
                  (o.face.materialIndex = _.materialIndex),
                  e.push(o));
            }
          }
        else {
          const x = Math.max(0, v.start),
            b = Math.min(u.count, v.start + v.count);
          for (let _ = x, y = b; _ < y; _ += 3) {
            const E = _,
              M = _ + 1,
              A = _ + 2;
            (o = Fu(this, i, t, fa, u, h, f, m, g, E, M, A)),
              o && ((o.faceIndex = Math.floor(_ / 3)), e.push(o));
          }
        }
    } else
      n.isGeometry &&
        console.error(
          "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
  }
}
ti.prototype.isMesh = !0;
function iR(a, t, e, n, i, r, o, l) {
  let u;
  if (
    (t.side === un
      ? (u = n.intersectTriangle(o, r, i, !0, l))
      : (u = n.intersectTriangle(i, r, o, t.side !== Yo, l)),
    u === null)
  )
    return null;
  Du.copy(l), Du.applyMatrix4(a.matrixWorld);
  const h = e.ray.origin.distanceTo(Du);
  return h < e.near || h > e.far
    ? null
    : { distance: h, point: Du.clone(), object: a };
}
function Fu(a, t, e, n, i, r, o, l, u, h, f, m) {
  gs.fromBufferAttribute(i, h),
    _s.fromBufferAttribute(i, f),
    vs.fromBufferAttribute(i, m);
  const g = a.morphTargetInfluences;
  if (r && g) {
    Au.set(0, 0, 0), Lu.set(0, 0, 0), Cu.set(0, 0, 0);
    for (let v = 0, x = r.length; v < x; v++) {
      const b = g[v],
        _ = r[v];
      b !== 0 &&
        (qd.fromBufferAttribute(_, h),
        Zd.fromBufferAttribute(_, f),
        jd.fromBufferAttribute(_, m),
        o
          ? (Au.addScaledVector(qd, b),
            Lu.addScaledVector(Zd, b),
            Cu.addScaledVector(jd, b))
          : (Au.addScaledVector(qd.sub(gs), b),
            Lu.addScaledVector(Zd.sub(_s), b),
            Cu.addScaledVector(jd.sub(vs), b)));
    }
    gs.add(Au), _s.add(Lu), vs.add(Cu);
  }
  a.isSkinnedMesh &&
    (a.boneTransform(h, gs), a.boneTransform(f, _s), a.boneTransform(m, vs));
  const p = iR(a, t, e, n, gs, _s, vs, Jd);
  if (p) {
    l &&
      (Ru.fromBufferAttribute(l, h),
      Pu.fromBufferAttribute(l, f),
      Iu.fromBufferAttribute(l, m),
      (p.uv = an.getUV(Jd, gs, _s, vs, Ru, Pu, Iu, new Et()))),
      u &&
        (Ru.fromBufferAttribute(u, h),
        Pu.fromBufferAttribute(u, f),
        Iu.fromBufferAttribute(u, m),
        (p.uv2 = an.getUV(Jd, gs, _s, vs, Ru, Pu, Iu, new Et())));
    const v = { a: h, b: f, c: m, normal: new k(), materialIndex: 0 };
    an.getNormal(gs, _s, vs, v.normal), (p.face = v);
  }
  return p;
}
class Ml extends Ge {
  constructor(t = 1, e = 1, n = 1, i = 1, r = 1, o = 1) {
    super();
    (this.type = "BoxGeometry"),
      (this.parameters = {
        width: t,
        height: e,
        depth: n,
        widthSegments: i,
        heightSegments: r,
        depthSegments: o,
      });
    const l = this;
    (i = Math.floor(i)), (r = Math.floor(r)), (o = Math.floor(o));
    const u = [],
      h = [],
      f = [],
      m = [];
    let g = 0,
      p = 0;
    v("z", "y", "x", -1, -1, n, e, t, o, r, 0),
      v("z", "y", "x", 1, -1, n, e, -t, o, r, 1),
      v("x", "z", "y", 1, 1, t, n, e, i, o, 2),
      v("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
      v("x", "y", "z", 1, -1, t, e, n, i, r, 4),
      v("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
      this.setIndex(u),
      this.setAttribute("position", new en(h, 3)),
      this.setAttribute("normal", new en(f, 3)),
      this.setAttribute("uv", new en(m, 2));
    function v(x, b, _, y, E, M, A, R, T, B, X) {
      const H = M / T,
        O = A / B,
        it = M / 2,
        W = A / 2,
        q = R / 2,
        tt = T + 1,
        V = B + 1;
      let Q = 0,
        st = 0;
      const Lt = new k();
      for (let J = 0; J < V; J++) {
        const vt = J * O - W;
        for (let zt = 0; zt < tt; zt++) {
          const ft = zt * H - it;
          (Lt[x] = ft * y),
            (Lt[b] = vt * E),
            (Lt[_] = q),
            h.push(Lt.x, Lt.y, Lt.z),
            (Lt[x] = 0),
            (Lt[b] = 0),
            (Lt[_] = R > 0 ? 1 : -1),
            f.push(Lt.x, Lt.y, Lt.z),
            m.push(zt / T),
            m.push(1 - J / B),
            (Q += 1);
        }
      }
      for (let J = 0; J < B; J++)
        for (let vt = 0; vt < T; vt++) {
          const zt = g + vt + tt * J,
            ft = g + vt + tt * (J + 1),
            Mt = g + (vt + 1) + tt * (J + 1),
            Tt = g + (vt + 1) + tt * J;
          u.push(zt, ft, Tt), u.push(ft, Mt, Tt), (st += 6);
        }
      l.addGroup(p, st, X), (p += st), (g += Q);
    }
  }
  static fromJSON(t) {
    return new Ml(
      t.width,
      t.height,
      t.depth,
      t.widthSegments,
      t.heightSegments,
      t.depthSegments
    );
  }
}
function da(a) {
  const t = {};
  for (const e in a) {
    t[e] = {};
    for (const n in a[e]) {
      const i = a[e][n];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? (t[e][n] = i.clone())
        : Array.isArray(i)
        ? (t[e][n] = i.slice())
        : (t[e][n] = i);
    }
  }
  return t;
}
function Pn(a) {
  const t = {};
  for (let e = 0; e < a.length; e++) {
    const n = da(a[e]);
    for (const i in n) t[i] = n[i];
  }
  return t;
}
const rR = { clone: da, merge: Pn };
var sR = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  oR = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class eo extends Rn {
  constructor(t) {
    super();
    (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader = sR),
      (this.fragmentShader = oR),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      t !== void 0 &&
        (t.attributes !== void 0 &&
          console.error(
            "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
          ),
        this.setValues(t));
  }
  copy(t) {
    return (
      super.copy(t),
      (this.fragmentShader = t.fragmentShader),
      (this.vertexShader = t.vertexShader),
      (this.uniforms = da(t.uniforms)),
      (this.defines = Object.assign({}, t.defines)),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.lights = t.lights),
      (this.clipping = t.clipping),
      (this.extensions = Object.assign({}, t.extensions)),
      (this.glslVersion = t.glslVersion),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    (e.glslVersion = this.glslVersion), (e.uniforms = {});
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture
        ? (e.uniforms[i] = { type: "t", value: o.toJSON(t).uuid })
        : o && o.isColor
        ? (e.uniforms[i] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (e.uniforms[i] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (e.uniforms[i] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (e.uniforms[i] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (e.uniforms[i] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (e.uniforms[i] = { type: "m4", value: o.toArray() })
        : (e.uniforms[i] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines),
      (e.vertexShader = this.vertexShader),
      (e.fragmentShader = this.fragmentShader);
    const n = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (e.extensions = n), e;
  }
}
eo.prototype.isShaderMaterial = !0;
class $d extends Me {
  constructor() {
    super();
    (this.type = "Camera"),
      (this.matrixWorldInverse = new Jt()),
      (this.projectionMatrix = new Jt()),
      (this.projectionMatrixInverse = new Jt());
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      this.matrixWorldInverse.copy(t.matrixWorldInverse),
      this.projectionMatrix.copy(t.projectionMatrix),
      this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
      this
    );
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(-e[8], -e[9], -e[10]).normalize();
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
$d.prototype.isCamera = !0;
class ei extends $d {
  constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
    super();
    (this.type = "PerspectiveCamera"),
      (this.fov = t),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = e),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.fov = t.fov),
      (this.zoom = t.zoom),
      (this.near = t.near),
      (this.far = t.far),
      (this.focus = t.focus),
      (this.aspect = t.aspect),
      (this.view = t.view === null ? null : Object.assign({}, t.view)),
      (this.filmGauge = t.filmGauge),
      (this.filmOffset = t.filmOffset),
      this
    );
  }
  setFocalLength(t) {
    const e = (0.5 * this.getFilmHeight()) / t;
    (this.fov = Ed * 2 * Math.atan(e)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const t = Math.tan(Td * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / t;
  }
  getEffectiveFOV() {
    return Ed * 2 * Math.atan(Math.tan(Td * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(t, e, n, i, r, o) {
    (this.aspect = t / e),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = this.near;
    let e = (t * Math.tan(Td * 0.5 * this.fov)) / this.zoom,
      n = 2 * e,
      i = this.aspect * n,
      r = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = o.fullWidth,
        h = o.fullHeight;
      (r += (o.offsetX * i) / u),
        (e -= (o.offsetY * n) / h),
        (i *= o.width / u),
        (n *= o.height / h);
    }
    const l = this.filmOffset;
    l !== 0 && (r += (t * l) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.fov = this.fov),
      (e.object.zoom = this.zoom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      (e.object.focus = this.focus),
      (e.object.aspect = this.aspect),
      this.view !== null && (e.object.view = Object.assign({}, this.view)),
      (e.object.filmGauge = this.filmGauge),
      (e.object.filmOffset = this.filmOffset),
      e
    );
  }
}
ei.prototype.isPerspectiveCamera = !0;
const pa = 90,
  ma = 1;
class Kd extends Me {
  constructor(t, e, n) {
    super();
    if (((this.type = "CubeCamera"), n.isWebGLCubeRenderTarget !== !0)) {
      console.error(
        "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
      );
      return;
    }
    this.renderTarget = n;
    const i = new ei(pa, ma, t, e);
    (i.layers = this.layers),
      i.up.set(0, -1, 0),
      i.lookAt(new k(1, 0, 0)),
      this.add(i);
    const r = new ei(pa, ma, t, e);
    (r.layers = this.layers),
      r.up.set(0, -1, 0),
      r.lookAt(new k(-1, 0, 0)),
      this.add(r);
    const o = new ei(pa, ma, t, e);
    (o.layers = this.layers),
      o.up.set(0, 0, 1),
      o.lookAt(new k(0, 1, 0)),
      this.add(o);
    const l = new ei(pa, ma, t, e);
    (l.layers = this.layers),
      l.up.set(0, 0, -1),
      l.lookAt(new k(0, -1, 0)),
      this.add(l);
    const u = new ei(pa, ma, t, e);
    (u.layers = this.layers),
      u.up.set(0, -1, 0),
      u.lookAt(new k(0, 0, 1)),
      this.add(u);
    const h = new ei(pa, ma, t, e);
    (h.layers = this.layers),
      h.up.set(0, -1, 0),
      h.lookAt(new k(0, 0, -1)),
      this.add(h);
  }
  update(t, e) {
    this.parent === null && this.updateMatrixWorld();
    const n = this.renderTarget,
      [i, r, o, l, u, h] = this.children,
      f = t.xr.enabled,
      m = t.getRenderTarget();
    t.xr.enabled = !1;
    const g = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      t.setRenderTarget(n, 0),
      t.render(e, i),
      t.setRenderTarget(n, 1),
      t.render(e, r),
      t.setRenderTarget(n, 2),
      t.render(e, o),
      t.setRenderTarget(n, 3),
      t.render(e, l),
      t.setRenderTarget(n, 4),
      t.render(e, u),
      (n.texture.generateMipmaps = g),
      t.setRenderTarget(n, 5),
      t.render(e, h),
      t.setRenderTarget(m),
      (t.xr.enabled = f);
  }
}
class Ou extends Sn {
  constructor(t, e, n, i, r, o, l, u, h, f) {
    (t = t !== void 0 ? t : []), (e = e !== void 0 ? e : pl);
    super(t, e, n, i, r, o, l, u, h, f);
    this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(t) {
    this.image = t;
  }
}
Ou.prototype.isCubeTexture = !0;
class jv extends or {
  constructor(t, e, n) {
    Number.isInteger(e) &&
      (console.warn(
        "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
      ),
      (e = n));
    super(t, t, e);
    (e = e || {}),
      (this.texture = new Ou(
        void 0,
        e.mapping,
        e.wrapS,
        e.wrapT,
        e.magFilter,
        e.minFilter,
        e.format,
        e.type,
        e.anisotropy,
        e.encoding
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        e.generateMipmaps !== void 0 ? e.generateMipmaps : !1),
      (this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : Oi),
      (this.texture._needsFlipEnvMap = !1);
  }
  fromEquirectangularTexture(t, e) {
    (this.texture.type = e.type),
      (this.texture.format = kn),
      (this.texture.encoding = e.encoding),
      (this.texture.generateMipmaps = e.generateMipmaps),
      (this.texture.minFilter = e.minFilter),
      (this.texture.magFilter = e.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new Ml(5, 5, 5),
      r = new eo({
        name: "CubemapFromEquirect",
        uniforms: da(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: un,
        blending: cs,
      });
    r.uniforms.tEquirect.value = e;
    const o = new ti(i, r),
      l = e.minFilter;
    return (
      e.minFilter === hu && (e.minFilter = Oi),
      new Kd(1, 10, this).update(t, o),
      (e.minFilter = l),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(t, e, n, i) {
    const r = t.getRenderTarget();
    for (let o = 0; o < 6; o++) t.setRenderTarget(this, o), t.clear(e, n, i);
    t.setRenderTarget(r);
  }
}
jv.prototype.isWebGLCubeRenderTarget = !0;
const Qd = new k(),
  aR = new k(),
  lR = new Mn();
class Br {
  constructor(t = new k(1, 0, 0), e = 0) {
    (this.normal = t), (this.constant = e);
  }
  set(t, e) {
    return this.normal.copy(t), (this.constant = e), this;
  }
  setComponents(t, e, n, i) {
    return this.normal.set(t, e, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
  }
  setFromCoplanarPoints(t, e, n) {
    const i = Qd.subVectors(n, e).cross(aR.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, t), this;
  }
  copy(t) {
    return this.normal.copy(t.normal), (this.constant = t.constant), this;
  }
  normalize() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), (this.constant *= t), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
  }
  intersectLine(t, e) {
    const n = t.delta(Qd),
      i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
    const r = -(t.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? null : e.copy(n).multiplyScalar(r).add(t.start);
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start),
      n = this.distanceToPoint(t.end);
    return (e < 0 && n > 0) || (n < 0 && e > 0);
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t, e) {
    const n = e || lR.getNormalMatrix(t),
      i = this.coplanarPoint(Qd).applyMatrix4(t),
      r = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(r)), this;
  }
  translate(t) {
    return (this.constant -= t.dot(this.normal)), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Br.prototype.isPlane = !0;
const ga = new sa(),
  Nu = new k();
class Bu {
  constructor(
    t = new Br(),
    e = new Br(),
    n = new Br(),
    i = new Br(),
    r = new Br(),
    o = new Br()
  ) {
    this.planes = [t, e, n, i, r, o];
  }
  set(t, e, n, i, r, o) {
    const l = this.planes;
    return (
      l[0].copy(t),
      l[1].copy(e),
      l[2].copy(n),
      l[3].copy(i),
      l[4].copy(r),
      l[5].copy(o),
      this
    );
  }
  copy(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
    return this;
  }
  setFromProjectionMatrix(t) {
    const e = this.planes,
      n = t.elements,
      i = n[0],
      r = n[1],
      o = n[2],
      l = n[3],
      u = n[4],
      h = n[5],
      f = n[6],
      m = n[7],
      g = n[8],
      p = n[9],
      v = n[10],
      x = n[11],
      b = n[12],
      _ = n[13],
      y = n[14],
      E = n[15];
    return (
      e[0].setComponents(l - i, m - u, x - g, E - b).normalize(),
      e[1].setComponents(l + i, m + u, x + g, E + b).normalize(),
      e[2].setComponents(l + r, m + h, x + p, E + _).normalize(),
      e[3].setComponents(l - r, m - h, x - p, E - _).normalize(),
      e[4].setComponents(l - o, m - f, x - v, E - y).normalize(),
      e[5].setComponents(l + o, m + f, x + v, E + y).normalize(),
      this
    );
  }
  intersectsObject(t) {
    const e = t.geometry;
    return (
      e.boundingSphere === null && e.computeBoundingSphere(),
      ga.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
      this.intersectsSphere(ga)
    );
  }
  intersectsSprite(t) {
    return (
      ga.center.set(0, 0, 0),
      (ga.radius = 0.7071067811865476),
      ga.applyMatrix4(t.matrixWorld),
      this.intersectsSphere(ga)
    );
  }
  intersectsSphere(t) {
    const e = this.planes,
      n = t.center,
      i = -t.radius;
    for (let r = 0; r < 6; r++) if (e[r].distanceToPoint(n) < i) return !1;
    return !0;
  }
  intersectsBox(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = e[n];
      if (
        ((Nu.x = i.normal.x > 0 ? t.max.x : t.min.x),
        (Nu.y = i.normal.y > 0 ? t.max.y : t.min.y),
        (Nu.z = i.normal.z > 0 ? t.max.z : t.min.z),
        i.distanceToPoint(Nu) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Jv() {
  let a = null,
    t = !1,
    e = null,
    n = null;
  function i(r, o) {
    e(r, o), (n = a.requestAnimationFrame(i));
  }
  return {
    start: function () {
      t !== !0 && e !== null && ((n = a.requestAnimationFrame(i)), (t = !0));
    },
    stop: function () {
      a.cancelAnimationFrame(n), (t = !1);
    },
    setAnimationLoop: function (r) {
      e = r;
    },
    setContext: function (r) {
      a = r;
    },
  };
}
function cR(a, t) {
  const e = t.isWebGL2,
    n = new WeakMap();
  function i(h, f) {
    const m = h.array,
      g = h.usage,
      p = a.createBuffer();
    a.bindBuffer(f, p), a.bufferData(f, m, g), h.onUploadCallback();
    let v = 5126;
    return (
      m instanceof Float32Array
        ? (v = 5126)
        : m instanceof Float64Array
        ? console.warn(
            "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
          )
        : m instanceof Uint16Array
        ? h.isFloat16BufferAttribute
          ? e
            ? (v = 5131)
            : console.warn(
                "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
              )
          : (v = 5123)
        : m instanceof Int16Array
        ? (v = 5122)
        : m instanceof Uint32Array
        ? (v = 5125)
        : m instanceof Int32Array
        ? (v = 5124)
        : m instanceof Int8Array
        ? (v = 5120)
        : (m instanceof Uint8Array || m instanceof Uint8ClampedArray) &&
          (v = 5121),
      {
        buffer: p,
        type: v,
        bytesPerElement: m.BYTES_PER_ELEMENT,
        version: h.version,
      }
    );
  }
  function r(h, f, m) {
    const g = f.array,
      p = f.updateRange;
    a.bindBuffer(m, h),
      p.count === -1
        ? a.bufferSubData(m, 0, g)
        : (e
            ? a.bufferSubData(
                m,
                p.offset * g.BYTES_PER_ELEMENT,
                g,
                p.offset,
                p.count
              )
            : a.bufferSubData(
                m,
                p.offset * g.BYTES_PER_ELEMENT,
                g.subarray(p.offset, p.offset + p.count)
              ),
          (p.count = -1));
  }
  function o(h) {
    return h.isInterleavedBufferAttribute && (h = h.data), n.get(h);
  }
  function l(h) {
    h.isInterleavedBufferAttribute && (h = h.data);
    const f = n.get(h);
    f && (a.deleteBuffer(f.buffer), n.delete(h));
  }
  function u(h, f) {
    if (h.isGLBufferAttribute) {
      const g = n.get(h);
      (!g || g.version < h.version) &&
        n.set(h, {
          buffer: h.buffer,
          type: h.type,
          bytesPerElement: h.elementSize,
          version: h.version,
        });
      return;
    }
    h.isInterleavedBufferAttribute && (h = h.data);
    const m = n.get(h);
    m === void 0
      ? n.set(h, i(h, f))
      : m.version < h.version && (r(m.buffer, h, f), (m.version = h.version));
  }
  return { get: o, remove: l, update: u };
}
class tp extends Ge {
  constructor(t = 1, e = 1, n = 1, i = 1) {
    super();
    (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: t,
        height: e,
        widthSegments: n,
        heightSegments: i,
      });
    const r = t / 2,
      o = e / 2,
      l = Math.floor(n),
      u = Math.floor(i),
      h = l + 1,
      f = u + 1,
      m = t / l,
      g = e / u,
      p = [],
      v = [],
      x = [],
      b = [];
    for (let _ = 0; _ < f; _++) {
      const y = _ * g - o;
      for (let E = 0; E < h; E++) {
        const M = E * m - r;
        v.push(M, -y, 0), x.push(0, 0, 1), b.push(E / l), b.push(1 - _ / u);
      }
    }
    for (let _ = 0; _ < u; _++)
      for (let y = 0; y < l; y++) {
        const E = y + h * _,
          M = y + h * (_ + 1),
          A = y + 1 + h * (_ + 1),
          R = y + 1 + h * _;
        p.push(E, M, R), p.push(M, A, R);
      }
    this.setIndex(p),
      this.setAttribute("position", new en(v, 3)),
      this.setAttribute("normal", new en(x, 3)),
      this.setAttribute("uv", new en(b, 2));
  }
  static fromJSON(t) {
    return new tp(t.width, t.height, t.widthSegments, t.heightSegments);
  }
}
var uR = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
  hR = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  fR = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  dR = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  pR = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  mR = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  gR = "vec3 transformed = vec3( position );",
  _R = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  vR = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
  xR = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  yR = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  wR = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  bR = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  MR = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  SR = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  TR = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  ER = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  AR = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  LR = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
  CR = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  RR = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  PR = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  IR = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
  DR = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  FR = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  OR = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  NR = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,
  BR = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  zR = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  UR = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  kR = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  GR = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  HR = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  VR = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  WR = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  XR = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  YR = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
  qR = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  ZR = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  jR = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
  JR = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  $R = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  KR = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  QR = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
  t2 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  e2 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
  n2 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
  i2 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  r2 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  s2 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  o2 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  a2 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  l2 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  c2 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  u2 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  h2 = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,
  f2 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  d2 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  p2 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  m2 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  g2 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  _2 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  v2 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  x2 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  y2 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
  w2 = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  b2 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  M2 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  S2 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  T2 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
  E2 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  A2 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
  L2 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
  C2 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  R2 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
  P2 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  I2 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  D2 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  F2 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  O2 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  N2 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  B2 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  z2 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  U2 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
  k2 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  G2 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  H2 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
  V2 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  W2 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  X2 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  Y2 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  q2 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  Z2 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  j2 = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,
  J2 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  $2 = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
  K2 = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
  Q2 = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
  t3 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
  e3 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
  n3 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
  i3 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const r3 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  s3 = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  o3 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  a3 = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  l3 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  c3 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  u3 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  h3 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  f3 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  d3 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  p3 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  m3 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  g3 = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  _3 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  v3 = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  x3 = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  y3 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  w3 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  b3 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  M3 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,
  S3 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  T3 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  E3 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  A3 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  L3 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  C3 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  R3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  P3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  I3 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  D3 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  F3 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  O3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  ce = {
    alphamap_fragment: uR,
    alphamap_pars_fragment: hR,
    alphatest_fragment: fR,
    alphatest_pars_fragment: dR,
    aomap_fragment: pR,
    aomap_pars_fragment: mR,
    begin_vertex: gR,
    beginnormal_vertex: _R,
    bsdfs: vR,
    bumpmap_pars_fragment: xR,
    clipping_planes_fragment: yR,
    clipping_planes_pars_fragment: wR,
    clipping_planes_pars_vertex: bR,
    clipping_planes_vertex: MR,
    color_fragment: SR,
    color_pars_fragment: TR,
    color_pars_vertex: ER,
    color_vertex: AR,
    common: LR,
    cube_uv_reflection_fragment: CR,
    defaultnormal_vertex: RR,
    displacementmap_pars_vertex: PR,
    displacementmap_vertex: IR,
    emissivemap_fragment: DR,
    emissivemap_pars_fragment: FR,
    encodings_fragment: OR,
    encodings_pars_fragment: NR,
    envmap_fragment: BR,
    envmap_common_pars_fragment: zR,
    envmap_pars_fragment: UR,
    envmap_pars_vertex: kR,
    envmap_physical_pars_fragment: $R,
    envmap_vertex: GR,
    fog_vertex: HR,
    fog_pars_vertex: VR,
    fog_fragment: WR,
    fog_pars_fragment: XR,
    gradientmap_pars_fragment: YR,
    lightmap_fragment: qR,
    lightmap_pars_fragment: ZR,
    lights_lambert_vertex: jR,
    lights_pars_begin: JR,
    lights_toon_fragment: KR,
    lights_toon_pars_fragment: QR,
    lights_phong_fragment: t2,
    lights_phong_pars_fragment: e2,
    lights_physical_fragment: n2,
    lights_physical_pars_fragment: i2,
    lights_fragment_begin: r2,
    lights_fragment_maps: s2,
    lights_fragment_end: o2,
    logdepthbuf_fragment: a2,
    logdepthbuf_pars_fragment: l2,
    logdepthbuf_pars_vertex: c2,
    logdepthbuf_vertex: u2,
    map_fragment: h2,
    map_pars_fragment: f2,
    map_particle_fragment: d2,
    map_particle_pars_fragment: p2,
    metalnessmap_fragment: m2,
    metalnessmap_pars_fragment: g2,
    morphnormal_vertex: _2,
    morphtarget_pars_vertex: v2,
    morphtarget_vertex: x2,
    normal_fragment_begin: y2,
    normal_fragment_maps: w2,
    normal_pars_fragment: b2,
    normal_pars_vertex: M2,
    normal_vertex: S2,
    normalmap_pars_fragment: T2,
    clearcoat_normal_fragment_begin: E2,
    clearcoat_normal_fragment_maps: A2,
    clearcoat_pars_fragment: L2,
    output_fragment: C2,
    packing: R2,
    premultiplied_alpha_fragment: P2,
    project_vertex: I2,
    dithering_fragment: D2,
    dithering_pars_fragment: F2,
    roughnessmap_fragment: O2,
    roughnessmap_pars_fragment: N2,
    shadowmap_pars_fragment: B2,
    shadowmap_pars_vertex: z2,
    shadowmap_vertex: U2,
    shadowmask_pars_fragment: k2,
    skinbase_vertex: G2,
    skinning_pars_vertex: H2,
    skinning_vertex: V2,
    skinnormal_vertex: W2,
    specularmap_fragment: X2,
    specularmap_pars_fragment: Y2,
    tonemapping_fragment: q2,
    tonemapping_pars_fragment: Z2,
    transmission_fragment: j2,
    transmission_pars_fragment: J2,
    uv_pars_fragment: $2,
    uv_pars_vertex: K2,
    uv_vertex: Q2,
    uv2_pars_fragment: t3,
    uv2_pars_vertex: e3,
    uv2_vertex: n3,
    worldpos_vertex: i3,
    background_vert: r3,
    background_frag: s3,
    cube_vert: o3,
    cube_frag: a3,
    depth_vert: l3,
    depth_frag: c3,
    distanceRGBA_vert: u3,
    distanceRGBA_frag: h3,
    equirect_vert: f3,
    equirect_frag: d3,
    linedashed_vert: p3,
    linedashed_frag: m3,
    meshbasic_vert: g3,
    meshbasic_frag: _3,
    meshlambert_vert: v3,
    meshlambert_frag: x3,
    meshmatcap_vert: y3,
    meshmatcap_frag: w3,
    meshnormal_vert: b3,
    meshnormal_frag: M3,
    meshphong_vert: S3,
    meshphong_frag: T3,
    meshphysical_vert: E3,
    meshphysical_frag: A3,
    meshtoon_vert: L3,
    meshtoon_frag: C3,
    points_vert: R3,
    points_frag: P3,
    shadow_vert: I3,
    shadow_frag: D3,
    sprite_vert: F3,
    sprite_frag: O3,
  },
  Pt = {
    common: {
      diffuse: { value: new Xt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Mn() },
      uv2Transform: { value: new Mn() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 },
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new Et(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Xt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Xt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Mn() },
    },
    sprite: {
      diffuse: { value: new Xt(16777215) },
      opacity: { value: 1 },
      center: { value: new Et(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Mn() },
    },
  },
  ar = {
    basic: {
      uniforms: Pn([
        Pt.common,
        Pt.specularmap,
        Pt.envmap,
        Pt.aomap,
        Pt.lightmap,
        Pt.fog,
      ]),
      vertexShader: ce.meshbasic_vert,
      fragmentShader: ce.meshbasic_frag,
    },
    lambert: {
      uniforms: Pn([
        Pt.common,
        Pt.specularmap,
        Pt.envmap,
        Pt.aomap,
        Pt.lightmap,
        Pt.emissivemap,
        Pt.fog,
        Pt.lights,
        { emissive: { value: new Xt(0) } },
      ]),
      vertexShader: ce.meshlambert_vert,
      fragmentShader: ce.meshlambert_frag,
    },
    phong: {
      uniforms: Pn([
        Pt.common,
        Pt.specularmap,
        Pt.envmap,
        Pt.aomap,
        Pt.lightmap,
        Pt.emissivemap,
        Pt.bumpmap,
        Pt.normalmap,
        Pt.displacementmap,
        Pt.fog,
        Pt.lights,
        {
          emissive: { value: new Xt(0) },
          specular: { value: new Xt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: ce.meshphong_vert,
      fragmentShader: ce.meshphong_frag,
    },
    standard: {
      uniforms: Pn([
        Pt.common,
        Pt.envmap,
        Pt.aomap,
        Pt.lightmap,
        Pt.emissivemap,
        Pt.bumpmap,
        Pt.normalmap,
        Pt.displacementmap,
        Pt.roughnessmap,
        Pt.metalnessmap,
        Pt.fog,
        Pt.lights,
        {
          emissive: { value: new Xt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: ce.meshphysical_vert,
      fragmentShader: ce.meshphysical_frag,
    },
    toon: {
      uniforms: Pn([
        Pt.common,
        Pt.aomap,
        Pt.lightmap,
        Pt.emissivemap,
        Pt.bumpmap,
        Pt.normalmap,
        Pt.displacementmap,
        Pt.gradientmap,
        Pt.fog,
        Pt.lights,
        { emissive: { value: new Xt(0) } },
      ]),
      vertexShader: ce.meshtoon_vert,
      fragmentShader: ce.meshtoon_frag,
    },
    matcap: {
      uniforms: Pn([
        Pt.common,
        Pt.bumpmap,
        Pt.normalmap,
        Pt.displacementmap,
        Pt.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: ce.meshmatcap_vert,
      fragmentShader: ce.meshmatcap_frag,
    },
    points: {
      uniforms: Pn([Pt.points, Pt.fog]),
      vertexShader: ce.points_vert,
      fragmentShader: ce.points_frag,
    },
    dashed: {
      uniforms: Pn([
        Pt.common,
        Pt.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: ce.linedashed_vert,
      fragmentShader: ce.linedashed_frag,
    },
    depth: {
      uniforms: Pn([Pt.common, Pt.displacementmap]),
      vertexShader: ce.depth_vert,
      fragmentShader: ce.depth_frag,
    },
    normal: {
      uniforms: Pn([
        Pt.common,
        Pt.bumpmap,
        Pt.normalmap,
        Pt.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: ce.meshnormal_vert,
      fragmentShader: ce.meshnormal_frag,
    },
    sprite: {
      uniforms: Pn([Pt.sprite, Pt.fog]),
      vertexShader: ce.sprite_vert,
      fragmentShader: ce.sprite_frag,
    },
    background: {
      uniforms: { uvTransform: { value: new Mn() }, t2D: { value: null } },
      vertexShader: ce.background_vert,
      fragmentShader: ce.background_frag,
    },
    cube: {
      uniforms: Pn([Pt.envmap, { opacity: { value: 1 } }]),
      vertexShader: ce.cube_vert,
      fragmentShader: ce.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: ce.equirect_vert,
      fragmentShader: ce.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Pn([
        Pt.common,
        Pt.displacementmap,
        {
          referencePosition: { value: new k() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: ce.distanceRGBA_vert,
      fragmentShader: ce.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Pn([
        Pt.lights,
        Pt.fog,
        { color: { value: new Xt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: ce.shadow_vert,
      fragmentShader: ce.shadow_frag,
    },
  };
ar.physical = {
  uniforms: Pn([
    ar.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new Et(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new Xt(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 0 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new Et() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Xt(0) },
      specularIntensity: { value: 0 },
      specularIntensityMap: { value: null },
      specularColor: { value: new Xt(1, 1, 1) },
      specularColorMap: { value: null },
    },
  ]),
  vertexShader: ce.meshphysical_vert,
  fragmentShader: ce.meshphysical_frag,
};
function N3(a, t, e, n, i) {
  const r = new Xt(0);
  let o = 0,
    l,
    u,
    h = null,
    f = 0,
    m = null;
  function g(v, x) {
    let b = !1,
      _ = x.isScene === !0 ? x.background : null;
    _ && _.isTexture && (_ = t.get(_));
    const y = a.xr,
      E = y.getSession && y.getSession();
    E && E.environmentBlendMode === "additive" && (_ = null),
      _ === null ? p(r, o) : _ && _.isColor && (p(_, 1), (b = !0)),
      (a.autoClear || b) &&
        a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil),
      _ && (_.isCubeTexture || _.mapping === uu)
        ? (u === void 0 &&
            ((u = new ti(
              new Ml(1, 1, 1),
              new eo({
                name: "BackgroundCubeMaterial",
                uniforms: da(ar.cube.uniforms),
                vertexShader: ar.cube.vertexShader,
                fragmentShader: ar.cube.fragmentShader,
                side: un,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            u.geometry.deleteAttribute("uv"),
            (u.onBeforeRender = function (M, A, R) {
              this.matrixWorld.copyPosition(R.matrixWorld);
            }),
            Object.defineProperty(u.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            n.update(u)),
          (u.material.uniforms.envMap.value = _),
          (u.material.uniforms.flipEnvMap.value =
            _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
          (h !== _ || f !== _.version || m !== a.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (h = _),
            (f = _.version),
            (m = a.toneMapping)),
          v.unshift(u, u.geometry, u.material, 0, 0, null))
        : _ &&
          _.isTexture &&
          (l === void 0 &&
            ((l = new ti(
              new tp(2, 2),
              new eo({
                name: "BackgroundMaterial",
                uniforms: da(ar.background.uniforms),
                vertexShader: ar.background.vertexShader,
                fragmentShader: ar.background.fragmentShader,
                side: fl,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            l.geometry.deleteAttribute("normal"),
            Object.defineProperty(l.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            n.update(l)),
          (l.material.uniforms.t2D.value = _),
          _.matrixAutoUpdate === !0 && _.updateMatrix(),
          l.material.uniforms.uvTransform.value.copy(_.matrix),
          (h !== _ || f !== _.version || m !== a.toneMapping) &&
            ((l.material.needsUpdate = !0),
            (h = _),
            (f = _.version),
            (m = a.toneMapping)),
          v.unshift(l, l.geometry, l.material, 0, 0, null));
  }
  function p(v, x) {
    e.buffers.color.setClear(v.r, v.g, v.b, x, i);
  }
  return {
    getClearColor: function () {
      return r;
    },
    setClearColor: function (v, x = 1) {
      r.set(v), (o = x), p(r, o);
    },
    getClearAlpha: function () {
      return o;
    },
    setClearAlpha: function (v) {
      (o = v), p(r, o);
    },
    render: g,
  };
}
function B3(a, t, e, n) {
  const i = a.getParameter(34921),
    r = n.isWebGL2 ? null : t.get("OES_vertex_array_object"),
    o = n.isWebGL2 || r !== null,
    l = {},
    u = x(null);
  let h = u;
  function f(W, q, tt, V, Q) {
    let st = !1;
    if (o) {
      const Lt = v(V, tt, q);
      h !== Lt && ((h = Lt), g(h.object)), (st = b(V, Q)), st && _(V, Q);
    } else {
      const Lt = q.wireframe === !0;
      (h.geometry !== V.id || h.program !== tt.id || h.wireframe !== Lt) &&
        ((h.geometry = V.id),
        (h.program = tt.id),
        (h.wireframe = Lt),
        (st = !0));
    }
    W.isInstancedMesh === !0 && (st = !0),
      Q !== null && e.update(Q, 34963),
      st &&
        (T(W, q, tt, V), Q !== null && a.bindBuffer(34963, e.get(Q).buffer));
  }
  function m() {
    return n.isWebGL2 ? a.createVertexArray() : r.createVertexArrayOES();
  }
  function g(W) {
    return n.isWebGL2 ? a.bindVertexArray(W) : r.bindVertexArrayOES(W);
  }
  function p(W) {
    return n.isWebGL2 ? a.deleteVertexArray(W) : r.deleteVertexArrayOES(W);
  }
  function v(W, q, tt) {
    const V = tt.wireframe === !0;
    let Q = l[W.id];
    Q === void 0 && ((Q = {}), (l[W.id] = Q));
    let st = Q[q.id];
    st === void 0 && ((st = {}), (Q[q.id] = st));
    let Lt = st[V];
    return Lt === void 0 && ((Lt = x(m())), (st[V] = Lt)), Lt;
  }
  function x(W) {
    const q = [],
      tt = [],
      V = [];
    for (let Q = 0; Q < i; Q++) (q[Q] = 0), (tt[Q] = 0), (V[Q] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: q,
      enabledAttributes: tt,
      attributeDivisors: V,
      object: W,
      attributes: {},
      index: null,
    };
  }
  function b(W, q) {
    const tt = h.attributes,
      V = W.attributes;
    let Q = 0;
    for (const st in V) {
      const Lt = tt[st],
        J = V[st];
      if (Lt === void 0 || Lt.attribute !== J || Lt.data !== J.data) return !0;
      Q++;
    }
    return h.attributesNum !== Q || h.index !== q;
  }
  function _(W, q) {
    const tt = {},
      V = W.attributes;
    let Q = 0;
    for (const st in V) {
      const Lt = V[st],
        J = {};
      (J.attribute = Lt), Lt.data && (J.data = Lt.data), (tt[st] = J), Q++;
    }
    (h.attributes = tt), (h.attributesNum = Q), (h.index = q);
  }
  function y() {
    const W = h.newAttributes;
    for (let q = 0, tt = W.length; q < tt; q++) W[q] = 0;
  }
  function E(W) {
    M(W, 0);
  }
  function M(W, q) {
    const tt = h.newAttributes,
      V = h.enabledAttributes,
      Q = h.attributeDivisors;
    (tt[W] = 1),
      V[W] === 0 && (a.enableVertexAttribArray(W), (V[W] = 1)),
      Q[W] !== q &&
        ((n.isWebGL2 ? a : t.get("ANGLE_instanced_arrays"))[
          n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](W, q),
        (Q[W] = q));
  }
  function A() {
    const W = h.newAttributes,
      q = h.enabledAttributes;
    for (let tt = 0, V = q.length; tt < V; tt++)
      q[tt] !== W[tt] && (a.disableVertexAttribArray(tt), (q[tt] = 0));
  }
  function R(W, q, tt, V, Q, st) {
    n.isWebGL2 === !0 && (tt === 5124 || tt === 5125)
      ? a.vertexAttribIPointer(W, q, tt, Q, st)
      : a.vertexAttribPointer(W, q, tt, V, Q, st);
  }
  function T(W, q, tt, V) {
    if (
      n.isWebGL2 === !1 &&
      (W.isInstancedMesh || V.isInstancedBufferGeometry) &&
      t.get("ANGLE_instanced_arrays") === null
    )
      return;
    y();
    const Q = V.attributes,
      st = tt.getAttributes(),
      Lt = q.defaultAttributeValues;
    for (const J in st) {
      const vt = st[J];
      if (vt.location >= 0) {
        let zt = Q[J];
        if (
          (zt === void 0 &&
            (J === "instanceMatrix" &&
              W.instanceMatrix &&
              (zt = W.instanceMatrix),
            J === "instanceColor" && W.instanceColor && (zt = W.instanceColor)),
          zt !== void 0)
        ) {
          const ft = zt.normalized,
            Mt = zt.itemSize,
            Tt = e.get(zt);
          if (Tt === void 0) continue;
          const z = Tt.buffer,
            F = Tt.type,
            U = Tt.bytesPerElement;
          if (zt.isInterleavedBufferAttribute) {
            const et = zt.data,
              dt = et.stride,
              gt = zt.offset;
            if (et && et.isInstancedInterleavedBuffer) {
              for (let j = 0; j < vt.locationSize; j++)
                M(vt.location + j, et.meshPerAttribute);
              W.isInstancedMesh !== !0 &&
                V._maxInstanceCount === void 0 &&
                (V._maxInstanceCount = et.meshPerAttribute * et.count);
            } else for (let j = 0; j < vt.locationSize; j++) E(vt.location + j);
            a.bindBuffer(34962, z);
            for (let j = 0; j < vt.locationSize; j++)
              R(
                vt.location + j,
                Mt / vt.locationSize,
                F,
                ft,
                dt * U,
                (gt + (Mt / vt.locationSize) * j) * U
              );
          } else {
            if (zt.isInstancedBufferAttribute) {
              for (let et = 0; et < vt.locationSize; et++)
                M(vt.location + et, zt.meshPerAttribute);
              W.isInstancedMesh !== !0 &&
                V._maxInstanceCount === void 0 &&
                (V._maxInstanceCount = zt.meshPerAttribute * zt.count);
            } else
              for (let et = 0; et < vt.locationSize; et++) E(vt.location + et);
            a.bindBuffer(34962, z);
            for (let et = 0; et < vt.locationSize; et++)
              R(
                vt.location + et,
                Mt / vt.locationSize,
                F,
                ft,
                Mt * U,
                (Mt / vt.locationSize) * et * U
              );
          }
        } else if (Lt !== void 0) {
          const ft = Lt[J];
          if (ft !== void 0)
            switch (ft.length) {
              case 2:
                a.vertexAttrib2fv(vt.location, ft);
                break;
              case 3:
                a.vertexAttrib3fv(vt.location, ft);
                break;
              case 4:
                a.vertexAttrib4fv(vt.location, ft);
                break;
              default:
                a.vertexAttrib1fv(vt.location, ft);
            }
        }
      }
    }
    A();
  }
  function B() {
    O();
    for (const W in l) {
      const q = l[W];
      for (const tt in q) {
        const V = q[tt];
        for (const Q in V) p(V[Q].object), delete V[Q];
        delete q[tt];
      }
      delete l[W];
    }
  }
  function X(W) {
    if (l[W.id] === void 0) return;
    const q = l[W.id];
    for (const tt in q) {
      const V = q[tt];
      for (const Q in V) p(V[Q].object), delete V[Q];
      delete q[tt];
    }
    delete l[W.id];
  }
  function H(W) {
    for (const q in l) {
      const tt = l[q];
      if (tt[W.id] === void 0) continue;
      const V = tt[W.id];
      for (const Q in V) p(V[Q].object), delete V[Q];
      delete tt[W.id];
    }
  }
  function O() {
    it(), h !== u && ((h = u), g(h.object));
  }
  function it() {
    (u.geometry = null), (u.program = null), (u.wireframe = !1);
  }
  return {
    setup: f,
    reset: O,
    resetDefaultState: it,
    dispose: B,
    releaseStatesOfGeometry: X,
    releaseStatesOfProgram: H,
    initAttributes: y,
    enableAttribute: E,
    disableUnusedAttributes: A,
  };
}
function z3(a, t, e, n) {
  const i = n.isWebGL2;
  let r;
  function o(h) {
    r = h;
  }
  function l(h, f) {
    a.drawArrays(r, h, f), e.update(f, r, 1);
  }
  function u(h, f, m) {
    if (m === 0) return;
    let g, p;
    if (i) (g = a), (p = "drawArraysInstanced");
    else if (
      ((g = t.get("ANGLE_instanced_arrays")),
      (p = "drawArraysInstancedANGLE"),
      g === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    g[p](r, h, f, m), e.update(f, r, m);
  }
  (this.setMode = o), (this.render = l), (this.renderInstances = u);
}
function U3(a, t, e) {
  let n;
  function i() {
    if (n !== void 0) return n;
    if (t.has("EXT_texture_filter_anisotropic") === !0) {
      const T = t.get("EXT_texture_filter_anisotropic");
      n = a.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else n = 0;
    return n;
  }
  function r(T) {
    if (T === "highp") {
      if (
        a.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        a.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      T = "mediump";
    }
    return T === "mediump" &&
      a.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      a.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  const o =
    (typeof WebGL2RenderingContext != "undefined" &&
      a instanceof WebGL2RenderingContext) ||
    (typeof WebGL2ComputeRenderingContext != "undefined" &&
      a instanceof WebGL2ComputeRenderingContext);
  let l = e.precision !== void 0 ? e.precision : "highp";
  const u = r(l);
  u !== l &&
    (console.warn(
      "THREE.WebGLRenderer:",
      l,
      "not supported, using",
      u,
      "instead."
    ),
    (l = u));
  const h = o || t.has("WEBGL_draw_buffers"),
    f = e.logarithmicDepthBuffer === !0,
    m = a.getParameter(34930),
    g = a.getParameter(35660),
    p = a.getParameter(3379),
    v = a.getParameter(34076),
    x = a.getParameter(34921),
    b = a.getParameter(36347),
    _ = a.getParameter(36348),
    y = a.getParameter(36349),
    E = g > 0,
    M = o || t.has("OES_texture_float"),
    A = E && M,
    R = o ? a.getParameter(36183) : 0;
  return {
    isWebGL2: o,
    drawBuffers: h,
    getMaxAnisotropy: i,
    getMaxPrecision: r,
    precision: l,
    logarithmicDepthBuffer: f,
    maxTextures: m,
    maxVertexTextures: g,
    maxTextureSize: p,
    maxCubemapSize: v,
    maxAttributes: x,
    maxVertexUniforms: b,
    maxVaryings: _,
    maxFragmentUniforms: y,
    vertexTextures: E,
    floatFragmentTextures: M,
    floatVertexTextures: A,
    maxSamples: R,
  };
}
function k3(a) {
  const t = this;
  let e = null,
    n = 0,
    i = !1,
    r = !1;
  const o = new Br(),
    l = new Mn(),
    u = { value: null, needsUpdate: !1 };
  (this.uniform = u),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (m, g, p) {
      const v = m.length !== 0 || g || n !== 0 || i;
      return (i = g), (e = f(m, p, 0)), (n = m.length), v;
    }),
    (this.beginShadows = function () {
      (r = !0), f(null);
    }),
    (this.endShadows = function () {
      (r = !1), h();
    }),
    (this.setState = function (m, g, p) {
      const v = m.clippingPlanes,
        x = m.clipIntersection,
        b = m.clipShadows,
        _ = a.get(m);
      if (!i || v === null || v.length === 0 || (r && !b)) r ? f(null) : h();
      else {
        const y = r ? 0 : n,
          E = y * 4;
        let M = _.clippingState || null;
        (u.value = M), (M = f(v, g, E, p));
        for (let A = 0; A !== E; ++A) M[A] = e[A];
        (_.clippingState = M),
          (this.numIntersection = x ? this.numPlanes : 0),
          (this.numPlanes += y);
      }
    });
  function h() {
    u.value !== e && ((u.value = e), (u.needsUpdate = n > 0)),
      (t.numPlanes = n),
      (t.numIntersection = 0);
  }
  function f(m, g, p, v) {
    const x = m !== null ? m.length : 0;
    let b = null;
    if (x !== 0) {
      if (((b = u.value), v !== !0 || b === null)) {
        const _ = p + x * 4,
          y = g.matrixWorldInverse;
        l.getNormalMatrix(y),
          (b === null || b.length < _) && (b = new Float32Array(_));
        for (let E = 0, M = p; E !== x; ++E, M += 4)
          o.copy(m[E]).applyMatrix4(y, l),
            o.normal.toArray(b, M),
            (b[M + 3] = o.constant);
      }
      (u.value = b), (u.needsUpdate = !0);
    }
    return (t.numPlanes = x), (t.numIntersection = 0), b;
  }
}
function G3(a) {
  let t = new WeakMap();
  function e(o, l) {
    return l === md ? (o.mapping = pl) : l === gd && (o.mapping = ml), o;
  }
  function n(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const l = o.mapping;
      if (l === md || l === gd)
        if (t.has(o)) {
          const u = t.get(o).texture;
          return e(u, o.mapping);
        } else {
          const u = o.image;
          if (u && u.height > 0) {
            const h = a.getRenderTarget(),
              f = new jv(u.height / 2);
            return (
              f.fromEquirectangularTexture(a, o),
              t.set(o, f),
              a.setRenderTarget(h),
              o.addEventListener("dispose", i),
              e(f.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function i(o) {
    const l = o.target;
    l.removeEventListener("dispose", i);
    const u = t.get(l);
    u !== void 0 && (t.delete(l), u.dispose());
  }
  function r() {
    t = new WeakMap();
  }
  return { get: n, dispose: r };
}
class ep extends $d {
  constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
    super();
    (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = t),
      (this.right = e),
      (this.top = n),
      (this.bottom = i),
      (this.near = r),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      (this.left = t.left),
      (this.right = t.right),
      (this.top = t.top),
      (this.bottom = t.bottom),
      (this.near = t.near),
      (this.far = t.far),
      (this.zoom = t.zoom),
      (this.view = t.view === null ? null : Object.assign({}, t.view)),
      this
    );
  }
  setViewOffset(t, e, n, i, r, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = t),
      (this.view.fullHeight = e),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = r),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom),
      e = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let r = n - t,
      o = n + t,
      l = i + e,
      u = i - e;
    if (this.view !== null && this.view.enabled) {
      const h = (this.right - this.left) / this.view.fullWidth / this.zoom,
        f = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (r += h * this.view.offsetX),
        (o = r + h * this.view.width),
        (l -= f * this.view.offsetY),
        (u = l - f * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(r, o, l, u, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.zoom = this.zoom),
      (e.object.left = this.left),
      (e.object.right = this.right),
      (e.object.top = this.top),
      (e.object.bottom = this.bottom),
      (e.object.near = this.near),
      (e.object.far = this.far),
      this.view !== null && (e.object.view = Object.assign({}, this.view)),
      e
    );
  }
}
ep.prototype.isOrthographicCamera = !0;
class zu extends eo {
  constructor(t) {
    super(t);
    this.type = "RawShaderMaterial";
  }
}
zu.prototype.isRawShaderMaterial = !0;
const _a = 4,
  xs = 8,
  lr = Math.pow(2, xs),
  $v = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Kv = xs - _a + 1 + $v.length,
  va = 20,
  ys = { [Cn]: 0, [Js]: 1, [Md]: 2, [Ev]: 3, [Av]: 4, [Lv]: 5, [bd]: 6 },
  np = new ep(),
  { _lodPlanes: Sl, _sizeLods: Qv, _sigmas: Uu } = W3(),
  tx = new Xt();
let ip = null;
const no = (1 + Math.sqrt(5)) / 2,
  xa = 1 / no,
  ex = [
    new k(1, 1, 1),
    new k(-1, 1, 1),
    new k(1, 1, -1),
    new k(-1, 1, -1),
    new k(0, no, xa),
    new k(0, no, -xa),
    new k(xa, 0, no),
    new k(-xa, 0, no),
    new k(no, xa, 0),
    new k(-no, xa, 0),
  ];
class H3 {
  constructor(t) {
    (this._renderer = t),
      (this._pingPongRenderTarget = null),
      (this._blurMaterial = X3(va)),
      (this._equirectShader = null),
      (this._cubemapShader = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(t, e = 0, n = 0.1, i = 100) {
    ip = this._renderer.getRenderTarget();
    const r = this._allocateTargets();
    return (
      this._sceneToCubeUV(t, n, i, r),
      e > 0 && this._blur(r, 0, 0, e),
      this._applyPMREM(r),
      this._cleanup(r),
      r
    );
  }
  fromEquirectangular(t) {
    return this._fromTexture(t);
  }
  fromCubemap(t) {
    return this._fromTexture(t);
  }
  compileCubemapShader() {
    this._cubemapShader === null &&
      ((this._cubemapShader = rx()),
      this._compileMaterial(this._cubemapShader));
  }
  compileEquirectangularShader() {
    this._equirectShader === null &&
      ((this._equirectShader = ix()),
      this._compileMaterial(this._equirectShader));
  }
  dispose() {
    this._blurMaterial.dispose(),
      this._cubemapShader !== null && this._cubemapShader.dispose(),
      this._equirectShader !== null && this._equirectShader.dispose();
    for (let t = 0; t < Sl.length; t++) Sl[t].dispose();
  }
  _cleanup(t) {
    this._pingPongRenderTarget.dispose(),
      this._renderer.setRenderTarget(ip),
      (t.scissorTest = !1),
      ku(t, 0, 0, t.width, t.height);
  }
  _fromTexture(t) {
    ip = this._renderer.getRenderTarget();
    const e = this._allocateTargets(t);
    return (
      this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
    );
  }
  _allocateTargets(t) {
    const e = {
        magFilter: mn,
        minFilter: mn,
        generateMipmaps: !1,
        type: us,
        format: JL,
        encoding: V3(t) ? t.encoding : Md,
        depthBuffer: !1,
      },
      n = nx(e);
    return (n.depthBuffer = !t), (this._pingPongRenderTarget = nx(e)), n;
  }
  _compileMaterial(t) {
    const e = new ti(Sl[0], t);
    this._renderer.compile(e, np);
  }
  _sceneToCubeUV(t, e, n, i) {
    const r = 90,
      o = 1,
      l = new ei(r, o, e, n),
      u = [1, -1, 1, 1, 1, 1],
      h = [1, 1, 1, -1, -1, -1],
      f = this._renderer,
      m = f.autoClear,
      g = f.outputEncoding,
      p = f.toneMapping;
    f.getClearColor(tx),
      (f.toneMapping = js),
      (f.outputEncoding = Cn),
      (f.autoClear = !1);
    const v = new Wd({
        name: "PMREM.Background",
        side: un,
        depthWrite: !1,
        depthTest: !1,
      }),
      x = new ti(new Ml(), v);
    let b = !1;
    const _ = t.background;
    _
      ? _.isColor && (v.color.copy(_), (t.background = null), (b = !0))
      : (v.color.copy(tx), (b = !0));
    for (let y = 0; y < 6; y++) {
      const E = y % 3;
      E == 0
        ? (l.up.set(0, u[y], 0), l.lookAt(h[y], 0, 0))
        : E == 1
        ? (l.up.set(0, 0, u[y]), l.lookAt(0, h[y], 0))
        : (l.up.set(0, u[y], 0), l.lookAt(0, 0, h[y])),
        ku(i, E * lr, y > 2 ? lr : 0, lr, lr),
        f.setRenderTarget(i),
        b && f.render(x, l),
        f.render(t, l);
    }
    x.geometry.dispose(),
      x.material.dispose(),
      (f.toneMapping = p),
      (f.outputEncoding = g),
      (f.autoClear = m),
      (t.background = _);
  }
  _setEncoding(t, e) {
    this._renderer.capabilities.isWebGL2 === !0 &&
    e.format === kn &&
    e.type === us &&
    e.encoding === Js
      ? (t.value = ys[Cn])
      : (t.value = ys[e.encoding]);
  }
  _textureToCubeUV(t, e) {
    const n = this._renderer,
      i = t.mapping === pl || t.mapping === ml;
    i
      ? this._cubemapShader == null && (this._cubemapShader = rx())
      : this._equirectShader == null && (this._equirectShader = ix());
    const r = i ? this._cubemapShader : this._equirectShader,
      o = new ti(Sl[0], r),
      l = r.uniforms;
    (l.envMap.value = t),
      i || l.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
      this._setEncoding(l.inputEncoding, t),
      this._setEncoding(l.outputEncoding, e.texture),
      ku(e, 0, 0, 3 * lr, 2 * lr),
      n.setRenderTarget(e),
      n.render(o, np);
  }
  _applyPMREM(t) {
    const e = this._renderer,
      n = e.autoClear;
    e.autoClear = !1;
    for (let i = 1; i < Kv; i++) {
      const r = Math.sqrt(Uu[i] * Uu[i] - Uu[i - 1] * Uu[i - 1]),
        o = ex[(i - 1) % ex.length];
      this._blur(t, i - 1, i, r, o);
    }
    e.autoClear = n;
  }
  _blur(t, e, n, i, r) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(t, o, e, n, i, "latitudinal", r),
      this._halfBlur(o, t, n, n, i, "longitudinal", r);
  }
  _halfBlur(t, e, n, i, r, o, l) {
    const u = this._renderer,
      h = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const f = 3,
      m = new ti(Sl[i], h),
      g = h.uniforms,
      p = Qv[n] - 1,
      v = isFinite(r) ? Math.PI / (2 * p) : (2 * Math.PI) / (2 * va - 1),
      x = r / v,
      b = isFinite(r) ? 1 + Math.floor(f * x) : va;
    b > va &&
      console.warn(
        `sigmaRadians, ${r}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${va}`
      );
    const _ = [];
    let y = 0;
    for (let R = 0; R < va; ++R) {
      const T = R / x,
        B = Math.exp((-T * T) / 2);
      _.push(B), R == 0 ? (y += B) : R < b && (y += 2 * B);
    }
    for (let R = 0; R < _.length; R++) _[R] = _[R] / y;
    (g.envMap.value = t.texture),
      (g.samples.value = b),
      (g.weights.value = _),
      (g.latitudinal.value = o === "latitudinal"),
      l && (g.poleAxis.value = l),
      (g.dTheta.value = v),
      (g.mipInt.value = xs - n),
      this._setEncoding(g.inputEncoding, t.texture),
      this._setEncoding(g.outputEncoding, t.texture);
    const E = Qv[i],
      M = 3 * Math.max(0, lr - 2 * E),
      A = (i === 0 ? 0 : 2 * lr) + 2 * E * (i > xs - _a ? i - xs + _a : 0);
    ku(e, M, A, 3 * E, 2 * E), u.setRenderTarget(e), u.render(m, np);
  }
}
function V3(a) {
  return a === void 0 || a.type !== us
    ? !1
    : a.encoding === Cn || a.encoding === Js || a.encoding === bd;
}
function W3() {
  const a = [],
    t = [],
    e = [];
  let n = xs;
  for (let i = 0; i < Kv; i++) {
    const r = Math.pow(2, n);
    t.push(r);
    let o = 1 / r;
    i > xs - _a ? (o = $v[i - xs + _a - 1]) : i == 0 && (o = 0), e.push(o);
    const l = 1 / (r - 1),
      u = -l / 2,
      h = 1 + l / 2,
      f = [u, u, h, u, h, h, u, u, h, h, u, h],
      m = 6,
      g = 6,
      p = 3,
      v = 2,
      x = 1,
      b = new Float32Array(p * g * m),
      _ = new Float32Array(v * g * m),
      y = new Float32Array(x * g * m);
    for (let M = 0; M < m; M++) {
      const A = ((M % 3) * 2) / 3 - 1,
        R = M > 2 ? 0 : -1,
        T = [
          A,
          R,
          0,
          A + 2 / 3,
          R,
          0,
          A + 2 / 3,
          R + 1,
          0,
          A,
          R,
          0,
          A + 2 / 3,
          R + 1,
          0,
          A,
          R + 1,
          0,
        ];
      b.set(T, p * g * M), _.set(f, v * g * M);
      const B = [M, M, M, M, M, M];
      y.set(B, x * g * M);
    }
    const E = new Ge();
    E.setAttribute("position", new hn(b, p)),
      E.setAttribute("uv", new hn(_, v)),
      E.setAttribute("faceIndex", new hn(y, x)),
      a.push(E),
      n > _a && n--;
  }
  return { _lodPlanes: a, _sizeLods: t, _sigmas: e };
}
function nx(a) {
  const t = new or(3 * lr, 3 * lr, a);
  return (
    (t.texture.mapping = uu),
    (t.texture.name = "PMREM.cubeUv"),
    (t.scissorTest = !0),
    t
  );
}
function ku(a, t, e, n, i) {
  a.viewport.set(t, e, n, i), a.scissor.set(t, e, n, i);
}
function X3(a) {
  const t = new Float32Array(a),
    e = new k(0, 1, 0);
  return new zu({
    name: "SphericalGaussianBlur",
    defines: { n: a },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: t },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: e },
      inputEncoding: { value: ys[Cn] },
      outputEncoding: { value: ys[Cn] },
    },
    vertexShader: rp(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${sp()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: cs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function ix() {
  const a = new Et(1, 1);
  return new zu({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null },
      texelSize: { value: a },
      inputEncoding: { value: ys[Cn] },
      outputEncoding: { value: ys[Cn] },
    },
    vertexShader: rp(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${sp()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: cs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function rx() {
  return new zu({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      inputEncoding: { value: ys[Cn] },
      outputEncoding: { value: ys[Cn] },
    },
    vertexShader: rp(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${sp()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
    blending: cs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function rp() {
  return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function sp() {
  return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
}
function Y3(a) {
  let t = new WeakMap(),
    e = null;
  function n(l) {
    if (l && l.isTexture && l.isRenderTargetTexture === !1) {
      const u = l.mapping,
        h = u === md || u === gd,
        f = u === pl || u === ml;
      if (h || f) {
        if (t.has(l)) return t.get(l).texture;
        {
          const m = l.image;
          if ((h && m && m.height > 0) || (f && m && i(m))) {
            const g = a.getRenderTarget();
            e === null && (e = new H3(a));
            const p = h ? e.fromEquirectangular(l) : e.fromCubemap(l);
            return (
              t.set(l, p),
              a.setRenderTarget(g),
              l.addEventListener("dispose", r),
              p.texture
            );
          } else return null;
        }
      }
    }
    return l;
  }
  function i(l) {
    let u = 0;
    const h = 6;
    for (let f = 0; f < h; f++) l[f] !== void 0 && u++;
    return u === h;
  }
  function r(l) {
    const u = l.target;
    u.removeEventListener("dispose", r);
    const h = t.get(u);
    h !== void 0 && (t.delete(u), h.dispose());
  }
  function o() {
    (t = new WeakMap()), e !== null && (e.dispose(), (e = null));
  }
  return { get: n, dispose: o };
}
function q3(a) {
  const t = {};
  function e(n) {
    if (t[n] !== void 0) return t[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i =
          a.getExtension("WEBGL_depth_texture") ||
          a.getExtension("MOZ_WEBGL_depth_texture") ||
          a.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          a.getExtension("EXT_texture_filter_anisotropic") ||
          a.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          a.getExtension("WEBGL_compressed_texture_s3tc") ||
          a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          a.getExtension("WEBGL_compressed_texture_pvrtc") ||
          a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = a.getExtension(n);
    }
    return (t[n] = i), i;
  }
  return {
    has: function (n) {
      return e(n) !== null;
    },
    init: function (n) {
      n.isWebGL2
        ? e("EXT_color_buffer_float")
        : (e("WEBGL_depth_texture"),
          e("OES_texture_float"),
          e("OES_texture_half_float"),
          e("OES_texture_half_float_linear"),
          e("OES_standard_derivatives"),
          e("OES_element_index_uint"),
          e("OES_vertex_array_object"),
          e("ANGLE_instanced_arrays")),
        e("OES_texture_float_linear"),
        e("EXT_color_buffer_half_float");
    },
    get: function (n) {
      const i = e(n);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + n + " extension not supported."
          ),
        i
      );
    },
  };
}
function Z3(a, t, e, n) {
  const i = {},
    r = new WeakMap();
  function o(m) {
    const g = m.target;
    g.index !== null && t.remove(g.index);
    for (const v in g.attributes) t.remove(g.attributes[v]);
    g.removeEventListener("dispose", o), delete i[g.id];
    const p = r.get(g);
    p && (t.remove(p), r.delete(g)),
      n.releaseStatesOfGeometry(g),
      g.isInstancedBufferGeometry === !0 && delete g._maxInstanceCount,
      e.memory.geometries--;
  }
  function l(m, g) {
    return (
      i[g.id] === !0 ||
        (g.addEventListener("dispose", o),
        (i[g.id] = !0),
        e.memory.geometries++),
      g
    );
  }
  function u(m) {
    const g = m.attributes;
    for (const v in g) t.update(g[v], 34962);
    const p = m.morphAttributes;
    for (const v in p) {
      const x = p[v];
      for (let b = 0, _ = x.length; b < _; b++) t.update(x[b], 34962);
    }
  }
  function h(m) {
    const g = [],
      p = m.index,
      v = m.attributes.position;
    let x = 0;
    if (p !== null) {
      const y = p.array;
      x = p.version;
      for (let E = 0, M = y.length; E < M; E += 3) {
        const A = y[E + 0],
          R = y[E + 1],
          T = y[E + 2];
        g.push(A, R, R, T, T, A);
      }
    } else {
      const y = v.array;
      x = v.version;
      for (let E = 0, M = y.length / 3 - 1; E < M; E += 3) {
        const A = E + 0,
          R = E + 1,
          T = E + 2;
        g.push(A, R, R, T, T, A);
      }
    }
    const b = new (Pv(g) > 65535 ? qv : Yv)(g, 1);
    b.version = x;
    const _ = r.get(m);
    _ && t.remove(_), r.set(m, b);
  }
  function f(m) {
    const g = r.get(m);
    if (g) {
      const p = m.index;
      p !== null && g.version < p.version && h(m);
    } else h(m);
    return r.get(m);
  }
  return { get: l, update: u, getWireframeAttribute: f };
}
function j3(a, t, e, n) {
  const i = n.isWebGL2;
  let r;
  function o(g) {
    r = g;
  }
  let l, u;
  function h(g) {
    (l = g.type), (u = g.bytesPerElement);
  }
  function f(g, p) {
    a.drawElements(r, p, l, g * u), e.update(p, r, 1);
  }
  function m(g, p, v) {
    if (v === 0) return;
    let x, b;
    if (i) (x = a), (b = "drawElementsInstanced");
    else if (
      ((x = t.get("ANGLE_instanced_arrays")),
      (b = "drawElementsInstancedANGLE"),
      x === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    x[b](r, p, l, g * u, v), e.update(p, r, v);
  }
  (this.setMode = o),
    (this.setIndex = h),
    (this.render = f),
    (this.renderInstances = m);
}
function J3(a) {
  const t = { geometries: 0, textures: 0 },
    e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(r, o, l) {
    switch ((e.calls++, o)) {
      case 4:
        e.triangles += l * (r / 3);
        break;
      case 1:
        e.lines += l * (r / 2);
        break;
      case 3:
        e.lines += l * (r - 1);
        break;
      case 2:
        e.lines += l * r;
        break;
      case 0:
        e.points += l * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    e.frame++, (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
  }
  return {
    memory: t,
    render: e,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n,
  };
}
class op extends Sn {
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null);
    (this.image = { data: t, width: e, height: n, depth: i }),
      (this.magFilter = mn),
      (this.minFilter = mn),
      (this.wrapR = di),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
}
op.prototype.isDataTexture2DArray = !0;
function $3(a, t) {
  return a[0] - t[0];
}
function K3(a, t) {
  return Math.abs(t[1]) - Math.abs(a[1]);
}
function sx(a, t) {
  let e = 1;
  const n = t.isInterleavedBufferAttribute ? t.data.array : t.array;
  n instanceof Int8Array
    ? (e = 127)
    : n instanceof Int16Array
    ? (e = 32767)
    : n instanceof Int32Array
    ? (e = 2147483647)
    : console.error(
        "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
        n
      ),
    a.divideScalar(e);
}
function Q3(a, t, e) {
  const n = {},
    i = new Float32Array(8),
    r = new WeakMap(),
    o = new k(),
    l = [];
  for (let h = 0; h < 8; h++) l[h] = [h, 0];
  function u(h, f, m, g) {
    const p = h.morphTargetInfluences;
    if (t.isWebGL2 === !0) {
      const v = f.morphAttributes.position.length;
      let x = r.get(f);
      if (x === void 0 || x.count !== v) {
        x !== void 0 && x.texture.dispose();
        const y = f.morphAttributes.normal !== void 0,
          E = f.morphAttributes.position,
          M = f.morphAttributes.normal || [],
          A = f.attributes.position.count,
          R = y === !0 ? 2 : 1;
        let T = A * R,
          B = 1;
        T > t.maxTextureSize &&
          ((B = Math.ceil(T / t.maxTextureSize)), (T = t.maxTextureSize));
        const X = new Float32Array(T * B * 4 * v),
          H = new op(X, T, B, v);
        (H.format = kn), (H.type = hs);
        const O = R * 4;
        for (let it = 0; it < v; it++) {
          const W = E[it],
            q = M[it],
            tt = T * B * 4 * it;
          for (let V = 0; V < W.count; V++) {
            o.fromBufferAttribute(W, V), W.normalized === !0 && sx(o, W);
            const Q = V * O;
            (X[tt + Q + 0] = o.x),
              (X[tt + Q + 1] = o.y),
              (X[tt + Q + 2] = o.z),
              (X[tt + Q + 3] = 0),
              y === !0 &&
                (o.fromBufferAttribute(q, V),
                q.normalized === !0 && sx(o, q),
                (X[tt + Q + 4] = o.x),
                (X[tt + Q + 5] = o.y),
                (X[tt + Q + 6] = o.z),
                (X[tt + Q + 7] = 0));
          }
        }
        (x = { count: v, texture: H, size: new Et(T, B) }), r.set(f, x);
      }
      let b = 0;
      for (let y = 0; y < p.length; y++) b += p[y];
      const _ = f.morphTargetsRelative ? 1 : 1 - b;
      g.getUniforms().setValue(a, "morphTargetBaseInfluence", _),
        g.getUniforms().setValue(a, "morphTargetInfluences", p),
        g.getUniforms().setValue(a, "morphTargetsTexture", x.texture, e),
        g.getUniforms().setValue(a, "morphTargetsTextureSize", x.size);
    } else {
      const v = p === void 0 ? 0 : p.length;
      let x = n[f.id];
      if (x === void 0 || x.length !== v) {
        x = [];
        for (let M = 0; M < v; M++) x[M] = [M, 0];
        n[f.id] = x;
      }
      for (let M = 0; M < v; M++) {
        const A = x[M];
        (A[0] = M), (A[1] = p[M]);
      }
      x.sort(K3);
      for (let M = 0; M < 8; M++)
        M < v && x[M][1]
          ? ((l[M][0] = x[M][0]), (l[M][1] = x[M][1]))
          : ((l[M][0] = Number.MAX_SAFE_INTEGER), (l[M][1] = 0));
      l.sort($3);
      const b = f.morphAttributes.position,
        _ = f.morphAttributes.normal;
      let y = 0;
      for (let M = 0; M < 8; M++) {
        const A = l[M],
          R = A[0],
          T = A[1];
        R !== Number.MAX_SAFE_INTEGER && T
          ? (b &&
              f.getAttribute("morphTarget" + M) !== b[R] &&
              f.setAttribute("morphTarget" + M, b[R]),
            _ &&
              f.getAttribute("morphNormal" + M) !== _[R] &&
              f.setAttribute("morphNormal" + M, _[R]),
            (i[M] = T),
            (y += T))
          : (b &&
              f.hasAttribute("morphTarget" + M) === !0 &&
              f.deleteAttribute("morphTarget" + M),
            _ &&
              f.hasAttribute("morphNormal" + M) === !0 &&
              f.deleteAttribute("morphNormal" + M),
            (i[M] = 0));
      }
      const E = f.morphTargetsRelative ? 1 : 1 - y;
      g.getUniforms().setValue(a, "morphTargetBaseInfluence", E),
        g.getUniforms().setValue(a, "morphTargetInfluences", i);
    }
  }
  return { update: u };
}
function tP(a, t, e, n) {
  let i = new WeakMap();
  function r(u) {
    const h = n.render.frame,
      f = u.geometry,
      m = t.get(u, f);
    return (
      i.get(m) !== h && (t.update(m), i.set(m, h)),
      u.isInstancedMesh &&
        (u.hasEventListener("dispose", l) === !1 &&
          u.addEventListener("dispose", l),
        e.update(u.instanceMatrix, 34962),
        u.instanceColor !== null && e.update(u.instanceColor, 34962)),
      m
    );
  }
  function o() {
    i = new WeakMap();
  }
  function l(u) {
    const h = u.target;
    h.removeEventListener("dispose", l),
      e.remove(h.instanceMatrix),
      h.instanceColor !== null && e.remove(h.instanceColor);
  }
  return { update: r, dispose: o };
}
class ox extends Sn {
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null);
    (this.image = { data: t, width: e, height: n, depth: i }),
      (this.magFilter = mn),
      (this.minFilter = mn),
      (this.wrapR = di),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
}
ox.prototype.isDataTexture3D = !0;
const ax = new Sn(),
  eP = new op(),
  nP = new ox(),
  lx = new Ou(),
  cx = [],
  ux = [],
  hx = new Float32Array(16),
  fx = new Float32Array(9),
  dx = new Float32Array(4);
function ya(a, t, e) {
  const n = a[0];
  if (n <= 0 || n > 0) return a;
  const i = t * e;
  let r = cx[i];
  if ((r === void 0 && ((r = new Float32Array(i)), (cx[i] = r)), t !== 0)) {
    n.toArray(r, 0);
    for (let o = 1, l = 0; o !== t; ++o) (l += e), a[o].toArray(r, l);
  }
  return r;
}
function Gn(a, t) {
  if (a.length !== t.length) return !1;
  for (let e = 0, n = a.length; e < n; e++) if (a[e] !== t[e]) return !1;
  return !0;
}
function In(a, t) {
  for (let e = 0, n = t.length; e < n; e++) a[e] = t[e];
}
function px(a, t) {
  let e = ux[t];
  e === void 0 && ((e = new Int32Array(t)), (ux[t] = e));
  for (let n = 0; n !== t; ++n) e[n] = a.allocateTextureUnit();
  return e;
}
function iP(a, t) {
  const e = this.cache;
  e[0] !== t && (a.uniform1f(this.addr, t), (e[0] = t));
}
function rP(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) &&
      (a.uniform2f(this.addr, t.x, t.y), (e[0] = t.x), (e[1] = t.y));
  else {
    if (Gn(e, t)) return;
    a.uniform2fv(this.addr, t), In(e, t);
  }
}
function sP(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) &&
      (a.uniform3f(this.addr, t.x, t.y, t.z),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z));
  else if (t.r !== void 0)
    (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) &&
      (a.uniform3f(this.addr, t.r, t.g, t.b),
      (e[0] = t.r),
      (e[1] = t.g),
      (e[2] = t.b));
  else {
    if (Gn(e, t)) return;
    a.uniform3fv(this.addr, t), In(e, t);
  }
}
function oP(a, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) &&
      (a.uniform4f(this.addr, t.x, t.y, t.z, t.w),
      (e[0] = t.x),
      (e[1] = t.y),
      (e[2] = t.z),
      (e[3] = t.w));
  else {
    if (Gn(e, t)) return;
    a.uniform4fv(this.addr, t), In(e, t);
  }
}
function aP(a, t) {
  const e = this.cache,
    n = t.elements;
  if (n === void 0) {
    if (Gn(e, t)) return;
    a.uniformMatrix2fv(this.addr, !1, t), In(e, t);
  } else {
    if (Gn(e, n)) return;
    dx.set(n), a.uniformMatrix2fv(this.addr, !1, dx), In(e, n);
  }
}
function lP(a, t) {
  const e = this.cache,
    n = t.elements;
  if (n === void 0) {
    if (Gn(e, t)) return;
    a.uniformMatrix3fv(this.addr, !1, t), In(e, t);
  } else {
    if (Gn(e, n)) return;
    fx.set(n), a.uniformMatrix3fv(this.addr, !1, fx), In(e, n);
  }
}
function cP(a, t) {
  const e = this.cache,
    n = t.elements;
  if (n === void 0) {
    if (Gn(e, t)) return;
    a.uniformMatrix4fv(this.addr, !1, t), In(e, t);
  } else {
    if (Gn(e, n)) return;
    hx.set(n), a.uniformMatrix4fv(this.addr, !1, hx), In(e, n);
  }
}
function uP(a, t) {
  const e = this.cache;
  e[0] !== t && (a.uniform1i(this.addr, t), (e[0] = t));
}
function hP(a, t) {
  const e = this.cache;
  Gn(e, t) || (a.uniform2iv(this.addr, t), In(e, t));
}
function fP(a, t) {
  const e = this.cache;
  Gn(e, t) || (a.uniform3iv(this.addr, t), In(e, t));
}
function dP(a, t) {
  const e = this.cache;
  Gn(e, t) || (a.uniform4iv(this.addr, t), In(e, t));
}
function pP(a, t) {
  const e = this.cache;
  e[0] !== t && (a.uniform1ui(this.addr, t), (e[0] = t));
}
function mP(a, t) {
  const e = this.cache;
  Gn(e, t) || (a.uniform2uiv(this.addr, t), In(e, t));
}
function gP(a, t) {
  const e = this.cache;
  Gn(e, t) || (a.uniform3uiv(this.addr, t), In(e, t));
}
function _P(a, t) {
  const e = this.cache;
  Gn(e, t) || (a.uniform4uiv(this.addr, t), In(e, t));
}
function vP(a, t, e) {
  const n = this.cache,
    i = e.allocateTextureUnit();
  n[0] !== i && (a.uniform1i(this.addr, i), (n[0] = i)),
    e.safeSetTexture2D(t || ax, i);
}
function xP(a, t, e) {
  const n = this.cache,
    i = e.allocateTextureUnit();
  n[0] !== i && (a.uniform1i(this.addr, i), (n[0] = i)),
    e.setTexture3D(t || nP, i);
}
function yP(a, t, e) {
  const n = this.cache,
    i = e.allocateTextureUnit();
  n[0] !== i && (a.uniform1i(this.addr, i), (n[0] = i)),
    e.safeSetTextureCube(t || lx, i);
}
function wP(a, t, e) {
  const n = this.cache,
    i = e.allocateTextureUnit();
  n[0] !== i && (a.uniform1i(this.addr, i), (n[0] = i)),
    e.setTexture2DArray(t || eP, i);
}
function bP(a) {
  switch (a) {
    case 5126:
      return iP;
    case 35664:
      return rP;
    case 35665:
      return sP;
    case 35666:
      return oP;
    case 35674:
      return aP;
    case 35675:
      return lP;
    case 35676:
      return cP;
    case 5124:
    case 35670:
      return uP;
    case 35667:
    case 35671:
      return hP;
    case 35668:
    case 35672:
      return fP;
    case 35669:
    case 35673:
      return dP;
    case 5125:
      return pP;
    case 36294:
      return mP;
    case 36295:
      return gP;
    case 36296:
      return _P;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return vP;
    case 35679:
    case 36299:
    case 36307:
      return xP;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return yP;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return wP;
  }
}
function MP(a, t) {
  a.uniform1fv(this.addr, t);
}
function SP(a, t) {
  const e = ya(t, this.size, 2);
  a.uniform2fv(this.addr, e);
}
function TP(a, t) {
  const e = ya(t, this.size, 3);
  a.uniform3fv(this.addr, e);
}
function EP(a, t) {
  const e = ya(t, this.size, 4);
  a.uniform4fv(this.addr, e);
}
function AP(a, t) {
  const e = ya(t, this.size, 4);
  a.uniformMatrix2fv(this.addr, !1, e);
}
function LP(a, t) {
  const e = ya(t, this.size, 9);
  a.uniformMatrix3fv(this.addr, !1, e);
}
function CP(a, t) {
  const e = ya(t, this.size, 16);
  a.uniformMatrix4fv(this.addr, !1, e);
}
function RP(a, t) {
  a.uniform1iv(this.addr, t);
}
function PP(a, t) {
  a.uniform2iv(this.addr, t);
}
function IP(a, t) {
  a.uniform3iv(this.addr, t);
}
function DP(a, t) {
  a.uniform4iv(this.addr, t);
}
function FP(a, t) {
  a.uniform1uiv(this.addr, t);
}
function OP(a, t) {
  a.uniform2uiv(this.addr, t);
}
function NP(a, t) {
  a.uniform3uiv(this.addr, t);
}
function BP(a, t) {
  a.uniform4uiv(this.addr, t);
}
function zP(a, t, e) {
  const n = t.length,
    i = px(e, n);
  a.uniform1iv(this.addr, i);
  for (let r = 0; r !== n; ++r) e.safeSetTexture2D(t[r] || ax, i[r]);
}
function UP(a, t, e) {
  const n = t.length,
    i = px(e, n);
  a.uniform1iv(this.addr, i);
  for (let r = 0; r !== n; ++r) e.safeSetTextureCube(t[r] || lx, i[r]);
}
function kP(a) {
  switch (a) {
    case 5126:
      return MP;
    case 35664:
      return SP;
    case 35665:
      return TP;
    case 35666:
      return EP;
    case 35674:
      return AP;
    case 35675:
      return LP;
    case 35676:
      return CP;
    case 5124:
    case 35670:
      return RP;
    case 35667:
    case 35671:
      return PP;
    case 35668:
    case 35672:
      return IP;
    case 35669:
    case 35673:
      return DP;
    case 5125:
      return FP;
    case 36294:
      return OP;
    case 36295:
      return NP;
    case 36296:
      return BP;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return zP;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return UP;
  }
}
function GP(a, t, e) {
  (this.id = a),
    (this.addr = e),
    (this.cache = []),
    (this.setValue = bP(t.type));
}
function mx(a, t, e) {
  (this.id = a),
    (this.addr = e),
    (this.cache = []),
    (this.size = t.size),
    (this.setValue = kP(t.type));
}
mx.prototype.updateCache = function (a) {
  const t = this.cache;
  a instanceof Float32Array &&
    t.length !== a.length &&
    (this.cache = new Float32Array(a.length)),
    In(t, a);
};
function gx(a) {
  (this.id = a), (this.seq = []), (this.map = {});
}
gx.prototype.setValue = function (a, t, e) {
  const n = this.seq;
  for (let i = 0, r = n.length; i !== r; ++i) {
    const o = n[i];
    o.setValue(a, t[o.id], e);
  }
};
const ap = /(\w+)(\])?(\[|\.)?/g;
function _x(a, t) {
  a.seq.push(t), (a.map[t.id] = t);
}
function HP(a, t, e) {
  const n = a.name,
    i = n.length;
  for (ap.lastIndex = 0; ; ) {
    const r = ap.exec(n),
      o = ap.lastIndex;
    let l = r[1];
    const u = r[2] === "]",
      h = r[3];
    if ((u && (l = l | 0), h === void 0 || (h === "[" && o + 2 === i))) {
      _x(e, h === void 0 ? new GP(l, a, t) : new mx(l, a, t));
      break;
    } else {
      let m = e.map[l];
      m === void 0 && ((m = new gx(l)), _x(e, m)), (e = m);
    }
  }
}
function ws(a, t) {
  (this.seq = []), (this.map = {});
  const e = a.getProgramParameter(t, 35718);
  for (let n = 0; n < e; ++n) {
    const i = a.getActiveUniform(t, n),
      r = a.getUniformLocation(t, i.name);
    HP(i, r, this);
  }
}
ws.prototype.setValue = function (a, t, e, n) {
  const i = this.map[t];
  i !== void 0 && i.setValue(a, e, n);
};
ws.prototype.setOptional = function (a, t, e) {
  const n = t[e];
  n !== void 0 && this.setValue(a, e, n);
};
ws.upload = function (a, t, e, n) {
  for (let i = 0, r = t.length; i !== r; ++i) {
    const o = t[i],
      l = e[o.id];
    l.needsUpdate !== !1 && o.setValue(a, l.value, n);
  }
};
ws.seqWithValue = function (a, t) {
  const e = [];
  for (let n = 0, i = a.length; n !== i; ++n) {
    const r = a[n];
    r.id in t && e.push(r);
  }
  return e;
};
function vx(a, t, e) {
  const n = a.createShader(t);
  return a.shaderSource(n, e), a.compileShader(n), n;
}
let VP = 0;
function WP(a) {
  const t = a.split(`
`);
  for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
  return t.join(`
`);
}
function xx(a) {
  switch (a) {
    case Cn:
      return ["Linear", "( value )"];
    case Js:
      return ["sRGB", "( value )"];
    case Md:
      return ["RGBE", "( value )"];
    case Ev:
      return ["RGBM", "( value, 7.0 )"];
    case Av:
      return ["RGBM", "( value, 16.0 )"];
    case Lv:
      return ["RGBD", "( value, 256.0 )"];
    case bd:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case BC:
      return ["LogLuv", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", a),
        ["Linear", "( value )"]
      );
  }
}
function yx(a, t, e) {
  const n = a.getShaderParameter(t, 35713),
    i = a.getShaderInfoLog(t).trim();
  return n && i === ""
    ? ""
    : e.toUpperCase() +
        `

` +
        i +
        `

` +
        WP(a.getShaderSource(t));
}
function io(a, t) {
  const e = xx(t);
  return (
    "vec4 " + a + "( vec4 value ) { return " + e[0] + "ToLinear" + e[1] + "; }"
  );
}
function XP(a, t) {
  const e = xx(t);
  return "vec4 " + a + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }";
}
function YP(a, t) {
  let e;
  switch (t) {
    case OL:
      e = "Linear";
      break;
    case NL:
      e = "Reinhard";
      break;
    case BL:
      e = "OptimizedCineon";
      break;
    case zL:
      e = "ACESFilmic";
      break;
    case UL:
      e = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
        (e = "Linear");
  }
  return (
    "vec3 " + a + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
  );
}
function qP(a) {
  return [
    a.extensionDerivatives ||
    a.envMapCubeUV ||
    a.bumpMap ||
    a.tangentSpaceNormalMap ||
    a.clearcoatNormalMap ||
    a.flatShading ||
    a.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (a.extensionFragDepth || a.logarithmicDepthBuffer) &&
    a.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    a.extensionDrawBuffers && a.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (a.extensionShaderTextureLOD || a.envMap || a.transmission) &&
    a.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(Tl).join(`
`);
}
function ZP(a) {
  const t = [];
  for (const e in a) {
    const n = a[e];
    n !== !1 && t.push("#define " + e + " " + n);
  }
  return t.join(`
`);
}
function jP(a, t) {
  const e = {},
    n = a.getProgramParameter(t, 35721);
  for (let i = 0; i < n; i++) {
    const r = a.getActiveAttrib(t, i),
      o = r.name;
    let l = 1;
    r.type === 35674 && (l = 2),
      r.type === 35675 && (l = 3),
      r.type === 35676 && (l = 4),
      (e[o] = {
        type: r.type,
        location: a.getAttribLocation(t, o),
        locationSize: l,
      });
  }
  return e;
}
function Tl(a) {
  return a !== "";
}
function wx(a, t) {
  return a
    .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
    .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function bx(a, t) {
  return a
    .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      t.numClippingPlanes - t.numClipIntersection
    );
}
const JP = /^[ \t]*#include +<([\w\d./]+)>/gm;
function lp(a) {
  return a.replace(JP, $P);
}
function $P(a, t) {
  const e = ce[t];
  if (e === void 0) throw new Error("Can not resolve #include <" + t + ">");
  return lp(e);
}
const KP =
    /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
  QP =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Mx(a) {
  return a.replace(QP, Sx).replace(KP, tI);
}
function tI(a, t, e, n) {
  return (
    console.warn(
      "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
    ),
    Sx(a, t, e, n)
  );
}
function Sx(a, t, e, n) {
  let i = "";
  for (let r = parseInt(t); r < parseInt(e); r++)
    i += n
      .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, r);
  return i;
}
function Tx(a) {
  let t =
    "precision " +
    a.precision +
    ` float;
precision ` +
    a.precision +
    " int;";
  return (
    a.precision === "highp"
      ? (t += `
#define HIGH_PRECISION`)
      : a.precision === "mediump"
      ? (t += `
#define MEDIUM_PRECISION`)
      : a.precision === "lowp" &&
        (t += `
#define LOW_PRECISION`),
    t
  );
}
function eI(a) {
  let t = "SHADOWMAP_TYPE_BASIC";
  return (
    a.shadowMapType === iv
      ? (t = "SHADOWMAP_TYPE_PCF")
      : a.shadowMapType === dL
      ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
      : a.shadowMapType === hl && (t = "SHADOWMAP_TYPE_VSM"),
    t
  );
}
function nI(a) {
  let t = "ENVMAP_TYPE_CUBE";
  if (a.envMap)
    switch (a.envMapMode) {
      case pl:
      case ml:
        t = "ENVMAP_TYPE_CUBE";
        break;
      case uu:
      case _d:
        t = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return t;
}
function iI(a) {
  let t = "ENVMAP_MODE_REFLECTION";
  if (a.envMap)
    switch (a.envMapMode) {
      case ml:
      case _d:
        t = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return t;
}
function rI(a) {
  let t = "ENVMAP_BLENDING_NONE";
  if (a.envMap)
    switch (a.combine) {
      case cu:
        t = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case DL:
        t = "ENVMAP_BLENDING_MIX";
        break;
      case FL:
        t = "ENVMAP_BLENDING_ADD";
        break;
    }
  return t;
}
function sI(a, t, e, n) {
  const i = a.getContext(),
    r = e.defines;
  let o = e.vertexShader,
    l = e.fragmentShader;
  const u = eI(e),
    h = nI(e),
    f = iI(e),
    m = rI(e),
    g = a.gammaFactor > 0 ? a.gammaFactor : 1,
    p = e.isWebGL2 ? "" : qP(e),
    v = ZP(r),
    x = i.createProgram();
  let b,
    _,
    y = e.glslVersion
      ? "#version " +
        e.glslVersion +
        `
`
      : "";
  e.isRawShaderMaterial
    ? ((b = [v].filter(Tl).join(`
`)),
      b.length > 0 &&
        (b += `
`),
      (_ = [p, v].filter(Tl).join(`
`)),
      _.length > 0 &&
        (_ += `
`))
    : ((b = [
        Tx(e),
        "#define SHADER_NAME " + e.shaderName,
        v,
        e.instancing ? "#define USE_INSTANCING" : "",
        e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define GAMMA_FACTOR " + g,
        "#define MAX_BONES " + e.maxBones,
        e.useFog && e.fog ? "#define USE_FOG" : "",
        e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
        e.map ? "#define USE_MAP" : "",
        e.envMap ? "#define USE_ENVMAP" : "",
        e.envMap ? "#define " + f : "",
        e.lightMap ? "#define USE_LIGHTMAP" : "",
        e.aoMap ? "#define USE_AOMAP" : "",
        e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        e.bumpMap ? "#define USE_BUMPMAP" : "",
        e.normalMap ? "#define USE_NORMALMAP" : "",
        e.normalMap && e.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        e.normalMap && e.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        e.displacementMap && e.supportsVertexTextures
          ? "#define USE_DISPLACEMENTMAP"
          : "",
        e.specularMap ? "#define USE_SPECULARMAP" : "",
        e.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        e.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        e.metalnessMap ? "#define USE_METALNESSMAP" : "",
        e.alphaMap ? "#define USE_ALPHAMAP" : "",
        e.transmission ? "#define USE_TRANSMISSION" : "",
        e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        e.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        e.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        e.vertexTangents ? "#define USE_TANGENT" : "",
        e.vertexColors ? "#define USE_COLOR" : "",
        e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        e.vertexUvs ? "#define USE_UV" : "",
        e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        e.flatShading ? "#define FLAT_SHADED" : "",
        e.skinning ? "#define USE_SKINNING" : "",
        e.useVertexTexture ? "#define BONE_TEXTURE" : "",
        e.morphTargets ? "#define USE_MORPHTARGETS" : "",
        e.morphNormals && e.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        e.morphTargets && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        e.morphTargets && e.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount
          : "",
        e.doubleSided ? "#define DOUBLE_SIDED" : "",
        e.flipSided ? "#define FLIP_SIDED" : "",
        e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        e.shadowMapEnabled ? "#define " + u : "",
        e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        e.logarithmicDepthBuffer && e.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Tl).join(`
`)),
      (_ = [
        p,
        Tx(e),
        "#define SHADER_NAME " + e.shaderName,
        v,
        "#define GAMMA_FACTOR " + g,
        e.useFog && e.fog ? "#define USE_FOG" : "",
        e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
        e.map ? "#define USE_MAP" : "",
        e.matcap ? "#define USE_MATCAP" : "",
        e.envMap ? "#define USE_ENVMAP" : "",
        e.envMap ? "#define " + h : "",
        e.envMap ? "#define " + f : "",
        e.envMap ? "#define " + m : "",
        e.lightMap ? "#define USE_LIGHTMAP" : "",
        e.aoMap ? "#define USE_AOMAP" : "",
        e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        e.bumpMap ? "#define USE_BUMPMAP" : "",
        e.normalMap ? "#define USE_NORMALMAP" : "",
        e.normalMap && e.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        e.normalMap && e.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        e.clearcoat ? "#define USE_CLEARCOAT" : "",
        e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        e.specularMap ? "#define USE_SPECULARMAP" : "",
        e.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        e.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        e.metalnessMap ? "#define USE_METALNESSMAP" : "",
        e.alphaMap ? "#define USE_ALPHAMAP" : "",
        e.alphaTest ? "#define USE_ALPHATEST" : "",
        e.sheen ? "#define USE_SHEEN" : "",
        e.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        e.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        e.transmission ? "#define USE_TRANSMISSION" : "",
        e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        e.vertexTangents ? "#define USE_TANGENT" : "",
        e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "",
        e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        e.vertexUvs ? "#define USE_UV" : "",
        e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        e.gradientMap ? "#define USE_GRADIENTMAP" : "",
        e.flatShading ? "#define FLAT_SHADED" : "",
        e.doubleSided ? "#define DOUBLE_SIDED" : "",
        e.flipSided ? "#define FLIP_SIDED" : "",
        e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        e.shadowMapEnabled ? "#define " + u : "",
        e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        e.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        e.logarithmicDepthBuffer && e.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        (e.extensionShaderTextureLOD || e.envMap) &&
        e.rendererExtensionShaderTextureLod
          ? "#define TEXTURE_LOD_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        e.toneMapping !== js ? "#define TONE_MAPPING" : "",
        e.toneMapping !== js ? ce.tonemapping_pars_fragment : "",
        e.toneMapping !== js ? YP("toneMapping", e.toneMapping) : "",
        e.dithering ? "#define DITHERING" : "",
        e.format === jo ? "#define OPAQUE" : "",
        ce.encodings_pars_fragment,
        e.map ? io("mapTexelToLinear", e.mapEncoding) : "",
        e.matcap ? io("matcapTexelToLinear", e.matcapEncoding) : "",
        e.envMap ? io("envMapTexelToLinear", e.envMapEncoding) : "",
        e.emissiveMap
          ? io("emissiveMapTexelToLinear", e.emissiveMapEncoding)
          : "",
        e.specularColorMap
          ? io("specularColorMapTexelToLinear", e.specularColorMapEncoding)
          : "",
        e.sheenColorMap
          ? io("sheenColorMapTexelToLinear", e.sheenColorMapEncoding)
          : "",
        e.lightMap ? io("lightMapTexelToLinear", e.lightMapEncoding) : "",
        XP("linearToOutputTexel", e.outputEncoding),
        e.depthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
        `
`,
      ].filter(Tl).join(`
`))),
    (o = lp(o)),
    (o = wx(o, e)),
    (o = bx(o, e)),
    (l = lp(l)),
    (l = wx(l, e)),
    (l = bx(l, e)),
    (o = Mx(o)),
    (l = Mx(l)),
    e.isWebGL2 &&
      e.isRawShaderMaterial !== !0 &&
      ((y = `#version 300 es
`),
      (b =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        b),
      (_ =
        [
          "#define varying in",
          e.glslVersion === Cv ? "" : "out highp vec4 pc_fragColor;",
          e.glslVersion === Cv ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        _));
  const E = y + b + o,
    M = y + _ + l,
    A = vx(i, 35633, E),
    R = vx(i, 35632, M);
  if (
    (i.attachShader(x, A),
    i.attachShader(x, R),
    e.index0AttributeName !== void 0
      ? i.bindAttribLocation(x, 0, e.index0AttributeName)
      : e.morphTargets === !0 && i.bindAttribLocation(x, 0, "position"),
    i.linkProgram(x),
    a.debug.checkShaderErrors)
  ) {
    const X = i.getProgramInfoLog(x).trim(),
      H = i.getShaderInfoLog(A).trim(),
      O = i.getShaderInfoLog(R).trim();
    let it = !0,
      W = !0;
    if (i.getProgramParameter(x, 35714) === !1) {
      it = !1;
      const q = yx(i, A, "vertex"),
        tt = yx(i, R, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " +
          i.getError() +
          " - VALIDATE_STATUS " +
          i.getProgramParameter(x, 35715) +
          `

Program Info Log: ` +
          X +
          `
` +
          q +
          `
` +
          tt
      );
    } else
      X !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", X)
        : (H === "" || O === "") && (W = !1);
    W &&
      (this.diagnostics = {
        runnable: it,
        programLog: X,
        vertexShader: { log: H, prefix: b },
        fragmentShader: { log: O, prefix: _ },
      });
  }
  i.deleteShader(A), i.deleteShader(R);
  let T;
  this.getUniforms = function () {
    return T === void 0 && (T = new ws(i, x)), T;
  };
  let B;
  return (
    (this.getAttributes = function () {
      return B === void 0 && (B = jP(i, x)), B;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        i.deleteProgram(x),
        (this.program = void 0);
    }),
    (this.name = e.shaderName),
    (this.id = VP++),
    (this.cacheKey = t),
    (this.usedTimes = 1),
    (this.program = x),
    (this.vertexShader = A),
    (this.fragmentShader = R),
    this
  );
}
function oI(a, t, e, n, i, r, o) {
  const l = [],
    u = i.isWebGL2,
    h = i.logarithmicDepthBuffer,
    f = i.floatVertexTextures,
    m = i.maxVertexUniforms,
    g = i.vertexTextures;
  let p = i.precision;
  const v = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    },
    x = [
      "precision",
      "isWebGL2",
      "supportsVertexTextures",
      "outputEncoding",
      "instancing",
      "instancingColor",
      "map",
      "mapEncoding",
      "matcap",
      "matcapEncoding",
      "envMap",
      "envMapMode",
      "envMapEncoding",
      "envMapCubeUV",
      "lightMap",
      "lightMapEncoding",
      "aoMap",
      "emissiveMap",
      "emissiveMapEncoding",
      "bumpMap",
      "normalMap",
      "objectSpaceNormalMap",
      "tangentSpaceNormalMap",
      "clearcoat",
      "clearcoatMap",
      "clearcoatRoughnessMap",
      "clearcoatNormalMap",
      "displacementMap",
      "specularMap",
      ,
      "roughnessMap",
      "metalnessMap",
      "gradientMap",
      "alphaMap",
      "alphaTest",
      "combine",
      "vertexColors",
      "vertexAlphas",
      "vertexTangents",
      "vertexUvs",
      "uvsVertexOnly",
      "fog",
      "useFog",
      "fogExp2",
      "flatShading",
      "sizeAttenuation",
      "logarithmicDepthBuffer",
      "skinning",
      "maxBones",
      "useVertexTexture",
      "morphTargets",
      "morphNormals",
      "morphTargetsCount",
      "premultipliedAlpha",
      "numDirLights",
      "numPointLights",
      "numSpotLights",
      "numHemiLights",
      "numRectAreaLights",
      "numDirLightShadows",
      "numPointLightShadows",
      "numSpotLightShadows",
      "shadowMapEnabled",
      "shadowMapType",
      "toneMapping",
      "physicallyCorrectLights",
      "doubleSided",
      "flipSided",
      "numClippingPlanes",
      "numClipIntersection",
      "depthPacking",
      "dithering",
      "format",
      "specularIntensityMap",
      "specularColorMap",
      "specularColorMapEncoding",
      "transmission",
      "transmissionMap",
      "thicknessMap",
      "sheen",
      "sheenColorMap",
      "sheenColorMapEncoding",
      "sheenRoughnessMap",
    ];
  function b(T) {
    const X = T.skeleton.bones;
    if (f) return 1024;
    {
      const O = Math.floor((m - 20) / 4),
        it = Math.min(O, X.length);
      return it < X.length
        ? (console.warn(
            "THREE.WebGLRenderer: Skeleton has " +
              X.length +
              " bones. This GPU supports " +
              it +
              "."
          ),
          0)
        : it;
    }
  }
  function _(T) {
    let B;
    return (
      T && T.isTexture
        ? (B = T.encoding)
        : T && T.isWebGLRenderTarget
        ? (console.warn(
            "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
          ),
          (B = T.texture.encoding))
        : (B = Cn),
      u &&
        T &&
        T.isTexture &&
        T.format === kn &&
        T.type === us &&
        T.encoding === Js &&
        (B = Cn),
      B
    );
  }
  function y(T, B, X, H, O) {
    const it = H.fog,
      W = T.isMeshStandardMaterial ? H.environment : null,
      q = (T.isMeshStandardMaterial ? e : t).get(T.envMap || W),
      tt = v[T.type],
      V = O.isSkinnedMesh ? b(O) : 0;
    T.precision !== null &&
      ((p = i.getMaxPrecision(T.precision)),
      p !== T.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          T.precision,
          "not supported, using",
          p,
          "instead."
        ));
    let Q, st;
    if (tt) {
      const ft = ar[tt];
      (Q = ft.vertexShader), (st = ft.fragmentShader);
    } else (Q = T.vertexShader), (st = T.fragmentShader);
    const Lt = a.getRenderTarget(),
      J = T.alphaTest > 0,
      vt = T.clearcoat > 0;
    return {
      isWebGL2: u,
      shaderID: tt,
      shaderName: T.type,
      vertexShader: Q,
      fragmentShader: st,
      defines: T.defines,
      isRawShaderMaterial: T.isRawShaderMaterial === !0,
      glslVersion: T.glslVersion,
      precision: p,
      instancing: O.isInstancedMesh === !0,
      instancingColor: O.isInstancedMesh === !0 && O.instanceColor !== null,
      supportsVertexTextures: g,
      outputEncoding: Lt !== null ? _(Lt.texture) : a.outputEncoding,
      map: !!T.map,
      mapEncoding: _(T.map),
      matcap: !!T.matcap,
      matcapEncoding: _(T.matcap),
      envMap: !!q,
      envMapMode: q && q.mapping,
      envMapEncoding: _(q),
      envMapCubeUV: !!q && (q.mapping === uu || q.mapping === _d),
      lightMap: !!T.lightMap,
      lightMapEncoding: _(T.lightMap),
      aoMap: !!T.aoMap,
      emissiveMap: !!T.emissiveMap,
      emissiveMapEncoding: _(T.emissiveMap),
      bumpMap: !!T.bumpMap,
      normalMap: !!T.normalMap,
      objectSpaceNormalMap: T.normalMapType === kC,
      tangentSpaceNormalMap: T.normalMapType === Qo,
      clearcoat: vt,
      clearcoatMap: vt && !!T.clearcoatMap,
      clearcoatRoughnessMap: vt && !!T.clearcoatRoughnessMap,
      clearcoatNormalMap: vt && !!T.clearcoatNormalMap,
      displacementMap: !!T.displacementMap,
      roughnessMap: !!T.roughnessMap,
      metalnessMap: !!T.metalnessMap,
      specularMap: !!T.specularMap,
      specularIntensityMap: !!T.specularIntensityMap,
      specularColorMap: !!T.specularColorMap,
      specularColorMapEncoding: _(T.specularColorMap),
      alphaMap: !!T.alphaMap,
      alphaTest: J,
      gradientMap: !!T.gradientMap,
      sheen: T.sheen > 0,
      sheenColorMap: !!T.sheenColorMap,
      sheenColorMapEncoding: _(T.sheenColorMap),
      sheenRoughnessMap: !!T.sheenRoughnessMap,
      transmission: T.transmission > 0,
      transmissionMap: !!T.transmissionMap,
      thicknessMap: !!T.thicknessMap,
      combine: T.combine,
      vertexTangents:
        !!T.normalMap && !!O.geometry && !!O.geometry.attributes.tangent,
      vertexColors: T.vertexColors,
      vertexAlphas:
        T.vertexColors === !0 &&
        !!O.geometry &&
        !!O.geometry.attributes.color &&
        O.geometry.attributes.color.itemSize === 4,
      vertexUvs:
        !!T.map ||
        !!T.bumpMap ||
        !!T.normalMap ||
        !!T.specularMap ||
        !!T.alphaMap ||
        !!T.emissiveMap ||
        !!T.roughnessMap ||
        !!T.metalnessMap ||
        !!T.clearcoatMap ||
        !!T.clearcoatRoughnessMap ||
        !!T.clearcoatNormalMap ||
        !!T.displacementMap ||
        !!T.transmissionMap ||
        !!T.thicknessMap ||
        !!T.specularIntensityMap ||
        !!T.specularColorMap ||
        !!T.sheenColorMap ||
        T.sheenRoughnessMap,
      uvsVertexOnly:
        !(
          !!T.map ||
          !!T.bumpMap ||
          !!T.normalMap ||
          !!T.specularMap ||
          !!T.alphaMap ||
          !!T.emissiveMap ||
          !!T.roughnessMap ||
          !!T.metalnessMap ||
          !!T.clearcoatNormalMap ||
          T.transmission > 0 ||
          !!T.transmissionMap ||
          !!T.thicknessMap ||
          !!T.specularIntensityMap ||
          !!T.specularColorMap ||
          !!T.sheen > 0 ||
          !!T.sheenColorMap ||
          !!T.sheenRoughnessMap
        ) && !!T.displacementMap,
      fog: !!it,
      useFog: T.fog,
      fogExp2: it && it.isFogExp2,
      flatShading: !!T.flatShading,
      sizeAttenuation: T.sizeAttenuation,
      logarithmicDepthBuffer: h,
      skinning: O.isSkinnedMesh === !0 && V > 0,
      maxBones: V,
      useVertexTexture: f,
      morphTargets: !!O.geometry && !!O.geometry.morphAttributes.position,
      morphNormals: !!O.geometry && !!O.geometry.morphAttributes.normal,
      morphTargetsCount:
        !!O.geometry && !!O.geometry.morphAttributes.position
          ? O.geometry.morphAttributes.position.length
          : 0,
      numDirLights: B.directional.length,
      numPointLights: B.point.length,
      numSpotLights: B.spot.length,
      numRectAreaLights: B.rectArea.length,
      numHemiLights: B.hemi.length,
      numDirLightShadows: B.directionalShadowMap.length,
      numPointLightShadows: B.pointShadowMap.length,
      numSpotLightShadows: B.spotShadowMap.length,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      format: T.format,
      dithering: T.dithering,
      shadowMapEnabled: a.shadowMap.enabled && X.length > 0,
      shadowMapType: a.shadowMap.type,
      toneMapping: T.toneMapped ? a.toneMapping : js,
      physicallyCorrectLights: a.physicallyCorrectLights,
      premultipliedAlpha: T.premultipliedAlpha,
      doubleSided: T.side === Yo,
      flipSided: T.side === un,
      depthPacking: T.depthPacking !== void 0 ? T.depthPacking : !1,
      index0AttributeName: T.index0AttributeName,
      extensionDerivatives: T.extensions && T.extensions.derivatives,
      extensionFragDepth: T.extensions && T.extensions.fragDepth,
      extensionDrawBuffers: T.extensions && T.extensions.drawBuffers,
      extensionShaderTextureLOD: T.extensions && T.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
      customProgramCacheKey: T.customProgramCacheKey(),
    };
  }
  function E(T) {
    const B = [];
    if (
      (T.shaderID
        ? B.push(T.shaderID)
        : (B.push(Iv(T.fragmentShader)), B.push(Iv(T.vertexShader))),
      T.defines !== void 0)
    )
      for (const X in T.defines) B.push(X), B.push(T.defines[X]);
    if (T.isRawShaderMaterial === !1) {
      for (let X = 0; X < x.length; X++) B.push(T[x[X]]);
      B.push(a.outputEncoding), B.push(a.gammaFactor);
    }
    return B.push(T.customProgramCacheKey), B.join();
  }
  function M(T) {
    const B = v[T.type];
    let X;
    if (B) {
      const H = ar[B];
      X = rR.clone(H.uniforms);
    } else X = T.uniforms;
    return X;
  }
  function A(T, B) {
    let X;
    for (let H = 0, O = l.length; H < O; H++) {
      const it = l[H];
      if (it.cacheKey === B) {
        (X = it), ++X.usedTimes;
        break;
      }
    }
    return X === void 0 && ((X = new sI(a, B, T, r)), l.push(X)), X;
  }
  function R(T) {
    if (--T.usedTimes == 0) {
      const B = l.indexOf(T);
      (l[B] = l[l.length - 1]), l.pop(), T.destroy();
    }
  }
  return {
    getParameters: y,
    getProgramCacheKey: E,
    getUniforms: M,
    acquireProgram: A,
    releaseProgram: R,
    programs: l,
  };
}
function aI() {
  let a = new WeakMap();
  function t(r) {
    let o = a.get(r);
    return o === void 0 && ((o = {}), a.set(r, o)), o;
  }
  function e(r) {
    a.delete(r);
  }
  function n(r, o, l) {
    a.get(r)[o] = l;
  }
  function i() {
    a = new WeakMap();
  }
  return { get: t, remove: e, update: n, dispose: i };
}
function lI(a, t) {
  return a.groupOrder !== t.groupOrder
    ? a.groupOrder - t.groupOrder
    : a.renderOrder !== t.renderOrder
    ? a.renderOrder - t.renderOrder
    : a.program !== t.program
    ? a.program.id - t.program.id
    : a.material.id !== t.material.id
    ? a.material.id - t.material.id
    : a.z !== t.z
    ? a.z - t.z
    : a.id - t.id;
}
function Ex(a, t) {
  return a.groupOrder !== t.groupOrder
    ? a.groupOrder - t.groupOrder
    : a.renderOrder !== t.renderOrder
    ? a.renderOrder - t.renderOrder
    : a.z !== t.z
    ? t.z - a.z
    : a.id - t.id;
}
function Ax(a) {
  const t = [];
  let e = 0;
  const n = [],
    i = [],
    r = [],
    o = { id: -1 };
  function l() {
    (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
  }
  function u(p, v, x, b, _, y) {
    let E = t[e];
    const M = a.get(x);
    return (
      E === void 0
        ? ((E = {
            id: p.id,
            object: p,
            geometry: v,
            material: x,
            program: M.program || o,
            groupOrder: b,
            renderOrder: p.renderOrder,
            z: _,
            group: y,
          }),
          (t[e] = E))
        : ((E.id = p.id),
          (E.object = p),
          (E.geometry = v),
          (E.material = x),
          (E.program = M.program || o),
          (E.groupOrder = b),
          (E.renderOrder = p.renderOrder),
          (E.z = _),
          (E.group = y)),
      e++,
      E
    );
  }
  function h(p, v, x, b, _, y) {
    const E = u(p, v, x, b, _, y);
    x.transmission > 0
      ? i.push(E)
      : x.transparent === !0
      ? r.push(E)
      : n.push(E);
  }
  function f(p, v, x, b, _, y) {
    const E = u(p, v, x, b, _, y);
    x.transmission > 0
      ? i.unshift(E)
      : x.transparent === !0
      ? r.unshift(E)
      : n.unshift(E);
  }
  function m(p, v) {
    n.length > 1 && n.sort(p || lI),
      i.length > 1 && i.sort(v || Ex),
      r.length > 1 && r.sort(v || Ex);
  }
  function g() {
    for (let p = e, v = t.length; p < v; p++) {
      const x = t[p];
      if (x.id === null) break;
      (x.id = null),
        (x.object = null),
        (x.geometry = null),
        (x.material = null),
        (x.program = null),
        (x.group = null);
    }
  }
  return {
    opaque: n,
    transmissive: i,
    transparent: r,
    init: l,
    push: h,
    unshift: f,
    finish: g,
    sort: m,
  };
}
function cI(a) {
  let t = new WeakMap();
  function e(i, r) {
    let o;
    return (
      t.has(i) === !1
        ? ((o = new Ax(a)), t.set(i, [o]))
        : r >= t.get(i).length
        ? ((o = new Ax(a)), t.get(i).push(o))
        : (o = t.get(i)[r]),
      o
    );
  }
  function n() {
    t = new WeakMap();
  }
  return { get: e, dispose: n };
}
function uI() {
  const a = {};
  return {
    get: function (t) {
      if (a[t.id] !== void 0) return a[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = { direction: new k(), color: new Xt() };
          break;
        case "SpotLight":
          e = {
            position: new k(),
            direction: new k(),
            color: new Xt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          e = { position: new k(), color: new Xt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          e = { direction: new k(), skyColor: new Xt(), groundColor: new Xt() };
          break;
        case "RectAreaLight":
          e = {
            color: new Xt(),
            position: new k(),
            halfWidth: new k(),
            halfHeight: new k(),
          };
          break;
      }
      return (a[t.id] = e), e;
    },
  };
}
function hI() {
  const a = {};
  return {
    get: function (t) {
      if (a[t.id] !== void 0) return a[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Et(),
          };
          break;
        case "SpotLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Et(),
          };
          break;
        case "PointLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Et(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (a[t.id] = e), e;
    },
  };
}
let fI = 0;
function dI(a, t) {
  return (t.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0);
}
function pI(a, t) {
  const e = new uI(),
    n = hI(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
    };
  for (let f = 0; f < 9; f++) i.probe.push(new k());
  const r = new k(),
    o = new Jt(),
    l = new Jt();
  function u(f, m) {
    let g = 0,
      p = 0,
      v = 0;
    for (let X = 0; X < 9; X++) i.probe[X].set(0, 0, 0);
    let x = 0,
      b = 0,
      _ = 0,
      y = 0,
      E = 0,
      M = 0,
      A = 0,
      R = 0;
    f.sort(dI);
    const T = m !== !0 ? Math.PI : 1;
    for (let X = 0, H = f.length; X < H; X++) {
      const O = f[X],
        it = O.color,
        W = O.intensity,
        q = O.distance,
        tt = O.shadow && O.shadow.map ? O.shadow.map.texture : null;
      if (O.isAmbientLight)
        (g += it.r * W * T), (p += it.g * W * T), (v += it.b * W * T);
      else if (O.isLightProbe)
        for (let V = 0; V < 9; V++)
          i.probe[V].addScaledVector(O.sh.coefficients[V], W);
      else if (O.isDirectionalLight) {
        const V = e.get(O);
        if (
          (V.color.copy(O.color).multiplyScalar(O.intensity * T), O.castShadow)
        ) {
          const Q = O.shadow,
            st = n.get(O);
          (st.shadowBias = Q.bias),
            (st.shadowNormalBias = Q.normalBias),
            (st.shadowRadius = Q.radius),
            (st.shadowMapSize = Q.mapSize),
            (i.directionalShadow[x] = st),
            (i.directionalShadowMap[x] = tt),
            (i.directionalShadowMatrix[x] = O.shadow.matrix),
            M++;
        }
        (i.directional[x] = V), x++;
      } else if (O.isSpotLight) {
        const V = e.get(O);
        if (
          (V.position.setFromMatrixPosition(O.matrixWorld),
          V.color.copy(it).multiplyScalar(W * T),
          (V.distance = q),
          (V.coneCos = Math.cos(O.angle)),
          (V.penumbraCos = Math.cos(O.angle * (1 - O.penumbra))),
          (V.decay = O.decay),
          O.castShadow)
        ) {
          const Q = O.shadow,
            st = n.get(O);
          (st.shadowBias = Q.bias),
            (st.shadowNormalBias = Q.normalBias),
            (st.shadowRadius = Q.radius),
            (st.shadowMapSize = Q.mapSize),
            (i.spotShadow[_] = st),
            (i.spotShadowMap[_] = tt),
            (i.spotShadowMatrix[_] = O.shadow.matrix),
            R++;
        }
        (i.spot[_] = V), _++;
      } else if (O.isRectAreaLight) {
        const V = e.get(O);
        V.color.copy(it).multiplyScalar(W),
          V.halfWidth.set(O.width * 0.5, 0, 0),
          V.halfHeight.set(0, O.height * 0.5, 0),
          (i.rectArea[y] = V),
          y++;
      } else if (O.isPointLight) {
        const V = e.get(O);
        if (
          (V.color.copy(O.color).multiplyScalar(O.intensity * T),
          (V.distance = O.distance),
          (V.decay = O.decay),
          O.castShadow)
        ) {
          const Q = O.shadow,
            st = n.get(O);
          (st.shadowBias = Q.bias),
            (st.shadowNormalBias = Q.normalBias),
            (st.shadowRadius = Q.radius),
            (st.shadowMapSize = Q.mapSize),
            (st.shadowCameraNear = Q.camera.near),
            (st.shadowCameraFar = Q.camera.far),
            (i.pointShadow[b] = st),
            (i.pointShadowMap[b] = tt),
            (i.pointShadowMatrix[b] = O.shadow.matrix),
            A++;
        }
        (i.point[b] = V), b++;
      } else if (O.isHemisphereLight) {
        const V = e.get(O);
        V.skyColor.copy(O.color).multiplyScalar(W * T),
          V.groundColor.copy(O.groundColor).multiplyScalar(W * T),
          (i.hemi[E] = V),
          E++;
      }
    }
    y > 0 &&
      (t.isWebGL2 || a.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = Pt.LTC_FLOAT_1), (i.rectAreaLTC2 = Pt.LTC_FLOAT_2))
        : a.has("OES_texture_half_float_linear") === !0
        ? ((i.rectAreaLTC1 = Pt.LTC_HALF_1), (i.rectAreaLTC2 = Pt.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (i.ambient[0] = g),
      (i.ambient[1] = p),
      (i.ambient[2] = v);
    const B = i.hash;
    (B.directionalLength !== x ||
      B.pointLength !== b ||
      B.spotLength !== _ ||
      B.rectAreaLength !== y ||
      B.hemiLength !== E ||
      B.numDirectionalShadows !== M ||
      B.numPointShadows !== A ||
      B.numSpotShadows !== R) &&
      ((i.directional.length = x),
      (i.spot.length = _),
      (i.rectArea.length = y),
      (i.point.length = b),
      (i.hemi.length = E),
      (i.directionalShadow.length = M),
      (i.directionalShadowMap.length = M),
      (i.pointShadow.length = A),
      (i.pointShadowMap.length = A),
      (i.spotShadow.length = R),
      (i.spotShadowMap.length = R),
      (i.directionalShadowMatrix.length = M),
      (i.pointShadowMatrix.length = A),
      (i.spotShadowMatrix.length = R),
      (B.directionalLength = x),
      (B.pointLength = b),
      (B.spotLength = _),
      (B.rectAreaLength = y),
      (B.hemiLength = E),
      (B.numDirectionalShadows = M),
      (B.numPointShadows = A),
      (B.numSpotShadows = R),
      (i.version = fI++));
  }
  function h(f, m) {
    let g = 0,
      p = 0,
      v = 0,
      x = 0,
      b = 0;
    const _ = m.matrixWorldInverse;
    for (let y = 0, E = f.length; y < E; y++) {
      const M = f[y];
      if (M.isDirectionalLight) {
        const A = i.directional[g];
        A.direction.setFromMatrixPosition(M.matrixWorld),
          r.setFromMatrixPosition(M.target.matrixWorld),
          A.direction.sub(r),
          A.direction.transformDirection(_),
          g++;
      } else if (M.isSpotLight) {
        const A = i.spot[v];
        A.position.setFromMatrixPosition(M.matrixWorld),
          A.position.applyMatrix4(_),
          A.direction.setFromMatrixPosition(M.matrixWorld),
          r.setFromMatrixPosition(M.target.matrixWorld),
          A.direction.sub(r),
          A.direction.transformDirection(_),
          v++;
      } else if (M.isRectAreaLight) {
        const A = i.rectArea[x];
        A.position.setFromMatrixPosition(M.matrixWorld),
          A.position.applyMatrix4(_),
          l.identity(),
          o.copy(M.matrixWorld),
          o.premultiply(_),
          l.extractRotation(o),
          A.halfWidth.set(M.width * 0.5, 0, 0),
          A.halfHeight.set(0, M.height * 0.5, 0),
          A.halfWidth.applyMatrix4(l),
          A.halfHeight.applyMatrix4(l),
          x++;
      } else if (M.isPointLight) {
        const A = i.point[p];
        A.position.setFromMatrixPosition(M.matrixWorld),
          A.position.applyMatrix4(_),
          p++;
      } else if (M.isHemisphereLight) {
        const A = i.hemi[b];
        A.direction.setFromMatrixPosition(M.matrixWorld),
          A.direction.transformDirection(_),
          A.direction.normalize(),
          b++;
      }
    }
  }
  return { setup: u, setupView: h, state: i };
}
function Lx(a, t) {
  const e = new pI(a, t),
    n = [],
    i = [];
  function r() {
    (n.length = 0), (i.length = 0);
  }
  function o(m) {
    n.push(m);
  }
  function l(m) {
    i.push(m);
  }
  function u(m) {
    e.setup(n, m);
  }
  function h(m) {
    e.setupView(n, m);
  }
  return {
    init: r,
    state: { lightsArray: n, shadowsArray: i, lights: e },
    setupLights: u,
    setupLightsView: h,
    pushLight: o,
    pushShadow: l,
  };
}
function mI(a, t) {
  let e = new WeakMap();
  function n(r, o = 0) {
    let l;
    return (
      e.has(r) === !1
        ? ((l = new Lx(a, t)), e.set(r, [l]))
        : o >= e.get(r).length
        ? ((l = new Lx(a, t)), e.get(r).push(l))
        : (l = e.get(r)[o]),
      l
    );
  }
  function i() {
    e = new WeakMap();
  }
  return { get: n, dispose: i };
}
class Cx extends Rn {
  constructor(t) {
    super();
    (this.type = "MeshDepthMaterial"),
      (this.depthPacking = zC),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.depthPacking = t.depthPacking),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      this
    );
  }
}
Cx.prototype.isMeshDepthMaterial = !0;
class Rx extends Rn {
  constructor(t) {
    super();
    (this.type = "MeshDistanceMaterial"),
      (this.referencePosition = new k()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.referencePosition.copy(t.referencePosition),
      (this.nearDistance = t.nearDistance),
      (this.farDistance = t.farDistance),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      this
    );
  }
}
Rx.prototype.isMeshDistanceMaterial = !0;
const gI = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  _I = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Px(a, t, e) {
  let n = new Bu();
  const i = new Et(),
    r = new Et(),
    o = new Fe(),
    l = new Cx({ depthPacking: UC }),
    u = new Rx(),
    h = {},
    f = e.maxTextureSize,
    m = { 0: un, 1: fl, 2: Yo },
    g = new eo({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Et() },
        radius: { value: 4 },
      },
      vertexShader: gI,
      fragmentShader: _I,
    }),
    p = g.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const v = new Ge();
  v.setAttribute(
    "position",
    new hn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const x = new ti(v, g),
    b = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = iv),
    (this.render = function (M, A, R) {
      if (
        b.enabled === !1 ||
        (b.autoUpdate === !1 && b.needsUpdate === !1) ||
        M.length === 0
      )
        return;
      const T = a.getRenderTarget(),
        B = a.getActiveCubeFace(),
        X = a.getActiveMipmapLevel(),
        H = a.state;
      H.setBlending(cs),
        H.buffers.color.setClear(1, 1, 1, 1),
        H.buffers.depth.setTest(!0),
        H.setScissorTest(!1);
      for (let O = 0, it = M.length; O < it; O++) {
        const W = M[O],
          q = W.shadow;
        if (q === void 0) {
          console.warn("THREE.WebGLShadowMap:", W, "has no shadow.");
          continue;
        }
        if (q.autoUpdate === !1 && q.needsUpdate === !1) continue;
        i.copy(q.mapSize);
        const tt = q.getFrameExtents();
        if (
          (i.multiply(tt),
          r.copy(q.mapSize),
          (i.x > f || i.y > f) &&
            (i.x > f &&
              ((r.x = Math.floor(f / tt.x)),
              (i.x = r.x * tt.x),
              (q.mapSize.x = r.x)),
            i.y > f &&
              ((r.y = Math.floor(f / tt.y)),
              (i.y = r.y * tt.y),
              (q.mapSize.y = r.y))),
          q.map === null && !q.isPointLightShadow && this.type === hl)
        ) {
          const Q = { minFilter: Oi, magFilter: Oi, format: kn };
          (q.map = new or(i.x, i.y, Q)),
            (q.map.texture.name = W.name + ".shadowMap"),
            (q.mapPass = new or(i.x, i.y, Q)),
            q.camera.updateProjectionMatrix();
        }
        if (q.map === null) {
          const Q = { minFilter: mn, magFilter: mn, format: kn };
          (q.map = new or(i.x, i.y, Q)),
            (q.map.texture.name = W.name + ".shadowMap"),
            q.camera.updateProjectionMatrix();
        }
        a.setRenderTarget(q.map), a.clear();
        const V = q.getViewportCount();
        for (let Q = 0; Q < V; Q++) {
          const st = q.getViewport(Q);
          o.set(r.x * st.x, r.y * st.y, r.x * st.z, r.y * st.w),
            H.viewport(o),
            q.updateMatrices(W, Q),
            (n = q.getFrustum()),
            E(A, R, q.camera, W, this.type);
        }
        !q.isPointLightShadow && this.type === hl && _(q, R),
          (q.needsUpdate = !1);
      }
      (b.needsUpdate = !1), a.setRenderTarget(T, B, X);
    });
  function _(M, A) {
    const R = t.update(x);
    g.defines.VSM_SAMPLES !== M.blurSamples &&
      ((g.defines.VSM_SAMPLES = M.blurSamples),
      (p.defines.VSM_SAMPLES = M.blurSamples),
      (g.needsUpdate = !0),
      (p.needsUpdate = !0)),
      (g.uniforms.shadow_pass.value = M.map.texture),
      (g.uniforms.resolution.value = M.mapSize),
      (g.uniforms.radius.value = M.radius),
      a.setRenderTarget(M.mapPass),
      a.clear(),
      a.renderBufferDirect(A, null, R, g, x, null),
      (p.uniforms.shadow_pass.value = M.mapPass.texture),
      (p.uniforms.resolution.value = M.mapSize),
      (p.uniforms.radius.value = M.radius),
      a.setRenderTarget(M.map),
      a.clear(),
      a.renderBufferDirect(A, null, R, p, x, null);
  }
  function y(M, A, R, T, B, X, H) {
    let O = null;
    const it =
      T.isPointLight === !0 ? M.customDistanceMaterial : M.customDepthMaterial;
    if (
      (it !== void 0 ? (O = it) : (O = T.isPointLight === !0 ? u : l),
      (a.localClippingEnabled &&
        R.clipShadows === !0 &&
        R.clippingPlanes.length !== 0) ||
        (R.displacementMap && R.displacementScale !== 0) ||
        (R.alphaMap && R.alphaTest > 0))
    ) {
      const W = O.uuid,
        q = R.uuid;
      let tt = h[W];
      tt === void 0 && ((tt = {}), (h[W] = tt));
      let V = tt[q];
      V === void 0 && ((V = O.clone()), (tt[q] = V)), (O = V);
    }
    return (
      (O.visible = R.visible),
      (O.wireframe = R.wireframe),
      H === hl
        ? (O.side = R.shadowSide !== null ? R.shadowSide : R.side)
        : (O.side = R.shadowSide !== null ? R.shadowSide : m[R.side]),
      (O.alphaMap = R.alphaMap),
      (O.alphaTest = R.alphaTest),
      (O.clipShadows = R.clipShadows),
      (O.clippingPlanes = R.clippingPlanes),
      (O.clipIntersection = R.clipIntersection),
      (O.displacementMap = R.displacementMap),
      (O.displacementScale = R.displacementScale),
      (O.displacementBias = R.displacementBias),
      (O.wireframeLinewidth = R.wireframeLinewidth),
      (O.linewidth = R.linewidth),
      T.isPointLight === !0 &&
        O.isMeshDistanceMaterial === !0 &&
        (O.referencePosition.setFromMatrixPosition(T.matrixWorld),
        (O.nearDistance = B),
        (O.farDistance = X)),
      O
    );
  }
  function E(M, A, R, T, B) {
    if (M.visible === !1) return;
    if (
      M.layers.test(A.layers) &&
      (M.isMesh || M.isLine || M.isPoints) &&
      (M.castShadow || (M.receiveShadow && B === hl)) &&
      (!M.frustumCulled || n.intersectsObject(M))
    ) {
      M.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, M.matrixWorld);
      const O = t.update(M),
        it = M.material;
      if (Array.isArray(it)) {
        const W = O.groups;
        for (let q = 0, tt = W.length; q < tt; q++) {
          const V = W[q],
            Q = it[V.materialIndex];
          if (Q && Q.visible) {
            const st = y(M, O, Q, T, R.near, R.far, B);
            a.renderBufferDirect(R, null, O, st, M, V);
          }
        }
      } else if (it.visible) {
        const W = y(M, O, it, T, R.near, R.far, B);
        a.renderBufferDirect(R, null, O, W, M, null);
      }
    }
    const H = M.children;
    for (let O = 0, it = H.length; O < it; O++) E(H[O], A, R, T, B);
  }
}
function vI(a, t, e) {
  const n = e.isWebGL2;
  function i() {
    let Y = !1;
    const Ct = new Fe();
    let _t = null;
    const Bt = new Fe(0, 0, 0, 0);
    return {
      setMask: function (Ft) {
        _t !== Ft && !Y && (a.colorMask(Ft, Ft, Ft, Ft), (_t = Ft));
      },
      setLocked: function (Ft) {
        Y = Ft;
      },
      setClear: function (Ft, ee, Be, He, Te) {
        Te === !0 && ((Ft *= He), (ee *= He), (Be *= He)),
          Ct.set(Ft, ee, Be, He),
          Bt.equals(Ct) === !1 && (a.clearColor(Ft, ee, Be, He), Bt.copy(Ct));
      },
      reset: function () {
        (Y = !1), (_t = null), Bt.set(-1, 0, 0, 0);
      },
    };
  }
  function r() {
    let Y = !1,
      Ct = null,
      _t = null,
      Bt = null;
    return {
      setTest: function (Ft) {
        Ft ? Mt(2929) : Tt(2929);
      },
      setMask: function (Ft) {
        Ct !== Ft && !Y && (a.depthMask(Ft), (Ct = Ft));
      },
      setFunc: function (Ft) {
        if (_t !== Ft) {
          if (Ft)
            switch (Ft) {
              case EL:
                a.depthFunc(512);
                break;
              case AL:
                a.depthFunc(519);
                break;
              case LL:
                a.depthFunc(513);
                break;
              case pd:
                a.depthFunc(515);
                break;
              case CL:
                a.depthFunc(514);
                break;
              case RL:
                a.depthFunc(518);
                break;
              case PL:
                a.depthFunc(516);
                break;
              case IL:
                a.depthFunc(517);
                break;
              default:
                a.depthFunc(515);
            }
          else a.depthFunc(515);
          _t = Ft;
        }
      },
      setLocked: function (Ft) {
        Y = Ft;
      },
      setClear: function (Ft) {
        Bt !== Ft && (a.clearDepth(Ft), (Bt = Ft));
      },
      reset: function () {
        (Y = !1), (Ct = null), (_t = null), (Bt = null);
      },
    };
  }
  function o() {
    let Y = !1,
      Ct = null,
      _t = null,
      Bt = null,
      Ft = null,
      ee = null,
      Be = null,
      He = null,
      Te = null;
    return {
      setTest: function (ve) {
        Y || (ve ? Mt(2960) : Tt(2960));
      },
      setMask: function (ve) {
        Ct !== ve && !Y && (a.stencilMask(ve), (Ct = ve));
      },
      setFunc: function (ve, je, rn) {
        (_t !== ve || Bt !== je || Ft !== rn) &&
          (a.stencilFunc(ve, je, rn), (_t = ve), (Bt = je), (Ft = rn));
      },
      setOp: function (ve, je, rn) {
        (ee !== ve || Be !== je || He !== rn) &&
          (a.stencilOp(ve, je, rn), (ee = ve), (Be = je), (He = rn));
      },
      setLocked: function (ve) {
        Y = ve;
      },
      setClear: function (ve) {
        Te !== ve && (a.clearStencil(ve), (Te = ve));
      },
      reset: function () {
        (Y = !1),
          (Ct = null),
          (_t = null),
          (Bt = null),
          (Ft = null),
          (ee = null),
          (Be = null),
          (He = null),
          (Te = null);
      },
    };
  }
  const l = new i(),
    u = new r(),
    h = new o();
  let f = {},
    m = null,
    g = {},
    p = null,
    v = !1,
    x = null,
    b = null,
    _ = null,
    y = null,
    E = null,
    M = null,
    A = null,
    R = !1,
    T = null,
    B = null,
    X = null,
    H = null,
    O = null;
  const it = a.getParameter(35661);
  let W = !1,
    q = 0;
  const tt = a.getParameter(7938);
  tt.indexOf("WebGL") !== -1
    ? ((q = parseFloat(/^WebGL (\d)/.exec(tt)[1])), (W = q >= 1))
    : tt.indexOf("OpenGL ES") !== -1 &&
      ((q = parseFloat(/^OpenGL ES (\d)/.exec(tt)[1])), (W = q >= 2));
  let V = null,
    Q = {};
  const st = a.getParameter(3088),
    Lt = a.getParameter(2978),
    J = new Fe().fromArray(st),
    vt = new Fe().fromArray(Lt);
  function zt(Y, Ct, _t) {
    const Bt = new Uint8Array(4),
      Ft = a.createTexture();
    a.bindTexture(Y, Ft),
      a.texParameteri(Y, 10241, 9728),
      a.texParameteri(Y, 10240, 9728);
    for (let ee = 0; ee < _t; ee++)
      a.texImage2D(Ct + ee, 0, 6408, 1, 1, 0, 6408, 5121, Bt);
    return Ft;
  }
  const ft = {};
  (ft[3553] = zt(3553, 3553, 1)),
    (ft[34067] = zt(34067, 34069, 6)),
    l.setClear(0, 0, 0, 1),
    u.setClear(1),
    h.setClear(0),
    Mt(2929),
    u.setFunc(pd),
    ot(!1),
    ct(nv),
    Mt(2884),
    gt(cs);
  function Mt(Y) {
    f[Y] !== !0 && (a.enable(Y), (f[Y] = !0));
  }
  function Tt(Y) {
    f[Y] !== !1 && (a.disable(Y), (f[Y] = !1));
  }
  function z(Y) {
    Y !== m && (a.bindFramebuffer(36160, Y), (m = Y));
  }
  function F(Y, Ct) {
    return (
      Ct === null && m !== null && (Ct = m),
      g[Y] !== Ct
        ? (a.bindFramebuffer(Y, Ct),
          (g[Y] = Ct),
          n && (Y === 36009 && (g[36160] = Ct), Y === 36160 && (g[36009] = Ct)),
          !0)
        : !1
    );
  }
  function U(Y) {
    return p !== Y ? (a.useProgram(Y), (p = Y), !0) : !1;
  }
  const et = { [qo]: 32774, [mL]: 32778, [gL]: 32779 };
  if (n) (et[lv] = 32775), (et[cv] = 32776);
  else {
    const Y = t.get("EXT_blend_minmax");
    Y !== null && ((et[lv] = Y.MIN_EXT), (et[cv] = Y.MAX_EXT));
  }
  const dt = {
    [_L]: 0,
    [vL]: 1,
    [xL]: 768,
    [uv]: 770,
    [TL]: 776,
    [ML]: 774,
    [wL]: 772,
    [yL]: 769,
    [hv]: 771,
    [SL]: 775,
    [bL]: 773,
  };
  function gt(Y, Ct, _t, Bt, Ft, ee, Be, He) {
    if (Y === cs) {
      v === !0 && (Tt(3042), (v = !1));
      return;
    }
    if ((v === !1 && (Mt(3042), (v = !0)), Y !== pL)) {
      if (Y !== x || He !== R) {
        if (
          ((b !== qo || E !== qo) &&
            (a.blendEquation(32774), (b = qo), (E = qo)),
          He)
        )
          switch (Y) {
            case dl:
              a.blendFuncSeparate(1, 771, 1, 771);
              break;
            case sv:
              a.blendFunc(1, 1);
              break;
            case ov:
              a.blendFuncSeparate(0, 0, 769, 771);
              break;
            case av:
              a.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Y);
              break;
          }
        else
          switch (Y) {
            case dl:
              a.blendFuncSeparate(770, 771, 1, 771);
              break;
            case sv:
              a.blendFunc(770, 1);
              break;
            case ov:
              a.blendFunc(0, 769);
              break;
            case av:
              a.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Y);
              break;
          }
        (_ = null), (y = null), (M = null), (A = null), (x = Y), (R = He);
      }
      return;
    }
    (Ft = Ft || Ct),
      (ee = ee || _t),
      (Be = Be || Bt),
      (Ct !== b || Ft !== E) &&
        (a.blendEquationSeparate(et[Ct], et[Ft]), (b = Ct), (E = Ft)),
      (_t !== _ || Bt !== y || ee !== M || Be !== A) &&
        (a.blendFuncSeparate(dt[_t], dt[Bt], dt[ee], dt[Be]),
        (_ = _t),
        (y = Bt),
        (M = ee),
        (A = Be)),
      (x = Y),
      (R = null);
  }
  function j(Y, Ct) {
    Y.side === Yo ? Tt(2884) : Mt(2884);
    let _t = Y.side === un;
    Ct && (_t = !_t),
      ot(_t),
      Y.blending === dl && Y.transparent === !1
        ? gt(cs)
        : gt(
            Y.blending,
            Y.blendEquation,
            Y.blendSrc,
            Y.blendDst,
            Y.blendEquationAlpha,
            Y.blendSrcAlpha,
            Y.blendDstAlpha,
            Y.premultipliedAlpha
          ),
      u.setFunc(Y.depthFunc),
      u.setTest(Y.depthTest),
      u.setMask(Y.depthWrite),
      l.setMask(Y.colorWrite);
    const Bt = Y.stencilWrite;
    h.setTest(Bt),
      Bt &&
        (h.setMask(Y.stencilWriteMask),
        h.setFunc(Y.stencilFunc, Y.stencilRef, Y.stencilFuncMask),
        h.setOp(Y.stencilFail, Y.stencilZFail, Y.stencilZPass)),
      xt(Y.polygonOffset, Y.polygonOffsetFactor, Y.polygonOffsetUnits),
      Y.alphaToCoverage === !0 ? Mt(32926) : Tt(32926);
  }
  function ot(Y) {
    T !== Y && (Y ? a.frontFace(2304) : a.frontFace(2305), (T = Y));
  }
  function ct(Y) {
    Y !== hL
      ? (Mt(2884),
        Y !== B &&
          (Y === nv
            ? a.cullFace(1029)
            : Y === fL
            ? a.cullFace(1028)
            : a.cullFace(1032)))
      : Tt(2884),
      (B = Y);
  }
  function St(Y) {
    Y !== X && (W && a.lineWidth(Y), (X = Y));
  }
  function xt(Y, Ct, _t) {
    Y
      ? (Mt(32823),
        (H !== Ct || O !== _t) && (a.polygonOffset(Ct, _t), (H = Ct), (O = _t)))
      : Tt(32823);
  }
  function I(Y) {
    Y ? Mt(3089) : Tt(3089);
  }
  function P(Y) {
    Y === void 0 && (Y = 33984 + it - 1),
      V !== Y && (a.activeTexture(Y), (V = Y));
  }
  function lt(Y, Ct) {
    V === null && P();
    let _t = Q[V];
    _t === void 0 && ((_t = { type: void 0, texture: void 0 }), (Q[V] = _t)),
      (_t.type !== Y || _t.texture !== Ct) &&
        (a.bindTexture(Y, Ct || ft[Y]), (_t.type = Y), (_t.texture = Ct));
  }
  function yt() {
    const Y = Q[V];
    Y !== void 0 &&
      Y.type !== void 0 &&
      (a.bindTexture(Y.type, null), (Y.type = void 0), (Y.texture = void 0));
  }
  function wt() {
    try {
      a.compressedTexImage2D.apply(a, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function At() {
    try {
      a.texImage2D.apply(a, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function Ht() {
    try {
      a.texImage3D.apply(a, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function Ut(Y) {
    J.equals(Y) === !1 && (a.scissor(Y.x, Y.y, Y.z, Y.w), J.copy(Y));
  }
  function Vt(Y) {
    vt.equals(Y) === !1 && (a.viewport(Y.x, Y.y, Y.z, Y.w), vt.copy(Y));
  }
  function Nt() {
    a.disable(3042),
      a.disable(2884),
      a.disable(2929),
      a.disable(32823),
      a.disable(3089),
      a.disable(2960),
      a.disable(32926),
      a.blendEquation(32774),
      a.blendFunc(1, 0),
      a.blendFuncSeparate(1, 0, 1, 0),
      a.colorMask(!0, !0, !0, !0),
      a.clearColor(0, 0, 0, 0),
      a.depthMask(!0),
      a.depthFunc(513),
      a.clearDepth(1),
      a.stencilMask(4294967295),
      a.stencilFunc(519, 0, 4294967295),
      a.stencilOp(7680, 7680, 7680),
      a.clearStencil(0),
      a.cullFace(1029),
      a.frontFace(2305),
      a.polygonOffset(0, 0),
      a.activeTexture(33984),
      a.bindFramebuffer(36160, null),
      n === !0 &&
        (a.bindFramebuffer(36009, null), a.bindFramebuffer(36008, null)),
      a.useProgram(null),
      a.lineWidth(1),
      a.scissor(0, 0, a.canvas.width, a.canvas.height),
      a.viewport(0, 0, a.canvas.width, a.canvas.height),
      (f = {}),
      (V = null),
      (Q = {}),
      (m = null),
      (g = {}),
      (p = null),
      (v = !1),
      (x = null),
      (b = null),
      (_ = null),
      (y = null),
      (E = null),
      (M = null),
      (A = null),
      (R = !1),
      (T = null),
      (B = null),
      (X = null),
      (H = null),
      (O = null),
      J.set(0, 0, a.canvas.width, a.canvas.height),
      vt.set(0, 0, a.canvas.width, a.canvas.height),
      l.reset(),
      u.reset(),
      h.reset();
  }
  return {
    buffers: { color: l, depth: u, stencil: h },
    enable: Mt,
    disable: Tt,
    bindFramebuffer: F,
    bindXRFramebuffer: z,
    useProgram: U,
    setBlending: gt,
    setMaterial: j,
    setFlipSided: ot,
    setCullFace: ct,
    setLineWidth: St,
    setPolygonOffset: xt,
    setScissorTest: I,
    activeTexture: P,
    bindTexture: lt,
    unbindTexture: yt,
    compressedTexImage2D: wt,
    texImage2D: At,
    texImage3D: Ht,
    scissor: Ut,
    viewport: Vt,
    reset: Nt,
  };
}
function xI(a, t, e, n, i, r, o) {
  const l = i.isWebGL2,
    u = i.maxTextures,
    h = i.maxCubemapSize,
    f = i.maxTextureSize,
    m = i.maxSamples,
    g = new WeakMap();
  let p,
    v = !1;
  try {
    v =
      typeof OffscreenCanvas != "undefined" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function x(I, P) {
    return v ? new OffscreenCanvas(I, P) : vu("canvas");
  }
  function b(I, P, lt, yt) {
    let wt = 1;
    if (
      ((I.width > yt || I.height > yt) &&
        (wt = yt / Math.max(I.width, I.height)),
      wt < 1 || P === !0)
    )
      if (
        (typeof HTMLImageElement != "undefined" &&
          I instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement != "undefined" &&
          I instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap != "undefined" && I instanceof ImageBitmap)
      ) {
        const At = P ? WC : Math.floor,
          Ht = At(wt * I.width),
          Ut = At(wt * I.height);
        p === void 0 && (p = x(Ht, Ut));
        const Vt = lt ? x(Ht, Ut) : p;
        return (
          (Vt.width = Ht),
          (Vt.height = Ut),
          Vt.getContext("2d").drawImage(I, 0, 0, Ht, Ut),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              I.width +
              "x" +
              I.height +
              ") to (" +
              Ht +
              "x" +
              Ut +
              ")."
          ),
          Vt
        );
      } else
        return (
          "data" in I &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                I.width +
                "x" +
                I.height +
                ")."
            ),
          I
        );
    return I;
  }
  function _(I) {
    return Rv(I.width) && Rv(I.height);
  }
  function y(I) {
    return l
      ? !1
      : I.wrapS !== di ||
          I.wrapT !== di ||
          (I.minFilter !== mn && I.minFilter !== Oi);
  }
  function E(I, P) {
    return I.generateMipmaps && P && I.minFilter !== mn && I.minFilter !== Oi;
  }
  function M(I, P, lt, yt, wt = 1) {
    a.generateMipmap(I);
    const At = n.get(P);
    At.__maxMipLevel = Math.log2(Math.max(lt, yt, wt));
  }
  function A(I, P, lt, yt) {
    if (l === !1) return P;
    if (I !== null) {
      if (a[I] !== void 0) return a[I];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          I +
          "'"
      );
    }
    let wt = P;
    return (
      P === 6403 &&
        (lt === 5126 && (wt = 33326),
        lt === 5131 && (wt = 33325),
        lt === 5121 && (wt = 33321)),
      P === 6407 &&
        (lt === 5126 && (wt = 34837),
        lt === 5131 && (wt = 34843),
        lt === 5121 && (wt = 32849)),
      P === 6408 &&
        (lt === 5126 && (wt = 34836),
        lt === 5131 && (wt = 34842),
        lt === 5121 && (wt = yt === Js ? 35907 : 32856)),
      (wt === 33325 || wt === 33326 || wt === 34842 || wt === 34836) &&
        t.get("EXT_color_buffer_float"),
      wt
    );
  }
  function R(I) {
    return I === mn || I === dv || I === pv ? 9728 : 9729;
  }
  function T(I) {
    const P = I.target;
    P.removeEventListener("dispose", T),
      X(P),
      P.isVideoTexture && g.delete(P),
      o.memory.textures--;
  }
  function B(I) {
    const P = I.target;
    P.removeEventListener("dispose", B), H(P);
  }
  function X(I) {
    const P = n.get(I);
    P.__webglInit !== void 0 &&
      (a.deleteTexture(P.__webglTexture), n.remove(I));
  }
  function H(I) {
    const P = I.texture,
      lt = n.get(I),
      yt = n.get(P);
    if (!!I) {
      if (
        (yt.__webglTexture !== void 0 &&
          (a.deleteTexture(yt.__webglTexture), o.memory.textures--),
        I.depthTexture && I.depthTexture.dispose(),
        I.isWebGLCubeRenderTarget)
      )
        for (let wt = 0; wt < 6; wt++)
          a.deleteFramebuffer(lt.__webglFramebuffer[wt]),
            lt.__webglDepthbuffer &&
              a.deleteRenderbuffer(lt.__webglDepthbuffer[wt]);
      else
        a.deleteFramebuffer(lt.__webglFramebuffer),
          lt.__webglDepthbuffer && a.deleteRenderbuffer(lt.__webglDepthbuffer),
          lt.__webglMultisampledFramebuffer &&
            a.deleteFramebuffer(lt.__webglMultisampledFramebuffer),
          lt.__webglColorRenderbuffer &&
            a.deleteRenderbuffer(lt.__webglColorRenderbuffer),
          lt.__webglDepthRenderbuffer &&
            a.deleteRenderbuffer(lt.__webglDepthRenderbuffer);
      if (I.isWebGLMultipleRenderTargets)
        for (let wt = 0, At = P.length; wt < At; wt++) {
          const Ht = n.get(P[wt]);
          Ht.__webglTexture &&
            (a.deleteTexture(Ht.__webglTexture), o.memory.textures--),
            n.remove(P[wt]);
        }
      n.remove(P), n.remove(I);
    }
  }
  let O = 0;
  function it() {
    O = 0;
  }
  function W() {
    const I = O;
    return (
      I >= u &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            I +
            " texture units while this GPU supports only " +
            u
        ),
      (O += 1),
      I
    );
  }
  function q(I, P) {
    const lt = n.get(I);
    if (
      (I.isVideoTexture && j(I), I.version > 0 && lt.__version !== I.version)
    ) {
      const yt = I.image;
      if (yt === void 0)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is undefined"
        );
      else if (yt.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        zt(lt, I, P);
        return;
      }
    }
    e.activeTexture(33984 + P), e.bindTexture(3553, lt.__webglTexture);
  }
  function tt(I, P) {
    const lt = n.get(I);
    if (I.version > 0 && lt.__version !== I.version) {
      zt(lt, I, P);
      return;
    }
    e.activeTexture(33984 + P), e.bindTexture(35866, lt.__webglTexture);
  }
  function V(I, P) {
    const lt = n.get(I);
    if (I.version > 0 && lt.__version !== I.version) {
      zt(lt, I, P);
      return;
    }
    e.activeTexture(33984 + P), e.bindTexture(32879, lt.__webglTexture);
  }
  function Q(I, P) {
    const lt = n.get(I);
    if (I.version > 0 && lt.__version !== I.version) {
      ft(lt, I, P);
      return;
    }
    e.activeTexture(33984 + P), e.bindTexture(34067, lt.__webglTexture);
  }
  const st = { [vd]: 10497, [di]: 33071, [xd]: 33648 },
    Lt = {
      [mn]: 9728,
      [dv]: 9984,
      [pv]: 9986,
      [Oi]: 9729,
      [kL]: 9985,
      [hu]: 9987,
    };
  function J(I, P, lt) {
    if (
      (lt
        ? (a.texParameteri(I, 10242, st[P.wrapS]),
          a.texParameteri(I, 10243, st[P.wrapT]),
          (I === 32879 || I === 35866) &&
            a.texParameteri(I, 32882, st[P.wrapR]),
          a.texParameteri(I, 10240, Lt[P.magFilter]),
          a.texParameteri(I, 10241, Lt[P.minFilter]))
        : (a.texParameteri(I, 10242, 33071),
          a.texParameteri(I, 10243, 33071),
          (I === 32879 || I === 35866) && a.texParameteri(I, 32882, 33071),
          (P.wrapS !== di || P.wrapT !== di) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          a.texParameteri(I, 10240, R(P.magFilter)),
          a.texParameteri(I, 10241, R(P.minFilter)),
          P.minFilter !== mn &&
            P.minFilter !== Oi &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      t.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const yt = t.get("EXT_texture_filter_anisotropic");
      if (
        (P.type === hs && t.has("OES_texture_float_linear") === !1) ||
        (l === !1 &&
          P.type === Zo &&
          t.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (P.anisotropy > 1 || n.get(P).__currentAnisotropy) &&
        (a.texParameterf(
          I,
          yt.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(P.anisotropy, i.getMaxAnisotropy())
        ),
        (n.get(P).__currentAnisotropy = P.anisotropy));
    }
  }
  function vt(I, P) {
    I.__webglInit === void 0 &&
      ((I.__webglInit = !0),
      P.addEventListener("dispose", T),
      (I.__webglTexture = a.createTexture()),
      o.memory.textures++);
  }
  function zt(I, P, lt) {
    let yt = 3553;
    P.isDataTexture2DArray && (yt = 35866),
      P.isDataTexture3D && (yt = 32879),
      vt(I, P),
      e.activeTexture(33984 + lt),
      e.bindTexture(yt, I.__webglTexture),
      a.pixelStorei(37440, P.flipY),
      a.pixelStorei(37441, P.premultiplyAlpha),
      a.pixelStorei(3317, P.unpackAlignment),
      a.pixelStorei(37443, 0);
    const wt = y(P) && _(P.image) === !1,
      At = b(P.image, wt, !1, f),
      Ht = _(At) || l,
      Ut = r.convert(P.format);
    let Vt = r.convert(P.type),
      Nt = A(P.internalFormat, Ut, Vt, P.encoding);
    J(yt, P, Ht);
    let Y;
    const Ct = P.mipmaps;
    if (P.isDepthTexture)
      (Nt = 6402),
        l
          ? P.type === hs
            ? (Nt = 36012)
            : P.type === du
            ? (Nt = 33190)
            : P.type === gl
            ? (Nt = 35056)
            : (Nt = 33189)
          : P.type === hs &&
            console.error(
              "WebGLRenderer: Floating point depth texture requires WebGL2."
            ),
        P.format === Jo &&
          Nt === 6402 &&
          P.type !== fu &&
          P.type !== du &&
          (console.warn(
            "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
          ),
          (P.type = fu),
          (Vt = r.convert(P.type))),
        P.format === _l &&
          Nt === 6402 &&
          ((Nt = 34041),
          P.type !== gl &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
            ),
            (P.type = gl),
            (Vt = r.convert(P.type)))),
        e.texImage2D(3553, 0, Nt, At.width, At.height, 0, Ut, Vt, null);
    else if (P.isDataTexture)
      if (Ct.length > 0 && Ht) {
        for (let _t = 0, Bt = Ct.length; _t < Bt; _t++)
          (Y = Ct[_t]),
            e.texImage2D(3553, _t, Nt, Y.width, Y.height, 0, Ut, Vt, Y.data);
        (P.generateMipmaps = !1), (I.__maxMipLevel = Ct.length - 1);
      } else
        e.texImage2D(3553, 0, Nt, At.width, At.height, 0, Ut, Vt, At.data),
          (I.__maxMipLevel = 0);
    else if (P.isCompressedTexture) {
      for (let _t = 0, Bt = Ct.length; _t < Bt; _t++)
        (Y = Ct[_t]),
          P.format !== kn && P.format !== jo
            ? Ut !== null
              ? e.compressedTexImage2D(
                  3553,
                  _t,
                  Nt,
                  Y.width,
                  Y.height,
                  0,
                  Y.data
                )
              : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                )
            : e.texImage2D(3553, _t, Nt, Y.width, Y.height, 0, Ut, Vt, Y.data);
      I.__maxMipLevel = Ct.length - 1;
    } else if (P.isDataTexture2DArray)
      e.texImage3D(
        35866,
        0,
        Nt,
        At.width,
        At.height,
        At.depth,
        0,
        Ut,
        Vt,
        At.data
      ),
        (I.__maxMipLevel = 0);
    else if (P.isDataTexture3D)
      e.texImage3D(
        32879,
        0,
        Nt,
        At.width,
        At.height,
        At.depth,
        0,
        Ut,
        Vt,
        At.data
      ),
        (I.__maxMipLevel = 0);
    else if (Ct.length > 0 && Ht) {
      for (let _t = 0, Bt = Ct.length; _t < Bt; _t++)
        (Y = Ct[_t]), e.texImage2D(3553, _t, Nt, Ut, Vt, Y);
      (P.generateMipmaps = !1), (I.__maxMipLevel = Ct.length - 1);
    } else e.texImage2D(3553, 0, Nt, Ut, Vt, At), (I.__maxMipLevel = 0);
    E(P, Ht) && M(yt, P, At.width, At.height),
      (I.__version = P.version),
      P.onUpdate && P.onUpdate(P);
  }
  function ft(I, P, lt) {
    if (P.image.length !== 6) return;
    vt(I, P),
      e.activeTexture(33984 + lt),
      e.bindTexture(34067, I.__webglTexture),
      a.pixelStorei(37440, P.flipY),
      a.pixelStorei(37441, P.premultiplyAlpha),
      a.pixelStorei(3317, P.unpackAlignment),
      a.pixelStorei(37443, 0);
    const yt = P && (P.isCompressedTexture || P.image[0].isCompressedTexture),
      wt = P.image[0] && P.image[0].isDataTexture,
      At = [];
    for (let _t = 0; _t < 6; _t++)
      !yt && !wt
        ? (At[_t] = b(P.image[_t], !1, !0, h))
        : (At[_t] = wt ? P.image[_t].image : P.image[_t]);
    const Ht = At[0],
      Ut = _(Ht) || l,
      Vt = r.convert(P.format),
      Nt = r.convert(P.type),
      Y = A(P.internalFormat, Vt, Nt, P.encoding);
    J(34067, P, Ut);
    let Ct;
    if (yt) {
      for (let _t = 0; _t < 6; _t++) {
        Ct = At[_t].mipmaps;
        for (let Bt = 0; Bt < Ct.length; Bt++) {
          const Ft = Ct[Bt];
          P.format !== kn && P.format !== jo
            ? Vt !== null
              ? e.compressedTexImage2D(
                  34069 + _t,
                  Bt,
                  Y,
                  Ft.width,
                  Ft.height,
                  0,
                  Ft.data
                )
              : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                )
            : e.texImage2D(
                34069 + _t,
                Bt,
                Y,
                Ft.width,
                Ft.height,
                0,
                Vt,
                Nt,
                Ft.data
              );
        }
      }
      I.__maxMipLevel = Ct.length - 1;
    } else {
      Ct = P.mipmaps;
      for (let _t = 0; _t < 6; _t++)
        if (wt) {
          e.texImage2D(
            34069 + _t,
            0,
            Y,
            At[_t].width,
            At[_t].height,
            0,
            Vt,
            Nt,
            At[_t].data
          );
          for (let Bt = 0; Bt < Ct.length; Bt++) {
            const ee = Ct[Bt].image[_t].image;
            e.texImage2D(
              34069 + _t,
              Bt + 1,
              Y,
              ee.width,
              ee.height,
              0,
              Vt,
              Nt,
              ee.data
            );
          }
        } else {
          e.texImage2D(34069 + _t, 0, Y, Vt, Nt, At[_t]);
          for (let Bt = 0; Bt < Ct.length; Bt++) {
            const Ft = Ct[Bt];
            e.texImage2D(34069 + _t, Bt + 1, Y, Vt, Nt, Ft.image[_t]);
          }
        }
      I.__maxMipLevel = Ct.length;
    }
    E(P, Ut) && M(34067, P, Ht.width, Ht.height),
      (I.__version = P.version),
      P.onUpdate && P.onUpdate(P);
  }
  function Mt(I, P, lt, yt, wt) {
    const At = r.convert(lt.format),
      Ht = r.convert(lt.type),
      Ut = A(lt.internalFormat, At, Ht, lt.encoding);
    wt === 32879 || wt === 35866
      ? e.texImage3D(wt, 0, Ut, P.width, P.height, P.depth, 0, At, Ht, null)
      : e.texImage2D(wt, 0, Ut, P.width, P.height, 0, At, Ht, null),
      e.bindFramebuffer(36160, I),
      a.framebufferTexture2D(36160, yt, wt, n.get(lt).__webglTexture, 0),
      e.bindFramebuffer(36160, null);
  }
  function Tt(I, P, lt) {
    if ((a.bindRenderbuffer(36161, I), P.depthBuffer && !P.stencilBuffer)) {
      let yt = 33189;
      if (lt) {
        const wt = P.depthTexture;
        wt &&
          wt.isDepthTexture &&
          (wt.type === hs ? (yt = 36012) : wt.type === du && (yt = 33190));
        const At = gt(P);
        a.renderbufferStorageMultisample(36161, At, yt, P.width, P.height);
      } else a.renderbufferStorage(36161, yt, P.width, P.height);
      a.framebufferRenderbuffer(36160, 36096, 36161, I);
    } else if (P.depthBuffer && P.stencilBuffer) {
      if (lt) {
        const yt = gt(P);
        a.renderbufferStorageMultisample(36161, yt, 35056, P.width, P.height);
      } else a.renderbufferStorage(36161, 34041, P.width, P.height);
      a.framebufferRenderbuffer(36160, 33306, 36161, I);
    } else {
      const yt =
          P.isWebGLMultipleRenderTargets === !0 ? P.texture[0] : P.texture,
        wt = r.convert(yt.format),
        At = r.convert(yt.type),
        Ht = A(yt.internalFormat, wt, At, yt.encoding);
      if (lt) {
        const Ut = gt(P);
        a.renderbufferStorageMultisample(36161, Ut, Ht, P.width, P.height);
      } else a.renderbufferStorage(36161, Ht, P.width, P.height);
    }
    a.bindRenderbuffer(36161, null);
  }
  function z(I, P) {
    if (P && P.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (e.bindFramebuffer(36160, I),
      !(P.depthTexture && P.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!n.get(P.depthTexture).__webglTexture ||
      P.depthTexture.image.width !== P.width ||
      P.depthTexture.image.height !== P.height) &&
      ((P.depthTexture.image.width = P.width),
      (P.depthTexture.image.height = P.height),
      (P.depthTexture.needsUpdate = !0)),
      q(P.depthTexture, 0);
    const yt = n.get(P.depthTexture).__webglTexture;
    if (P.depthTexture.format === Jo)
      a.framebufferTexture2D(36160, 36096, 3553, yt, 0);
    else if (P.depthTexture.format === _l)
      a.framebufferTexture2D(36160, 33306, 3553, yt, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function F(I) {
    const P = n.get(I),
      lt = I.isWebGLCubeRenderTarget === !0;
    if (I.depthTexture) {
      if (lt)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      z(P.__webglFramebuffer, I);
    } else if (lt) {
      P.__webglDepthbuffer = [];
      for (let yt = 0; yt < 6; yt++)
        e.bindFramebuffer(36160, P.__webglFramebuffer[yt]),
          (P.__webglDepthbuffer[yt] = a.createRenderbuffer()),
          Tt(P.__webglDepthbuffer[yt], I, !1);
    } else
      e.bindFramebuffer(36160, P.__webglFramebuffer),
        (P.__webglDepthbuffer = a.createRenderbuffer()),
        Tt(P.__webglDepthbuffer, I, !1);
    e.bindFramebuffer(36160, null);
  }
  function U(I) {
    const P = I.texture,
      lt = n.get(I),
      yt = n.get(P);
    I.addEventListener("dispose", B),
      I.isWebGLMultipleRenderTargets !== !0 &&
        ((yt.__webglTexture = a.createTexture()),
        (yt.__version = P.version),
        o.memory.textures++);
    const wt = I.isWebGLCubeRenderTarget === !0,
      At = I.isWebGLMultipleRenderTargets === !0,
      Ht = I.isWebGLMultisampleRenderTarget === !0,
      Ut = P.isDataTexture3D || P.isDataTexture2DArray,
      Vt = _(I) || l;
    if (
      (l &&
        P.format === jo &&
        (P.type === hs || P.type === Zo) &&
        ((P.format = kn),
        console.warn(
          "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
        )),
      wt)
    ) {
      lt.__webglFramebuffer = [];
      for (let Nt = 0; Nt < 6; Nt++)
        lt.__webglFramebuffer[Nt] = a.createFramebuffer();
    } else if (((lt.__webglFramebuffer = a.createFramebuffer()), At))
      if (i.drawBuffers) {
        const Nt = I.texture;
        for (let Y = 0, Ct = Nt.length; Y < Ct; Y++) {
          const _t = n.get(Nt[Y]);
          _t.__webglTexture === void 0 &&
            ((_t.__webglTexture = a.createTexture()), o.memory.textures++);
        }
      } else
        console.warn(
          "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
        );
    else if (Ht)
      if (l) {
        (lt.__webglMultisampledFramebuffer = a.createFramebuffer()),
          (lt.__webglColorRenderbuffer = a.createRenderbuffer()),
          a.bindRenderbuffer(36161, lt.__webglColorRenderbuffer);
        const Nt = r.convert(P.format),
          Y = r.convert(P.type),
          Ct = A(P.internalFormat, Nt, Y, P.encoding),
          _t = gt(I);
        a.renderbufferStorageMultisample(36161, _t, Ct, I.width, I.height),
          e.bindFramebuffer(36160, lt.__webglMultisampledFramebuffer),
          a.framebufferRenderbuffer(
            36160,
            36064,
            36161,
            lt.__webglColorRenderbuffer
          ),
          a.bindRenderbuffer(36161, null),
          I.depthBuffer &&
            ((lt.__webglDepthRenderbuffer = a.createRenderbuffer()),
            Tt(lt.__webglDepthRenderbuffer, I, !0)),
          e.bindFramebuffer(36160, null);
      } else
        console.warn(
          "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
        );
    if (wt) {
      e.bindTexture(34067, yt.__webglTexture), J(34067, P, Vt);
      for (let Nt = 0; Nt < 6; Nt++)
        Mt(lt.__webglFramebuffer[Nt], I, P, 36064, 34069 + Nt);
      E(P, Vt) && M(34067, P, I.width, I.height), e.unbindTexture();
    } else if (At) {
      const Nt = I.texture;
      for (let Y = 0, Ct = Nt.length; Y < Ct; Y++) {
        const _t = Nt[Y],
          Bt = n.get(_t);
        e.bindTexture(3553, Bt.__webglTexture),
          J(3553, _t, Vt),
          Mt(lt.__webglFramebuffer, I, _t, 36064 + Y, 3553),
          E(_t, Vt) && M(3553, _t, I.width, I.height);
      }
      e.unbindTexture();
    } else {
      let Nt = 3553;
      Ut &&
        (l
          ? (Nt = P.isDataTexture3D ? 32879 : 35866)
          : console.warn(
              "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
            )),
        e.bindTexture(Nt, yt.__webglTexture),
        J(Nt, P, Vt),
        Mt(lt.__webglFramebuffer, I, P, 36064, Nt),
        E(P, Vt) && M(Nt, P, I.width, I.height, I.depth),
        e.unbindTexture();
    }
    I.depthBuffer && F(I);
  }
  function et(I) {
    const P = _(I) || l,
      lt = I.isWebGLMultipleRenderTargets === !0 ? I.texture : [I.texture];
    for (let yt = 0, wt = lt.length; yt < wt; yt++) {
      const At = lt[yt];
      if (E(At, P)) {
        const Ht = I.isWebGLCubeRenderTarget ? 34067 : 3553,
          Ut = n.get(At).__webglTexture;
        e.bindTexture(Ht, Ut), M(Ht, At, I.width, I.height), e.unbindTexture();
      }
    }
  }
  function dt(I) {
    if (I.isWebGLMultisampleRenderTarget)
      if (l) {
        const P = I.width,
          lt = I.height;
        let yt = 16384;
        I.depthBuffer && (yt |= 256), I.stencilBuffer && (yt |= 1024);
        const wt = n.get(I);
        e.bindFramebuffer(36008, wt.__webglMultisampledFramebuffer),
          e.bindFramebuffer(36009, wt.__webglFramebuffer),
          a.blitFramebuffer(0, 0, P, lt, 0, 0, P, lt, yt, 9728),
          e.bindFramebuffer(36008, null),
          e.bindFramebuffer(36009, wt.__webglMultisampledFramebuffer);
      } else
        console.warn(
          "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
        );
  }
  function gt(I) {
    return l && I.isWebGLMultisampleRenderTarget ? Math.min(m, I.samples) : 0;
  }
  function j(I) {
    const P = o.render.frame;
    g.get(I) !== P && (g.set(I, P), I.update());
  }
  let ot = !1,
    ct = !1;
  function St(I, P) {
    I &&
      I.isWebGLRenderTarget &&
      (ot === !1 &&
        (console.warn(
          "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
        ),
        (ot = !0)),
      (I = I.texture)),
      q(I, P);
  }
  function xt(I, P) {
    I &&
      I.isWebGLCubeRenderTarget &&
      (ct === !1 &&
        (console.warn(
          "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
        ),
        (ct = !0)),
      (I = I.texture)),
      Q(I, P);
  }
  (this.allocateTextureUnit = W),
    (this.resetTextureUnits = it),
    (this.setTexture2D = q),
    (this.setTexture2DArray = tt),
    (this.setTexture3D = V),
    (this.setTextureCube = Q),
    (this.setupRenderTarget = U),
    (this.updateRenderTargetMipmap = et),
    (this.updateMultisampleRenderTarget = dt),
    (this.safeSetTexture2D = St),
    (this.safeSetTextureCube = xt);
}
function yI(a, t, e) {
  const n = e.isWebGL2;
  function i(r) {
    let o;
    if (r === us) return 5121;
    if (r === WL) return 32819;
    if (r === XL) return 32820;
    if (r === YL) return 33635;
    if (r === GL) return 5120;
    if (r === HL) return 5122;
    if (r === fu) return 5123;
    if (r === VL) return 5124;
    if (r === du) return 5125;
    if (r === hs) return 5126;
    if (r === Zo)
      return n
        ? 5131
        : ((o = t.get("OES_texture_half_float")),
          o !== null ? o.HALF_FLOAT_OES : null);
    if (r === qL) return 6406;
    if (r === jo) return 6407;
    if (r === kn) return 6408;
    if (r === ZL) return 6409;
    if (r === jL) return 6410;
    if (r === Jo) return 6402;
    if (r === _l) return 34041;
    if (r === $L) return 6403;
    if (r === KL) return 36244;
    if (r === QL) return 33319;
    if (r === tC) return 33320;
    if (r === eC) return 36248;
    if (r === nC) return 36249;
    if (r === mv || r === gv || r === _v || r === vv)
      if (((o = t.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (r === mv) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === gv) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === _v) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === vv) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (r === xv || r === yv || r === wv || r === bv)
      if (((o = t.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (r === xv) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === yv) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === wv) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === bv) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (r === iC)
      return (
        (o = t.get("WEBGL_compressed_texture_etc1")),
        o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (
      (r === Mv || r === Sv) &&
      ((o = t.get("WEBGL_compressed_texture_etc")), o !== null)
    ) {
      if (r === Mv) return o.COMPRESSED_RGB8_ETC2;
      if (r === Sv) return o.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (
      r === rC ||
      r === sC ||
      r === oC ||
      r === aC ||
      r === lC ||
      r === cC ||
      r === uC ||
      r === hC ||
      r === fC ||
      r === dC ||
      r === pC ||
      r === mC ||
      r === gC ||
      r === _C ||
      r === xC ||
      r === yC ||
      r === wC ||
      r === bC ||
      r === MC ||
      r === SC ||
      r === TC ||
      r === EC ||
      r === AC ||
      r === LC ||
      r === CC ||
      r === RC ||
      r === PC ||
      r === IC
    )
      return (
        (o = t.get("WEBGL_compressed_texture_astc")), o !== null ? r : null
      );
    if (r === vC)
      return (o = t.get("EXT_texture_compression_bptc")), o !== null ? r : null;
    if (r === gl)
      return n
        ? 34042
        : ((o = t.get("WEBGL_depth_texture")),
          o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null);
  }
  return { convert: i };
}
class Ix extends ei {
  constructor(t = []) {
    super();
    this.cameras = t;
  }
}
Ix.prototype.isArrayCamera = !0;
class El extends Me {
  constructor() {
    super();
    this.type = "Group";
  }
}
El.prototype.isGroup = !0;
const wI = { type: "move" };
class cp {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new El()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new El()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new k()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new k())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new El()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new k()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new k())),
      this._grip
    );
  }
  dispatchEvent(t) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(t),
      this._grip !== null && this._grip.dispatchEvent(t),
      this._hand !== null && this._hand.dispatchEvent(t),
      this
    );
  }
  disconnect(t) {
    return (
      this.dispatchEvent({ type: "disconnected", data: t }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(t, e, n) {
    let i = null,
      r = null,
      o = null;
    const l = this._targetRay,
      u = this._grip,
      h = this._hand;
    if (t && e.session.visibilityState !== "visible-blurred")
      if (
        (l !== null &&
          ((i = e.getPose(t.targetRaySpace, n)),
          i !== null &&
            (l.matrix.fromArray(i.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            i.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(i.linearVelocity))
              : (l.hasLinearVelocity = !1),
            i.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(i.angularVelocity))
              : (l.hasAngularVelocity = !1),
            this.dispatchEvent(wI))),
        h && t.hand)
      ) {
        o = !0;
        for (const x of t.hand.values()) {
          const b = e.getJointPose(x, n);
          if (h.joints[x.jointName] === void 0) {
            const y = new El();
            (y.matrixAutoUpdate = !1),
              (y.visible = !1),
              (h.joints[x.jointName] = y),
              h.add(y);
          }
          const _ = h.joints[x.jointName];
          b !== null &&
            (_.matrix.fromArray(b.transform.matrix),
            _.matrix.decompose(_.position, _.rotation, _.scale),
            (_.jointRadius = b.radius)),
            (_.visible = b !== null);
        }
        const f = h.joints["index-finger-tip"],
          m = h.joints["thumb-tip"],
          g = f.position.distanceTo(m.position),
          p = 0.02,
          v = 0.005;
        h.inputState.pinching && g > p + v
          ? ((h.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: t.handedness,
              target: this,
            }))
          : !h.inputState.pinching &&
            g <= p - v &&
            ((h.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: t.handedness,
              target: this,
            }));
      } else
        u !== null &&
          t.gripSpace &&
          ((r = e.getPose(t.gripSpace, n)),
          r !== null &&
            (u.matrix.fromArray(r.transform.matrix),
            u.matrix.decompose(u.position, u.rotation, u.scale),
            r.linearVelocity
              ? ((u.hasLinearVelocity = !0),
                u.linearVelocity.copy(r.linearVelocity))
              : (u.hasLinearVelocity = !1),
            r.angularVelocity
              ? ((u.hasAngularVelocity = !0),
                u.angularVelocity.copy(r.angularVelocity))
              : (u.hasAngularVelocity = !1)));
    return (
      l !== null && (l.visible = i !== null),
      u !== null && (u.visible = r !== null),
      h !== null && (h.visible = o !== null),
      this
    );
  }
}
class bI extends $s {
  constructor(t, e) {
    super();
    const n = this,
      i = t.state;
    let r = null,
      o = 1,
      l = null,
      u = "local-floor",
      h = null,
      f = null,
      m = null,
      g = null,
      p = null,
      v = !1,
      x = null,
      b = null,
      _ = null,
      y = null,
      E = null,
      M = null;
    const A = [],
      R = new Map(),
      T = new ei();
    T.layers.enable(1), (T.viewport = new Fe());
    const B = new ei();
    B.layers.enable(2), (B.viewport = new Fe());
    const X = [T, B],
      H = new Ix();
    H.layers.enable(1), H.layers.enable(2);
    let O = null,
      it = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (ft) {
        let Mt = A[ft];
        return (
          Mt === void 0 && ((Mt = new cp()), (A[ft] = Mt)),
          Mt.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (ft) {
        let Mt = A[ft];
        return (
          Mt === void 0 && ((Mt = new cp()), (A[ft] = Mt)), Mt.getGripSpace()
        );
      }),
      (this.getHand = function (ft) {
        let Mt = A[ft];
        return (
          Mt === void 0 && ((Mt = new cp()), (A[ft] = Mt)), Mt.getHandSpace()
        );
      });
    function W(ft) {
      const Mt = R.get(ft.inputSource);
      Mt && Mt.dispatchEvent({ type: ft.type, data: ft.inputSource });
    }
    function q() {
      R.forEach(function (ft, Mt) {
        ft.disconnect(Mt);
      }),
        R.clear(),
        (O = null),
        (it = null),
        i.bindXRFramebuffer(null),
        t.setRenderTarget(t.getRenderTarget()),
        m && e.deleteFramebuffer(m),
        x && e.deleteFramebuffer(x),
        b && e.deleteRenderbuffer(b),
        _ && e.deleteRenderbuffer(_),
        (m = null),
        (x = null),
        (b = null),
        (_ = null),
        (p = null),
        (g = null),
        (f = null),
        (r = null),
        zt.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (ft) {
      (o = ft),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (ft) {
        (u = ft),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return l;
      }),
      (this.getBaseLayer = function () {
        return g !== null ? g : p;
      }),
      (this.getBinding = function () {
        return f;
      }),
      (this.getFrame = function () {
        return y;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (ft) {
        if (((r = ft), r !== null)) {
          r.addEventListener("select", W),
            r.addEventListener("selectstart", W),
            r.addEventListener("selectend", W),
            r.addEventListener("squeeze", W),
            r.addEventListener("squeezestart", W),
            r.addEventListener("squeezeend", W),
            r.addEventListener("end", q),
            r.addEventListener("inputsourceschange", tt);
          const Mt = e.getContextAttributes();
          if (
            (Mt.xrCompatible !== !0 && (await e.makeXRCompatible()),
            r.renderState.layers === void 0)
          ) {
            const Tt = {
              antialias: Mt.antialias,
              alpha: Mt.alpha,
              depth: Mt.depth,
              stencil: Mt.stencil,
              framebufferScaleFactor: o,
            };
            (p = new XRWebGLLayer(r, e, Tt)),
              r.updateRenderState({ baseLayer: p });
          } else if (e instanceof WebGLRenderingContext) {
            const Tt = {
              antialias: !0,
              alpha: Mt.alpha,
              depth: Mt.depth,
              stencil: Mt.stencil,
              framebufferScaleFactor: o,
            };
            (p = new XRWebGLLayer(r, e, Tt)),
              r.updateRenderState({ layers: [p] });
          } else {
            v = Mt.antialias;
            let Tt = null;
            Mt.depth &&
              ((M = 256),
              Mt.stencil && (M |= 1024),
              (E = Mt.stencil ? 33306 : 36096),
              (Tt = Mt.stencil ? 35056 : 33190));
            const z = {
              colorFormat: Mt.alpha ? 32856 : 32849,
              depthFormat: Tt,
              scaleFactor: o,
            };
            (f = new XRWebGLBinding(r, e)),
              (g = f.createProjectionLayer(z)),
              (m = e.createFramebuffer()),
              r.updateRenderState({ layers: [g] }),
              v &&
                ((x = e.createFramebuffer()),
                (b = e.createRenderbuffer()),
                e.bindRenderbuffer(36161, b),
                e.renderbufferStorageMultisample(
                  36161,
                  4,
                  32856,
                  g.textureWidth,
                  g.textureHeight
                ),
                i.bindFramebuffer(36160, x),
                e.framebufferRenderbuffer(36160, 36064, 36161, b),
                e.bindRenderbuffer(36161, null),
                Tt !== null &&
                  ((_ = e.createRenderbuffer()),
                  e.bindRenderbuffer(36161, _),
                  e.renderbufferStorageMultisample(
                    36161,
                    4,
                    Tt,
                    g.textureWidth,
                    g.textureHeight
                  ),
                  e.framebufferRenderbuffer(36160, E, 36161, _),
                  e.bindRenderbuffer(36161, null)),
                i.bindFramebuffer(36160, null));
          }
          (l = await r.requestReferenceSpace(u)),
            zt.setContext(r),
            zt.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      });
    function tt(ft) {
      const Mt = r.inputSources;
      for (let Tt = 0; Tt < A.length; Tt++) R.set(Mt[Tt], A[Tt]);
      for (let Tt = 0; Tt < ft.removed.length; Tt++) {
        const z = ft.removed[Tt],
          F = R.get(z);
        F && (F.dispatchEvent({ type: "disconnected", data: z }), R.delete(z));
      }
      for (let Tt = 0; Tt < ft.added.length; Tt++) {
        const z = ft.added[Tt],
          F = R.get(z);
        F && F.dispatchEvent({ type: "connected", data: z });
      }
    }
    const V = new k(),
      Q = new k();
    function st(ft, Mt, Tt) {
      V.setFromMatrixPosition(Mt.matrixWorld),
        Q.setFromMatrixPosition(Tt.matrixWorld);
      const z = V.distanceTo(Q),
        F = Mt.projectionMatrix.elements,
        U = Tt.projectionMatrix.elements,
        et = F[14] / (F[10] - 1),
        dt = F[14] / (F[10] + 1),
        gt = (F[9] + 1) / F[5],
        j = (F[9] - 1) / F[5],
        ot = (F[8] - 1) / F[0],
        ct = (U[8] + 1) / U[0],
        St = et * ot,
        xt = et * ct,
        I = z / (-ot + ct),
        P = I * -ot;
      Mt.matrixWorld.decompose(ft.position, ft.quaternion, ft.scale),
        ft.translateX(P),
        ft.translateZ(I),
        ft.matrixWorld.compose(ft.position, ft.quaternion, ft.scale),
        ft.matrixWorldInverse.copy(ft.matrixWorld).invert();
      const lt = et + I,
        yt = dt + I,
        wt = St - P,
        At = xt + (z - P),
        Ht = ((gt * dt) / yt) * lt,
        Ut = ((j * dt) / yt) * lt;
      ft.projectionMatrix.makePerspective(wt, At, Ht, Ut, lt, yt);
    }
    function Lt(ft, Mt) {
      Mt === null
        ? ft.matrixWorld.copy(ft.matrix)
        : ft.matrixWorld.multiplyMatrices(Mt.matrixWorld, ft.matrix),
        ft.matrixWorldInverse.copy(ft.matrixWorld).invert();
    }
    (this.updateCamera = function (ft) {
      if (r === null) return;
      (H.near = B.near = T.near = ft.near),
        (H.far = B.far = T.far = ft.far),
        (O !== H.near || it !== H.far) &&
          (r.updateRenderState({ depthNear: H.near, depthFar: H.far }),
          (O = H.near),
          (it = H.far));
      const Mt = ft.parent,
        Tt = H.cameras;
      Lt(H, Mt);
      for (let F = 0; F < Tt.length; F++) Lt(Tt[F], Mt);
      H.matrixWorld.decompose(H.position, H.quaternion, H.scale),
        ft.position.copy(H.position),
        ft.quaternion.copy(H.quaternion),
        ft.scale.copy(H.scale),
        ft.matrix.copy(H.matrix),
        ft.matrixWorld.copy(H.matrixWorld);
      const z = ft.children;
      for (let F = 0, U = z.length; F < U; F++) z[F].updateMatrixWorld(!0);
      Tt.length === 2
        ? st(H, T, B)
        : H.projectionMatrix.copy(T.projectionMatrix);
    }),
      (this.getCamera = function () {
        return H;
      }),
      (this.getFoveation = function () {
        if (g !== null) return g.fixedFoveation;
        if (p !== null) return p.fixedFoveation;
      }),
      (this.setFoveation = function (ft) {
        g !== null && (g.fixedFoveation = ft),
          p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = ft);
      });
    let J = null;
    function vt(ft, Mt) {
      if (((h = Mt.getViewerPose(l)), (y = Mt), h !== null)) {
        const z = h.views;
        p !== null && i.bindXRFramebuffer(p.framebuffer);
        let F = !1;
        z.length !== H.cameras.length && ((H.cameras.length = 0), (F = !0));
        for (let U = 0; U < z.length; U++) {
          const et = z[U];
          let dt = null;
          if (p !== null) dt = p.getViewport(et);
          else {
            const j = f.getViewSubImage(g, et);
            i.bindXRFramebuffer(m),
              j.depthStencilTexture !== void 0 &&
                e.framebufferTexture2D(
                  36160,
                  E,
                  3553,
                  j.depthStencilTexture,
                  0
                ),
              e.framebufferTexture2D(36160, 36064, 3553, j.colorTexture, 0),
              (dt = j.viewport);
          }
          const gt = X[U];
          gt.matrix.fromArray(et.transform.matrix),
            gt.projectionMatrix.fromArray(et.projectionMatrix),
            gt.viewport.set(dt.x, dt.y, dt.width, dt.height),
            U === 0 && H.matrix.copy(gt.matrix),
            F === !0 && H.cameras.push(gt);
        }
        v && (i.bindXRFramebuffer(x), M !== null && e.clear(M));
      }
      const Tt = r.inputSources;
      for (let z = 0; z < A.length; z++) {
        const F = A[z],
          U = Tt[z];
        F.update(U, Mt, l);
      }
      if ((J && J(ft, Mt), v)) {
        const z = g.textureWidth,
          F = g.textureHeight;
        i.bindFramebuffer(36008, x),
          i.bindFramebuffer(36009, m),
          e.invalidateFramebuffer(36008, [E]),
          e.invalidateFramebuffer(36009, [E]),
          e.blitFramebuffer(0, 0, z, F, 0, 0, z, F, 16384, 9728),
          e.invalidateFramebuffer(36008, [36064]),
          i.bindFramebuffer(36008, null),
          i.bindFramebuffer(36009, null),
          i.bindFramebuffer(36160, x);
      }
      y = null;
    }
    const zt = new Jv();
    zt.setAnimationLoop(vt),
      (this.setAnimationLoop = function (ft) {
        J = ft;
      }),
      (this.dispose = function () {});
  }
}
function MI(a) {
  function t(_, y) {
    _.fogColor.value.copy(y.color),
      y.isFog
        ? ((_.fogNear.value = y.near), (_.fogFar.value = y.far))
        : y.isFogExp2 && (_.fogDensity.value = y.density);
  }
  function e(_, y, E, M, A) {
    y.isMeshBasicMaterial
      ? n(_, y)
      : y.isMeshLambertMaterial
      ? (n(_, y), u(_, y))
      : y.isMeshToonMaterial
      ? (n(_, y), f(_, y))
      : y.isMeshPhongMaterial
      ? (n(_, y), h(_, y))
      : y.isMeshStandardMaterial
      ? (n(_, y), y.isMeshPhysicalMaterial ? g(_, y, A) : m(_, y))
      : y.isMeshMatcapMaterial
      ? (n(_, y), p(_, y))
      : y.isMeshDepthMaterial
      ? (n(_, y), v(_, y))
      : y.isMeshDistanceMaterial
      ? (n(_, y), x(_, y))
      : y.isMeshNormalMaterial
      ? (n(_, y), b(_, y))
      : y.isLineBasicMaterial
      ? (i(_, y), y.isLineDashedMaterial && r(_, y))
      : y.isPointsMaterial
      ? o(_, y, E, M)
      : y.isSpriteMaterial
      ? l(_, y)
      : y.isShadowMaterial
      ? (_.color.value.copy(y.color), (_.opacity.value = y.opacity))
      : y.isShaderMaterial && (y.uniformsNeedUpdate = !1);
  }
  function n(_, y) {
    (_.opacity.value = y.opacity),
      y.color && _.diffuse.value.copy(y.color),
      y.emissive &&
        _.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity),
      y.map && (_.map.value = y.map),
      y.alphaMap && (_.alphaMap.value = y.alphaMap),
      y.specularMap && (_.specularMap.value = y.specularMap),
      y.alphaTest > 0 && (_.alphaTest.value = y.alphaTest);
    const E = a.get(y).envMap;
    if (E) {
      (_.envMap.value = E),
        (_.flipEnvMap.value =
          E.isCubeTexture && E.isRenderTargetTexture === !1 ? -1 : 1),
        (_.reflectivity.value = y.reflectivity),
        (_.ior.value = y.ior),
        (_.refractionRatio.value = y.refractionRatio);
      const R = a.get(E).__maxMipLevel;
      R !== void 0 && (_.maxMipLevel.value = R);
    }
    y.lightMap &&
      ((_.lightMap.value = y.lightMap),
      (_.lightMapIntensity.value = y.lightMapIntensity)),
      y.aoMap &&
        ((_.aoMap.value = y.aoMap),
        (_.aoMapIntensity.value = y.aoMapIntensity));
    let M;
    y.map
      ? (M = y.map)
      : y.specularMap
      ? (M = y.specularMap)
      : y.displacementMap
      ? (M = y.displacementMap)
      : y.normalMap
      ? (M = y.normalMap)
      : y.bumpMap
      ? (M = y.bumpMap)
      : y.roughnessMap
      ? (M = y.roughnessMap)
      : y.metalnessMap
      ? (M = y.metalnessMap)
      : y.alphaMap
      ? (M = y.alphaMap)
      : y.emissiveMap
      ? (M = y.emissiveMap)
      : y.clearcoatMap
      ? (M = y.clearcoatMap)
      : y.clearcoatNormalMap
      ? (M = y.clearcoatNormalMap)
      : y.clearcoatRoughnessMap
      ? (M = y.clearcoatRoughnessMap)
      : y.specularIntensityMap
      ? (M = y.specularIntensityMap)
      : y.specularColorMap
      ? (M = y.specularColorMap)
      : y.transmissionMap
      ? (M = y.transmissionMap)
      : y.thicknessMap
      ? (M = y.thicknessMap)
      : y.sheenColorMap
      ? (M = y.sheenColorMap)
      : y.sheenRoughnessMap && (M = y.sheenRoughnessMap),
      M !== void 0 &&
        (M.isWebGLRenderTarget && (M = M.texture),
        M.matrixAutoUpdate === !0 && M.updateMatrix(),
        _.uvTransform.value.copy(M.matrix));
    let A;
    y.aoMap ? (A = y.aoMap) : y.lightMap && (A = y.lightMap),
      A !== void 0 &&
        (A.isWebGLRenderTarget && (A = A.texture),
        A.matrixAutoUpdate === !0 && A.updateMatrix(),
        _.uv2Transform.value.copy(A.matrix));
  }
  function i(_, y) {
    _.diffuse.value.copy(y.color), (_.opacity.value = y.opacity);
  }
  function r(_, y) {
    (_.dashSize.value = y.dashSize),
      (_.totalSize.value = y.dashSize + y.gapSize),
      (_.scale.value = y.scale);
  }
  function o(_, y, E, M) {
    _.diffuse.value.copy(y.color),
      (_.opacity.value = y.opacity),
      (_.size.value = y.size * E),
      (_.scale.value = M * 0.5),
      y.map && (_.map.value = y.map),
      y.alphaMap && (_.alphaMap.value = y.alphaMap),
      y.alphaTest > 0 && (_.alphaTest.value = y.alphaTest);
    let A;
    y.map ? (A = y.map) : y.alphaMap && (A = y.alphaMap),
      A !== void 0 &&
        (A.matrixAutoUpdate === !0 && A.updateMatrix(),
        _.uvTransform.value.copy(A.matrix));
  }
  function l(_, y) {
    _.diffuse.value.copy(y.color),
      (_.opacity.value = y.opacity),
      (_.rotation.value = y.rotation),
      y.map && (_.map.value = y.map),
      y.alphaMap && (_.alphaMap.value = y.alphaMap),
      y.alphaTest > 0 && (_.alphaTest.value = y.alphaTest);
    let E;
    y.map ? (E = y.map) : y.alphaMap && (E = y.alphaMap),
      E !== void 0 &&
        (E.matrixAutoUpdate === !0 && E.updateMatrix(),
        _.uvTransform.value.copy(E.matrix));
  }
  function u(_, y) {
    y.emissiveMap && (_.emissiveMap.value = y.emissiveMap);
  }
  function h(_, y) {
    _.specular.value.copy(y.specular),
      (_.shininess.value = Math.max(y.shininess, 1e-4)),
      y.emissiveMap && (_.emissiveMap.value = y.emissiveMap),
      y.bumpMap &&
        ((_.bumpMap.value = y.bumpMap),
        (_.bumpScale.value = y.bumpScale),
        y.side === un && (_.bumpScale.value *= -1)),
      y.normalMap &&
        ((_.normalMap.value = y.normalMap),
        _.normalScale.value.copy(y.normalScale),
        y.side === un && _.normalScale.value.negate()),
      y.displacementMap &&
        ((_.displacementMap.value = y.displacementMap),
        (_.displacementScale.value = y.displacementScale),
        (_.displacementBias.value = y.displacementBias));
  }
  function f(_, y) {
    y.gradientMap && (_.gradientMap.value = y.gradientMap),
      y.emissiveMap && (_.emissiveMap.value = y.emissiveMap),
      y.bumpMap &&
        ((_.bumpMap.value = y.bumpMap),
        (_.bumpScale.value = y.bumpScale),
        y.side === un && (_.bumpScale.value *= -1)),
      y.normalMap &&
        ((_.normalMap.value = y.normalMap),
        _.normalScale.value.copy(y.normalScale),
        y.side === un && _.normalScale.value.negate()),
      y.displacementMap &&
        ((_.displacementMap.value = y.displacementMap),
        (_.displacementScale.value = y.displacementScale),
        (_.displacementBias.value = y.displacementBias));
  }
  function m(_, y) {
    (_.roughness.value = y.roughness),
      (_.metalness.value = y.metalness),
      y.roughnessMap && (_.roughnessMap.value = y.roughnessMap),
      y.metalnessMap && (_.metalnessMap.value = y.metalnessMap),
      y.emissiveMap && (_.emissiveMap.value = y.emissiveMap),
      y.bumpMap &&
        ((_.bumpMap.value = y.bumpMap),
        (_.bumpScale.value = y.bumpScale),
        y.side === un && (_.bumpScale.value *= -1)),
      y.normalMap &&
        ((_.normalMap.value = y.normalMap),
        _.normalScale.value.copy(y.normalScale),
        y.side === un && _.normalScale.value.negate()),
      y.displacementMap &&
        ((_.displacementMap.value = y.displacementMap),
        (_.displacementScale.value = y.displacementScale),
        (_.displacementBias.value = y.displacementBias)),
      a.get(y).envMap && (_.envMapIntensity.value = y.envMapIntensity);
  }
  function g(_, y, E) {
    m(_, y),
      (_.ior.value = y.ior),
      y.sheen > 0 &&
        (_.sheenColor.value.copy(y.sheenColor).multiplyScalar(y.sheen),
        (_.sheenRoughness.value = y.sheenRoughness),
        y.sheenColorMap && (_.sheenColorMap.value = y.sheenColorMap),
        y.sheenRoughnessMap &&
          (_.sheenRoughnessMap.value = y.sheenRoughnessMap)),
      y.clearcoat > 0 &&
        ((_.clearcoat.value = y.clearcoat),
        (_.clearcoatRoughness.value = y.clearcoatRoughness),
        y.clearcoatMap && (_.clearcoatMap.value = y.clearcoatMap),
        y.clearcoatRoughnessMap &&
          (_.clearcoatRoughnessMap.value = y.clearcoatRoughnessMap),
        y.clearcoatNormalMap &&
          (_.clearcoatNormalScale.value.copy(y.clearcoatNormalScale),
          (_.clearcoatNormalMap.value = y.clearcoatNormalMap),
          y.side === un && _.clearcoatNormalScale.value.negate())),
      y.transmission > 0 &&
        ((_.transmission.value = y.transmission),
        (_.transmissionSamplerMap.value = E.texture),
        _.transmissionSamplerSize.value.set(E.width, E.height),
        y.transmissionMap && (_.transmissionMap.value = y.transmissionMap),
        (_.thickness.value = y.thickness),
        y.thicknessMap && (_.thicknessMap.value = y.thicknessMap),
        (_.attenuationDistance.value = y.attenuationDistance),
        _.attenuationColor.value.copy(y.attenuationColor)),
      (_.specularIntensity.value = y.specularIntensity),
      _.specularColor.value.copy(y.specularColor),
      y.specularIntensityMap &&
        (_.specularIntensityMap.value = y.specularIntensityMap),
      y.specularColorMap && (_.specularColorMap.value = y.specularColorMap);
  }
  function p(_, y) {
    y.matcap && (_.matcap.value = y.matcap),
      y.bumpMap &&
        ((_.bumpMap.value = y.bumpMap),
        (_.bumpScale.value = y.bumpScale),
        y.side === un && (_.bumpScale.value *= -1)),
      y.normalMap &&
        ((_.normalMap.value = y.normalMap),
        _.normalScale.value.copy(y.normalScale),
        y.side === un && _.normalScale.value.negate()),
      y.displacementMap &&
        ((_.displacementMap.value = y.displacementMap),
        (_.displacementScale.value = y.displacementScale),
        (_.displacementBias.value = y.displacementBias));
  }
  function v(_, y) {
    y.displacementMap &&
      ((_.displacementMap.value = y.displacementMap),
      (_.displacementScale.value = y.displacementScale),
      (_.displacementBias.value = y.displacementBias));
  }
  function x(_, y) {
    y.displacementMap &&
      ((_.displacementMap.value = y.displacementMap),
      (_.displacementScale.value = y.displacementScale),
      (_.displacementBias.value = y.displacementBias)),
      _.referencePosition.value.copy(y.referencePosition),
      (_.nearDistance.value = y.nearDistance),
      (_.farDistance.value = y.farDistance);
  }
  function b(_, y) {
    y.bumpMap &&
      ((_.bumpMap.value = y.bumpMap),
      (_.bumpScale.value = y.bumpScale),
      y.side === un && (_.bumpScale.value *= -1)),
      y.normalMap &&
        ((_.normalMap.value = y.normalMap),
        _.normalScale.value.copy(y.normalScale),
        y.side === un && _.normalScale.value.negate()),
      y.displacementMap &&
        ((_.displacementMap.value = y.displacementMap),
        (_.displacementScale.value = y.displacementScale),
        (_.displacementBias.value = y.displacementBias));
  }
  return { refreshFogUniforms: t, refreshMaterialUniforms: e };
}
function SI() {
  const a = vu("canvas");
  return (a.style.display = "block"), a;
}
function Le(a = {}) {
  const t = a.canvas !== void 0 ? a.canvas : SI(),
    e = a.context !== void 0 ? a.context : null,
    n = a.alpha !== void 0 ? a.alpha : !1,
    i = a.depth !== void 0 ? a.depth : !0,
    r = a.stencil !== void 0 ? a.stencil : !0,
    o = a.antialias !== void 0 ? a.antialias : !1,
    l = a.premultipliedAlpha !== void 0 ? a.premultipliedAlpha : !0,
    u = a.preserveDrawingBuffer !== void 0 ? a.preserveDrawingBuffer : !1,
    h = a.powerPreference !== void 0 ? a.powerPreference : "default",
    f =
      a.failIfMajorPerformanceCaveat !== void 0
        ? a.failIfMajorPerformanceCaveat
        : !1;
  let m = null,
    g = null;
  const p = [],
    v = [];
  (this.domElement = t),
    (this.debug = { checkShaderErrors: !0 }),
    (this.autoClear = !0),
    (this.autoClearColor = !0),
    (this.autoClearDepth = !0),
    (this.autoClearStencil = !0),
    (this.sortObjects = !0),
    (this.clippingPlanes = []),
    (this.localClippingEnabled = !1),
    (this.gammaFactor = 2),
    (this.outputEncoding = Cn),
    (this.physicallyCorrectLights = !1),
    (this.toneMapping = js),
    (this.toneMappingExposure = 1);
  const x = this;
  let b = !1,
    _ = 0,
    y = 0,
    E = null,
    M = -1,
    A = null;
  const R = new Fe(),
    T = new Fe();
  let B = null,
    X = t.width,
    H = t.height,
    O = 1,
    it = null,
    W = null;
  const q = new Fe(0, 0, X, H),
    tt = new Fe(0, 0, X, H);
  let V = !1;
  const Q = [],
    st = new Bu();
  let Lt = !1,
    J = !1,
    vt = null;
  const zt = new Jt(),
    ft = new k(),
    Mt = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: !0,
    };
  function Tt() {
    return E === null ? O : 1;
  }
  let z = e;
  function F(D, K) {
    for (let at = 0; at < D.length; at++) {
      const nt = D[at],
        ut = t.getContext(nt, K);
      if (ut !== null) return ut;
    }
    return null;
  }
  try {
    const D = {
      alpha: n,
      depth: i,
      stencil: r,
      antialias: o,
      premultipliedAlpha: l,
      preserveDrawingBuffer: u,
      powerPreference: h,
      failIfMajorPerformanceCaveat: f,
    };
    if (
      (t.addEventListener("webglcontextlost", Be, !1),
      t.addEventListener("webglcontextrestored", He, !1),
      z === null)
    ) {
      const K = ["webgl2", "webgl", "experimental-webgl"];
      if ((x.isWebGL1Renderer === !0 && K.shift(), (z = F(K, D)), z === null))
        throw F(K)
          ? new Error(
              "Error creating WebGL context with your selected attributes."
            )
          : new Error("Error creating WebGL context.");
    }
    z.getShaderPrecisionFormat === void 0 &&
      (z.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
  } catch (D) {
    throw (console.error("THREE.WebGLRenderer: " + D.message), D);
  }
  let U,
    et,
    dt,
    gt,
    j,
    ot,
    ct,
    St,
    xt,
    I,
    P,
    lt,
    yt,
    wt,
    At,
    Ht,
    Ut,
    Vt,
    Nt,
    Y,
    Ct,
    _t,
    Bt;
  function Ft() {
    (U = new q3(z)),
      (et = new U3(z, U, a)),
      U.init(et),
      (_t = new yI(z, U, et)),
      (dt = new vI(z, U, et)),
      (Q[0] = 1029),
      (gt = new J3(z)),
      (j = new aI()),
      (ot = new xI(z, U, dt, j, et, _t, gt)),
      (ct = new G3(x)),
      (St = new Y3(x)),
      (xt = new cR(z, et)),
      (Bt = new B3(z, U, xt, et)),
      (I = new Z3(z, xt, gt, Bt)),
      (P = new tP(z, I, xt, gt)),
      (Nt = new Q3(z, et, ot)),
      (Ht = new k3(j)),
      (lt = new oI(x, ct, St, U, et, Bt, Ht)),
      (yt = new MI(j)),
      (wt = new cI(j)),
      (At = new mI(U, et)),
      (Vt = new N3(x, ct, dt, P, l)),
      (Ut = new Px(x, P, et)),
      (Y = new z3(z, U, gt, et)),
      (Ct = new j3(z, U, gt, et)),
      (gt.programs = lt.programs),
      (x.capabilities = et),
      (x.extensions = U),
      (x.properties = j),
      (x.renderLists = wt),
      (x.shadowMap = Ut),
      (x.state = dt),
      (x.info = gt);
  }
  Ft();
  const ee = new bI(x, z);
  (this.xr = ee),
    (this.getContext = function () {
      return z;
    }),
    (this.getContextAttributes = function () {
      return z.getContextAttributes();
    }),
    (this.forceContextLoss = function () {
      const D = U.get("WEBGL_lose_context");
      D && D.loseContext();
    }),
    (this.forceContextRestore = function () {
      const D = U.get("WEBGL_lose_context");
      D && D.restoreContext();
    }),
    (this.getPixelRatio = function () {
      return O;
    }),
    (this.setPixelRatio = function (D) {
      D !== void 0 && ((O = D), this.setSize(X, H, !1));
    }),
    (this.getSize = function (D) {
      return D.set(X, H);
    }),
    (this.setSize = function (D, K, at) {
      if (ee.isPresenting) {
        console.warn(
          "THREE.WebGLRenderer: Can't change size while VR device is presenting."
        );
        return;
      }
      (X = D),
        (H = K),
        (t.width = Math.floor(D * O)),
        (t.height = Math.floor(K * O)),
        at !== !1 && ((t.style.width = D + "px"), (t.style.height = K + "px")),
        this.setViewport(0, 0, D, K);
    }),
    (this.getDrawingBufferSize = function (D) {
      return D.set(X * O, H * O).floor();
    }),
    (this.setDrawingBufferSize = function (D, K, at) {
      (X = D),
        (H = K),
        (O = at),
        (t.width = Math.floor(D * at)),
        (t.height = Math.floor(K * at)),
        this.setViewport(0, 0, D, K);
    }),
    (this.getCurrentViewport = function (D) {
      return D.copy(R);
    }),
    (this.getViewport = function (D) {
      return D.copy(q);
    }),
    (this.setViewport = function (D, K, at, nt) {
      D.isVector4 ? q.set(D.x, D.y, D.z, D.w) : q.set(D, K, at, nt),
        dt.viewport(R.copy(q).multiplyScalar(O).floor());
    }),
    (this.getScissor = function (D) {
      return D.copy(tt);
    }),
    (this.setScissor = function (D, K, at, nt) {
      D.isVector4 ? tt.set(D.x, D.y, D.z, D.w) : tt.set(D, K, at, nt),
        dt.scissor(T.copy(tt).multiplyScalar(O).floor());
    }),
    (this.getScissorTest = function () {
      return V;
    }),
    (this.setScissorTest = function (D) {
      dt.setScissorTest((V = D));
    }),
    (this.setOpaqueSort = function (D) {
      it = D;
    }),
    (this.setTransparentSort = function (D) {
      W = D;
    }),
    (this.getClearColor = function (D) {
      return D.copy(Vt.getClearColor());
    }),
    (this.setClearColor = function () {
      Vt.setClearColor.apply(Vt, arguments);
    }),
    (this.getClearAlpha = function () {
      return Vt.getClearAlpha();
    }),
    (this.setClearAlpha = function () {
      Vt.setClearAlpha.apply(Vt, arguments);
    }),
    (this.clear = function (D, K, at) {
      let nt = 0;
      (D === void 0 || D) && (nt |= 16384),
        (K === void 0 || K) && (nt |= 256),
        (at === void 0 || at) && (nt |= 1024),
        z.clear(nt);
    }),
    (this.clearColor = function () {
      this.clear(!0, !1, !1);
    }),
    (this.clearDepth = function () {
      this.clear(!1, !0, !1);
    }),
    (this.clearStencil = function () {
      this.clear(!1, !1, !0);
    }),
    (this.dispose = function () {
      t.removeEventListener("webglcontextlost", Be, !1),
        t.removeEventListener("webglcontextrestored", He, !1),
        wt.dispose(),
        At.dispose(),
        j.dispose(),
        ct.dispose(),
        St.dispose(),
        P.dispose(),
        Bt.dispose(),
        ee.dispose(),
        ee.removeEventListener("sessionstart", Zi),
        ee.removeEventListener("sessionend", fr),
        vt && (vt.dispose(), (vt = null)),
        Hn.stop();
    });
  function Be(D) {
    D.preventDefault(),
      console.log("THREE.WebGLRenderer: Context Lost."),
      (b = !0);
  }
  function He() {
    console.log("THREE.WebGLRenderer: Context Restored."), (b = !1);
    const D = gt.autoReset,
      K = Ut.enabled,
      at = Ut.autoUpdate,
      nt = Ut.needsUpdate,
      ut = Ut.type;
    Ft(),
      (gt.autoReset = D),
      (Ut.enabled = K),
      (Ut.autoUpdate = at),
      (Ut.needsUpdate = nt),
      (Ut.type = ut);
  }
  function Te(D) {
    const K = D.target;
    K.removeEventListener("dispose", Te), ve(K);
  }
  function ve(D) {
    je(D), j.remove(D);
  }
  function je(D) {
    const K = j.get(D).programs;
    K !== void 0 &&
      K.forEach(function (at) {
        lt.releaseProgram(at);
      });
  }
  (this.renderBufferDirect = function (D, K, at, nt, ut, Ot) {
    K === null && (K = Mt);
    const It = ut.isMesh && ut.matrixWorld.determinant() < 0,
      Gt = Kt(D, K, at, nt, ut);
    dt.setMaterial(nt, It);
    let $t = at.index;
    const Yt = at.attributes.position;
    if ($t === null) {
      if (Yt === void 0 || Yt.count === 0) return;
    } else if ($t.count === 0) return;
    let Wt = 1;
    nt.wireframe === !0 && (($t = I.getWireframeAttribute(at)), (Wt = 2)),
      Bt.setup(ut, nt, Gt, at, $t);
    let Qt,
      Ee = Y;
    $t !== null && ((Qt = xt.get($t)), (Ee = Ct), Ee.setIndex(Qt));
    const _i = $t !== null ? $t.count : Yt.count,
      oe = at.drawRange.start * Wt,
      dr = at.drawRange.count * Wt,
      xe = Ot !== null ? Ot.start * Wt : 0,
      pr = Ot !== null ? Ot.count * Wt : 1 / 0,
      vi = Math.max(oe, xe),
      mr = Math.min(_i, oe + dr, xe + pr) - 1,
      ji = Math.max(0, mr - vi + 1);
    if (ji !== 0) {
      if (ut.isMesh)
        nt.wireframe === !0
          ? (dt.setLineWidth(nt.wireframeLinewidth * Tt()), Ee.setMode(1))
          : Ee.setMode(4);
      else if (ut.isLine) {
        let Ve = nt.linewidth;
        Ve === void 0 && (Ve = 1),
          dt.setLineWidth(Ve * Tt()),
          ut.isLineSegments
            ? Ee.setMode(1)
            : ut.isLineLoop
            ? Ee.setMode(2)
            : Ee.setMode(3);
      } else ut.isPoints ? Ee.setMode(0) : ut.isSprite && Ee.setMode(4);
      if (ut.isInstancedMesh) Ee.renderInstances(vi, ji, ut.count);
      else if (at.isInstancedBufferGeometry) {
        const Ve = Math.min(at.instanceCount, at._maxInstanceCount);
        Ee.renderInstances(vi, ji, Ve);
      } else Ee.render(vi, ji);
    }
  }),
    (this.compile = function (D, K) {
      (g = At.get(D)),
        g.init(),
        v.push(g),
        D.traverseVisible(function (at) {
          at.isLight &&
            at.layers.test(K.layers) &&
            (g.pushLight(at), at.castShadow && g.pushShadow(at));
        }),
        g.setupLights(x.physicallyCorrectLights),
        D.traverse(function (at) {
          const nt = at.material;
          if (nt)
            if (Array.isArray(nt))
              for (let ut = 0; ut < nt.length; ut++) {
                const Ot = nt[ut];
                de(Ot, D, at);
              }
            else de(nt, D, at);
        }),
        v.pop(),
        (g = null);
    });
  let rn = null;
  function hr(D) {
    rn && rn(D);
  }
  function Zi() {
    Hn.stop();
  }
  function fr() {
    Hn.start();
  }
  const Hn = new Jv();
  Hn.setAnimationLoop(hr),
    typeof window != "undefined" && Hn.setContext(window),
    (this.setAnimationLoop = function (D) {
      (rn = D), ee.setAnimationLoop(D), D === null ? Hn.stop() : Hn.start();
    }),
    ee.addEventListener("sessionstart", Zi),
    ee.addEventListener("sessionend", fr),
    (this.render = function (D, K) {
      if (K !== void 0 && K.isCamera !== !0) {
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        );
        return;
      }
      if (b === !0) return;
      D.autoUpdate === !0 && D.updateMatrixWorld(),
        K.parent === null && K.updateMatrixWorld(),
        ee.enabled === !0 &&
          ee.isPresenting === !0 &&
          (ee.cameraAutoUpdate === !0 && ee.updateCamera(K),
          (K = ee.getCamera())),
        D.isScene === !0 && D.onBeforeRender(x, D, K, E),
        (g = At.get(D, v.length)),
        g.init(),
        v.push(g),
        zt.multiplyMatrices(K.projectionMatrix, K.matrixWorldInverse),
        st.setFromProjectionMatrix(zt),
        (J = this.localClippingEnabled),
        (Lt = Ht.init(this.clippingPlanes, J, K)),
        (m = wt.get(D, p.length)),
        m.init(),
        p.push(m),
        As(D, K, 0, x.sortObjects),
        m.finish(),
        x.sortObjects === !0 && m.sort(it, W),
        Lt === !0 && Ht.beginShadows();
      const at = g.state.shadowsArray;
      if (
        (Ut.render(at, D, K),
        Lt === !0 && Ht.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        Vt.render(m, D),
        g.setupLights(x.physicallyCorrectLights),
        K.isArrayCamera)
      ) {
        const nt = K.cameras;
        for (let ut = 0, Ot = nt.length; ut < Ot; ut++) {
          const It = nt[ut];
          ro(m, D, It, It.viewport);
        }
      } else ro(m, D, K);
      E !== null &&
        (ot.updateMultisampleRenderTarget(E), ot.updateRenderTargetMipmap(E)),
        D.isScene === !0 && D.onAfterRender(x, D, K),
        dt.buffers.depth.setTest(!0),
        dt.buffers.depth.setMask(!0),
        dt.buffers.color.setMask(!0),
        dt.setPolygonOffset(!1),
        Bt.resetDefaultState(),
        (M = -1),
        (A = null),
        v.pop(),
        v.length > 0 ? (g = v[v.length - 1]) : (g = null),
        p.pop(),
        p.length > 0 ? (m = p[p.length - 1]) : (m = null);
    });
  function As(D, K, at, nt) {
    if (D.visible === !1) return;
    if (D.layers.test(K.layers)) {
      if (D.isGroup) at = D.renderOrder;
      else if (D.isLOD) D.autoUpdate === !0 && D.update(K);
      else if (D.isLight) g.pushLight(D), D.castShadow && g.pushShadow(D);
      else if (D.isSprite) {
        if (!D.frustumCulled || st.intersectsSprite(D)) {
          nt && ft.setFromMatrixPosition(D.matrixWorld).applyMatrix4(zt);
          const It = P.update(D),
            Gt = D.material;
          Gt.visible && m.push(D, It, Gt, at, ft.z, null);
        }
      } else if (
        (D.isMesh || D.isLine || D.isPoints) &&
        (D.isSkinnedMesh &&
          D.skeleton.frame !== gt.render.frame &&
          (D.skeleton.update(), (D.skeleton.frame = gt.render.frame)),
        !D.frustumCulled || st.intersectsObject(D))
      ) {
        nt && ft.setFromMatrixPosition(D.matrixWorld).applyMatrix4(zt);
        const It = P.update(D),
          Gt = D.material;
        if (Array.isArray(Gt)) {
          const $t = It.groups;
          for (let Yt = 0, Wt = $t.length; Yt < Wt; Yt++) {
            const Qt = $t[Yt],
              Ee = Gt[Qt.materialIndex];
            Ee && Ee.visible && m.push(D, It, Ee, at, ft.z, Qt);
          }
        } else Gt.visible && m.push(D, It, Gt, at, ft.z, null);
      }
    }
    const Ot = D.children;
    for (let It = 0, Gt = Ot.length; It < Gt; It++) As(Ot[It], K, at, nt);
  }
  function ro(D, K, at, nt) {
    const ut = D.opaque,
      Ot = D.transmissive,
      It = D.transparent;
    g.setupLightsView(at),
      Ot.length > 0 && me(ut, K, at),
      nt && dt.viewport(R.copy(nt)),
      ut.length > 0 && fe(ut, K, at),
      Ot.length > 0 && fe(Ot, K, at),
      It.length > 0 && fe(It, K, at);
  }
  function me(D, K, at) {
    if (vt === null) {
      const It = o === !0 && et.isWebGL2 === !0 ? Dv : or;
      vt = new It(1024, 1024, {
        generateMipmaps: !0,
        type: _t.convert(Zo) !== null ? Zo : us,
        minFilter: hu,
        magFilter: mn,
        wrapS: di,
        wrapT: di,
      });
    }
    const nt = x.getRenderTarget();
    x.setRenderTarget(vt), x.clear();
    const ut = x.toneMapping;
    (x.toneMapping = js),
      fe(D, K, at),
      (x.toneMapping = ut),
      ot.updateMultisampleRenderTarget(vt),
      ot.updateRenderTargetMipmap(vt),
      x.setRenderTarget(nt);
  }
  function fe(D, K, at) {
    const nt = K.isScene === !0 ? K.overrideMaterial : null;
    for (let ut = 0, Ot = D.length; ut < Ot; ut++) {
      const It = D[ut],
        Gt = It.object,
        $t = It.geometry,
        Yt = nt === null ? It.material : nt,
        Wt = It.group;
      Gt.layers.test(at.layers) && ge(Gt, K, at, $t, Yt, Wt);
    }
  }
  function ge(D, K, at, nt, ut, Ot) {
    D.onBeforeRender(x, K, at, nt, ut, Ot),
      D.modelViewMatrix.multiplyMatrices(at.matrixWorldInverse, D.matrixWorld),
      D.normalMatrix.getNormalMatrix(D.modelViewMatrix),
      ut.onBeforeRender(x, K, at, nt, D, Ot),
      ut.transparent === !0 && ut.side === Yo
        ? ((ut.side = un),
          (ut.needsUpdate = !0),
          x.renderBufferDirect(at, K, nt, ut, D, Ot),
          (ut.side = fl),
          (ut.needsUpdate = !0),
          x.renderBufferDirect(at, K, nt, ut, D, Ot),
          (ut.side = Yo))
        : x.renderBufferDirect(at, K, nt, ut, D, Ot),
      D.onAfterRender(x, K, at, nt, ut, Ot);
  }
  function de(D, K, at) {
    K.isScene !== !0 && (K = Mt);
    const nt = j.get(D),
      ut = g.state.lights,
      Ot = g.state.shadowsArray,
      It = ut.state.version,
      Gt = lt.getParameters(D, ut.state, Ot, K, at),
      $t = lt.getProgramCacheKey(Gt);
    let Yt = nt.programs;
    (nt.environment = D.isMeshStandardMaterial ? K.environment : null),
      (nt.fog = K.fog),
      (nt.envMap = (D.isMeshStandardMaterial ? St : ct).get(
        D.envMap || nt.environment
      )),
      Yt === void 0 &&
        (D.addEventListener("dispose", Te),
        (Yt = new Map()),
        (nt.programs = Yt));
    let Wt = Yt.get($t);
    if (Wt !== void 0) {
      if (nt.currentProgram === Wt && nt.lightsStateVersion === It)
        return _n(D, Gt), Wt;
    } else
      (Gt.uniforms = lt.getUniforms(D)),
        D.onBuild(at, Gt, x),
        D.onBeforeCompile(Gt, x),
        (Wt = lt.acquireProgram(Gt, $t)),
        Yt.set($t, Wt),
        (nt.uniforms = Gt.uniforms);
    const Qt = nt.uniforms;
    ((!D.isShaderMaterial && !D.isRawShaderMaterial) || D.clipping === !0) &&
      (Qt.clippingPlanes = Ht.uniform),
      _n(D, Gt),
      (nt.needsLights = Re(D)),
      (nt.lightsStateVersion = It),
      nt.needsLights &&
        ((Qt.ambientLightColor.value = ut.state.ambient),
        (Qt.lightProbe.value = ut.state.probe),
        (Qt.directionalLights.value = ut.state.directional),
        (Qt.directionalLightShadows.value = ut.state.directionalShadow),
        (Qt.spotLights.value = ut.state.spot),
        (Qt.spotLightShadows.value = ut.state.spotShadow),
        (Qt.rectAreaLights.value = ut.state.rectArea),
        (Qt.ltc_1.value = ut.state.rectAreaLTC1),
        (Qt.ltc_2.value = ut.state.rectAreaLTC2),
        (Qt.pointLights.value = ut.state.point),
        (Qt.pointLightShadows.value = ut.state.pointShadow),
        (Qt.hemisphereLights.value = ut.state.hemi),
        (Qt.directionalShadowMap.value = ut.state.directionalShadowMap),
        (Qt.directionalShadowMatrix.value = ut.state.directionalShadowMatrix),
        (Qt.spotShadowMap.value = ut.state.spotShadowMap),
        (Qt.spotShadowMatrix.value = ut.state.spotShadowMatrix),
        (Qt.pointShadowMap.value = ut.state.pointShadowMap),
        (Qt.pointShadowMatrix.value = ut.state.pointShadowMatrix));
    const Ee = Wt.getUniforms(),
      _i = ws.seqWithValue(Ee.seq, Qt);
    return (nt.currentProgram = Wt), (nt.uniformsList = _i), Wt;
  }
  function _n(D, K) {
    const at = j.get(D);
    (at.outputEncoding = K.outputEncoding),
      (at.instancing = K.instancing),
      (at.skinning = K.skinning),
      (at.morphTargets = K.morphTargets),
      (at.morphNormals = K.morphNormals),
      (at.morphTargetsCount = K.morphTargetsCount),
      (at.numClippingPlanes = K.numClippingPlanes),
      (at.numIntersection = K.numClipIntersection),
      (at.vertexAlphas = K.vertexAlphas),
      (at.vertexTangents = K.vertexTangents);
  }
  function Kt(D, K, at, nt, ut) {
    K.isScene !== !0 && (K = Mt), ot.resetTextureUnits();
    const Ot = K.fog,
      It = nt.isMeshStandardMaterial ? K.environment : null,
      Gt = E === null ? x.outputEncoding : E.texture.encoding,
      $t = (nt.isMeshStandardMaterial ? St : ct).get(nt.envMap || It),
      Yt =
        nt.vertexColors === !0 &&
        !!at.attributes.color &&
        at.attributes.color.itemSize === 4,
      Wt = !!nt.normalMap && !!at.attributes.tangent,
      Qt = !!at.morphAttributes.position,
      Ee = !!at.morphAttributes.normal,
      _i = at.morphAttributes.position ? at.morphAttributes.position.length : 0,
      oe = j.get(nt),
      dr = g.state.lights;
    if (Lt === !0 && (J === !0 || D !== A)) {
      const Vn = D === A && nt.id === M;
      Ht.setState(nt, D, Vn);
    }
    let xe = !1;
    nt.version === oe.__version
      ? ((oe.needsLights && oe.lightsStateVersion !== dr.state.version) ||
          oe.outputEncoding !== Gt ||
          (ut.isInstancedMesh && oe.instancing === !1) ||
          (!ut.isInstancedMesh && oe.instancing === !0) ||
          (ut.isSkinnedMesh && oe.skinning === !1) ||
          (!ut.isSkinnedMesh && oe.skinning === !0) ||
          oe.envMap !== $t ||
          (nt.fog && oe.fog !== Ot) ||
          (oe.numClippingPlanes !== void 0 &&
            (oe.numClippingPlanes !== Ht.numPlanes ||
              oe.numIntersection !== Ht.numIntersection)) ||
          oe.vertexAlphas !== Yt ||
          oe.vertexTangents !== Wt ||
          oe.morphTargets !== Qt ||
          oe.morphNormals !== Ee ||
          (et.isWebGL2 === !0 && oe.morphTargetsCount !== _i)) &&
        (xe = !0)
      : ((xe = !0), (oe.__version = nt.version));
    let pr = oe.currentProgram;
    xe === !0 && (pr = de(nt, K, ut));
    let vi = !1,
      mr = !1,
      ji = !1;
    const Ve = pr.getUniforms(),
      Ur = oe.uniforms;
    if (
      (dt.useProgram(pr.program) && ((vi = !0), (mr = !0), (ji = !0)),
      nt.id !== M && ((M = nt.id), (mr = !0)),
      vi || A !== D)
    ) {
      if (
        (Ve.setValue(z, "projectionMatrix", D.projectionMatrix),
        et.logarithmicDepthBuffer &&
          Ve.setValue(z, "logDepthBufFC", 2 / (Math.log(D.far + 1) / Math.LN2)),
        A !== D && ((A = D), (mr = !0), (ji = !0)),
        nt.isShaderMaterial ||
          nt.isMeshPhongMaterial ||
          nt.isMeshToonMaterial ||
          nt.isMeshStandardMaterial ||
          nt.envMap)
      ) {
        const Vn = Ve.map.cameraPosition;
        Vn !== void 0 &&
          Vn.setValue(z, ft.setFromMatrixPosition(D.matrixWorld));
      }
      (nt.isMeshPhongMaterial ||
        nt.isMeshToonMaterial ||
        nt.isMeshLambertMaterial ||
        nt.isMeshBasicMaterial ||
        nt.isMeshStandardMaterial ||
        nt.isShaderMaterial) &&
        Ve.setValue(z, "isOrthographic", D.isOrthographicCamera === !0),
        (nt.isMeshPhongMaterial ||
          nt.isMeshToonMaterial ||
          nt.isMeshLambertMaterial ||
          nt.isMeshBasicMaterial ||
          nt.isMeshStandardMaterial ||
          nt.isShaderMaterial ||
          nt.isShadowMaterial ||
          ut.isSkinnedMesh) &&
          Ve.setValue(z, "viewMatrix", D.matrixWorldInverse);
    }
    if (ut.isSkinnedMesh) {
      Ve.setOptional(z, ut, "bindMatrix"),
        Ve.setOptional(z, ut, "bindMatrixInverse");
      const Vn = ut.skeleton;
      Vn &&
        (et.floatVertexTextures
          ? (Vn.boneTexture === null && Vn.computeBoneTexture(),
            Ve.setValue(z, "boneTexture", Vn.boneTexture, ot),
            Ve.setValue(z, "boneTextureSize", Vn.boneTextureSize))
          : Ve.setOptional(z, Vn, "boneMatrices"));
    }
    return (
      !!at &&
        (at.morphAttributes.position !== void 0 ||
          at.morphAttributes.normal !== void 0) &&
        Nt.update(ut, at, nt, pr),
      (mr || oe.receiveShadow !== ut.receiveShadow) &&
        ((oe.receiveShadow = ut.receiveShadow),
        Ve.setValue(z, "receiveShadow", ut.receiveShadow)),
      mr &&
        (Ve.setValue(z, "toneMappingExposure", x.toneMappingExposure),
        oe.needsLights && Ce(Ur, ji),
        Ot && nt.fog && yt.refreshFogUniforms(Ur, Ot),
        yt.refreshMaterialUniforms(Ur, nt, O, H, vt),
        ws.upload(z, oe.uniformsList, Ur, ot)),
      nt.isShaderMaterial &&
        nt.uniformsNeedUpdate === !0 &&
        (ws.upload(z, oe.uniformsList, Ur, ot), (nt.uniformsNeedUpdate = !1)),
      nt.isSpriteMaterial && Ve.setValue(z, "center", ut.center),
      Ve.setValue(z, "modelViewMatrix", ut.modelViewMatrix),
      Ve.setValue(z, "normalMatrix", ut.normalMatrix),
      Ve.setValue(z, "modelMatrix", ut.matrixWorld),
      pr
    );
  }
  function Ce(D, K) {
    (D.ambientLightColor.needsUpdate = K),
      (D.lightProbe.needsUpdate = K),
      (D.directionalLights.needsUpdate = K),
      (D.directionalLightShadows.needsUpdate = K),
      (D.pointLights.needsUpdate = K),
      (D.pointLightShadows.needsUpdate = K),
      (D.spotLights.needsUpdate = K),
      (D.spotLightShadows.needsUpdate = K),
      (D.rectAreaLights.needsUpdate = K),
      (D.hemisphereLights.needsUpdate = K);
  }
  function Re(D) {
    return (
      D.isMeshLambertMaterial ||
      D.isMeshToonMaterial ||
      D.isMeshPhongMaterial ||
      D.isMeshStandardMaterial ||
      D.isShadowMaterial ||
      (D.isShaderMaterial && D.lights === !0)
    );
  }
  (this.getActiveCubeFace = function () {
    return _;
  }),
    (this.getActiveMipmapLevel = function () {
      return y;
    }),
    (this.getRenderTarget = function () {
      return E;
    }),
    (this.setRenderTarget = function (D, K = 0, at = 0) {
      (E = D),
        (_ = K),
        (y = at),
        D && j.get(D).__webglFramebuffer === void 0 && ot.setupRenderTarget(D);
      let nt = null,
        ut = !1,
        Ot = !1;
      if (D) {
        const Gt = D.texture;
        (Gt.isDataTexture3D || Gt.isDataTexture2DArray) && (Ot = !0);
        const $t = j.get(D).__webglFramebuffer;
        D.isWebGLCubeRenderTarget
          ? ((nt = $t[K]), (ut = !0))
          : D.isWebGLMultisampleRenderTarget
          ? (nt = j.get(D).__webglMultisampledFramebuffer)
          : (nt = $t),
          R.copy(D.viewport),
          T.copy(D.scissor),
          (B = D.scissorTest);
      } else
        R.copy(q).multiplyScalar(O).floor(),
          T.copy(tt).multiplyScalar(O).floor(),
          (B = V);
      if (dt.bindFramebuffer(36160, nt) && et.drawBuffers) {
        let Gt = !1;
        if (D)
          if (D.isWebGLMultipleRenderTargets) {
            const $t = D.texture;
            if (Q.length !== $t.length || Q[0] !== 36064) {
              for (let Yt = 0, Wt = $t.length; Yt < Wt; Yt++)
                Q[Yt] = 36064 + Yt;
              (Q.length = $t.length), (Gt = !0);
            }
          } else
            (Q.length !== 1 || Q[0] !== 36064) &&
              ((Q[0] = 36064), (Q.length = 1), (Gt = !0));
        else
          (Q.length !== 1 || Q[0] !== 1029) &&
            ((Q[0] = 1029), (Q.length = 1), (Gt = !0));
        Gt &&
          (et.isWebGL2
            ? z.drawBuffers(Q)
            : U.get("WEBGL_draw_buffers").drawBuffersWEBGL(Q));
      }
      if ((dt.viewport(R), dt.scissor(T), dt.setScissorTest(B), ut)) {
        const Gt = j.get(D.texture);
        z.framebufferTexture2D(36160, 36064, 34069 + K, Gt.__webglTexture, at);
      } else if (Ot) {
        const Gt = j.get(D.texture),
          $t = K || 0;
        z.framebufferTextureLayer(36160, 36064, Gt.__webglTexture, at || 0, $t);
      }
      M = -1;
    }),
    (this.readRenderTargetPixels = function (D, K, at, nt, ut, Ot, It) {
      if (!(D && D.isWebGLRenderTarget)) {
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        );
        return;
      }
      let Gt = j.get(D).__webglFramebuffer;
      if ((D.isWebGLCubeRenderTarget && It !== void 0 && (Gt = Gt[It]), Gt)) {
        dt.bindFramebuffer(36160, Gt);
        try {
          const $t = D.texture,
            Yt = $t.format,
            Wt = $t.type;
          if (Yt !== kn && _t.convert(Yt) !== z.getParameter(35739)) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            );
            return;
          }
          const Qt =
            Wt === Zo &&
            (U.has("EXT_color_buffer_half_float") ||
              (et.isWebGL2 && U.has("EXT_color_buffer_float")));
          if (
            Wt !== us &&
            _t.convert(Wt) !== z.getParameter(35738) &&
            !(
              Wt === hs &&
              (et.isWebGL2 ||
                U.has("OES_texture_float") ||
                U.has("WEBGL_color_buffer_float"))
            ) &&
            !Qt
          ) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            );
            return;
          }
          z.checkFramebufferStatus(36160) === 36053
            ? K >= 0 &&
              K <= D.width - nt &&
              at >= 0 &&
              at <= D.height - ut &&
              z.readPixels(K, at, nt, ut, _t.convert(Yt), _t.convert(Wt), Ot)
            : console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
              );
        } finally {
          const $t = E !== null ? j.get(E).__webglFramebuffer : null;
          dt.bindFramebuffer(36160, $t);
        }
      }
    }),
    (this.copyFramebufferToTexture = function (D, K, at = 0) {
      const nt = Math.pow(2, -at),
        ut = Math.floor(K.image.width * nt),
        Ot = Math.floor(K.image.height * nt);
      let It = _t.convert(K.format);
      et.isWebGL2 && (It === 6407 && (It = 32849), It === 6408 && (It = 32856)),
        ot.setTexture2D(K, 0),
        z.copyTexImage2D(3553, at, It, D.x, D.y, ut, Ot, 0),
        dt.unbindTexture();
    }),
    (this.copyTextureToTexture = function (D, K, at, nt = 0) {
      const ut = K.image.width,
        Ot = K.image.height,
        It = _t.convert(at.format),
        Gt = _t.convert(at.type);
      ot.setTexture2D(at, 0),
        z.pixelStorei(37440, at.flipY),
        z.pixelStorei(37441, at.premultiplyAlpha),
        z.pixelStorei(3317, at.unpackAlignment),
        K.isDataTexture
          ? z.texSubImage2D(3553, nt, D.x, D.y, ut, Ot, It, Gt, K.image.data)
          : K.isCompressedTexture
          ? z.compressedTexSubImage2D(
              3553,
              nt,
              D.x,
              D.y,
              K.mipmaps[0].width,
              K.mipmaps[0].height,
              It,
              K.mipmaps[0].data
            )
          : z.texSubImage2D(3553, nt, D.x, D.y, It, Gt, K.image),
        nt === 0 && at.generateMipmaps && z.generateMipmap(3553),
        dt.unbindTexture();
    }),
    (this.copyTextureToTexture3D = function (D, K, at, nt, ut = 0) {
      if (x.isWebGL1Renderer) {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
        );
        return;
      }
      const Ot = D.max.x - D.min.x + 1,
        It = D.max.y - D.min.y + 1,
        Gt = D.max.z - D.min.z + 1,
        $t = _t.convert(nt.format),
        Yt = _t.convert(nt.type);
      let Wt;
      if (nt.isDataTexture3D) ot.setTexture3D(nt, 0), (Wt = 32879);
      else if (nt.isDataTexture2DArray)
        ot.setTexture2DArray(nt, 0), (Wt = 35866);
      else {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
        );
        return;
      }
      z.pixelStorei(37440, nt.flipY),
        z.pixelStorei(37441, nt.premultiplyAlpha),
        z.pixelStorei(3317, nt.unpackAlignment);
      const Qt = z.getParameter(3314),
        Ee = z.getParameter(32878),
        _i = z.getParameter(3316),
        oe = z.getParameter(3315),
        dr = z.getParameter(32877),
        xe = at.isCompressedTexture ? at.mipmaps[0] : at.image;
      z.pixelStorei(3314, xe.width),
        z.pixelStorei(32878, xe.height),
        z.pixelStorei(3316, D.min.x),
        z.pixelStorei(3315, D.min.y),
        z.pixelStorei(32877, D.min.z),
        at.isDataTexture || at.isDataTexture3D
          ? z.texSubImage3D(Wt, ut, K.x, K.y, K.z, Ot, It, Gt, $t, Yt, xe.data)
          : at.isCompressedTexture
          ? (console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
            ),
            z.compressedTexSubImage3D(
              Wt,
              ut,
              K.x,
              K.y,
              K.z,
              Ot,
              It,
              Gt,
              $t,
              xe.data
            ))
          : z.texSubImage3D(Wt, ut, K.x, K.y, K.z, Ot, It, Gt, $t, Yt, xe),
        z.pixelStorei(3314, Qt),
        z.pixelStorei(32878, Ee),
        z.pixelStorei(3316, _i),
        z.pixelStorei(3315, oe),
        z.pixelStorei(32877, dr),
        ut === 0 && nt.generateMipmaps && z.generateMipmap(Wt),
        dt.unbindTexture();
    }),
    (this.initTexture = function (D) {
      ot.setTexture2D(D, 0), dt.unbindTexture();
    }),
    (this.resetState = function () {
      (_ = 0), (y = 0), (E = null), dt.reset(), Bt.reset();
    }),
    typeof __THREE_DEVTOOLS__ != "undefined" &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      );
}
Le.prototype.isWebGLRenderer = !0;
class TI extends Le {}
TI.prototype.isWebGL1Renderer = !0;
class Dx extends Me {
  constructor() {
    super();
    (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0),
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(t, e) {
    return (
      super.copy(t, e),
      t.background !== null && (this.background = t.background.clone()),
      t.environment !== null && (this.environment = t.environment.clone()),
      t.fog !== null && (this.fog = t.fog.clone()),
      t.overrideMaterial !== null &&
        (this.overrideMaterial = t.overrideMaterial.clone()),
      (this.autoUpdate = t.autoUpdate),
      (this.matrixAutoUpdate = t.matrixAutoUpdate),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), e;
  }
}
Dx.prototype.isScene = !0;
class Al {
  constructor(t, e) {
    (this.array = t),
      (this.stride = e),
      (this.count = t !== void 0 ? t.length / e : 0),
      (this.usage = vl),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = sr());
  }
  onUploadCallback() {}
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  setUsage(t) {
    return (this.usage = t), this;
  }
  copy(t) {
    return (
      (this.array = new t.array.constructor(t.array)),
      (this.count = t.count),
      (this.stride = t.stride),
      (this.usage = t.usage),
      this
    );
  }
  copyAt(t, e, n) {
    (t *= this.stride), (n *= e.stride);
    for (let i = 0, r = this.stride; i < r; i++)
      this.array[t + i] = e.array[n + i];
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  clone(t) {
    t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = sr()),
      t.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e = new this.array.constructor(
        t.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(e, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(t) {
    return (this.onUploadCallback = t), this;
  }
  toJSON(t) {
    return (
      t.arrayBuffers === void 0 && (t.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = sr()),
      t.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
Al.prototype.isInterleavedBuffer = !0;
const nn = new k();
class Ll {
  constructor(t, e, n, i = !1) {
    (this.name = ""),
      (this.data = t),
      (this.itemSize = e),
      (this.offset = n),
      (this.normalized = i === !0);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(t) {
    this.data.needsUpdate = t;
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.data.count; e < n; e++)
      (nn.x = this.getX(e)),
        (nn.y = this.getY(e)),
        (nn.z = this.getZ(e)),
        nn.applyMatrix4(t),
        this.setXYZ(e, nn.x, nn.y, nn.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      (nn.x = this.getX(e)),
        (nn.y = this.getY(e)),
        (nn.z = this.getZ(e)),
        nn.applyNormalMatrix(t),
        this.setXYZ(e, nn.x, nn.y, nn.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      (nn.x = this.getX(e)),
        (nn.y = this.getY(e)),
        (nn.z = this.getZ(e)),
        nn.transformDirection(t),
        this.setXYZ(e, nn.x, nn.y, nn.z);
    return this;
  }
  setX(t, e) {
    return (this.data.array[t * this.data.stride + this.offset] = e), this;
  }
  setY(t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 1] = e), this;
  }
  setZ(t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 2] = e), this;
  }
  setW(t, e) {
    return (this.data.array[t * this.data.stride + this.offset + 3] = e), this;
  }
  getX(t) {
    return this.data.array[t * this.data.stride + this.offset];
  }
  getY(t) {
    return this.data.array[t * this.data.stride + this.offset + 1];
  }
  getZ(t) {
    return this.data.array[t * this.data.stride + this.offset + 2];
  }
  getW(t) {
    return this.data.array[t * this.data.stride + this.offset + 3];
  }
  setXY(t, e, n) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      this
    );
  }
  setXYZ(t, e, n, i) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = i),
      this
    );
  }
  setXYZW(t, e, n, i, r) {
    return (
      (t = t * this.data.stride + this.offset),
      (this.data.array[t + 0] = e),
      (this.data.array[t + 1] = n),
      (this.data.array[t + 2] = i),
      (this.data.array[t + 3] = r),
      this
    );
  }
  clone(t) {
    if (t === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
      );
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[i + r]);
      }
      return new hn(
        new this.array.constructor(e),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
        t.interleavedBuffers[this.data.uuid] === void 0 &&
          (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
        new Ll(
          t.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(t) {
    if (t === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
      );
      const e = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++) e.push(this.data.array[i + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized,
      };
    } else
      return (
        t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}),
        t.interleavedBuffers[this.data.uuid] === void 0 &&
          (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
Ll.prototype.isInterleavedBufferAttribute = !0;
class Fx extends Rn {
  constructor(t) {
    super();
    (this.type = "SpriteMaterial"),
      (this.color = new Xt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.rotation = t.rotation),
      (this.sizeAttenuation = t.sizeAttenuation),
      this
    );
  }
}
Fx.prototype.isSpriteMaterial = !0;
let wa;
const Cl = new k(),
  ba = new k(),
  Ma = new k(),
  Sa = new Et(),
  Rl = new Et(),
  Ox = new Jt(),
  Gu = new k(),
  Pl = new k(),
  Hu = new k(),
  Nx = new Et(),
  up = new Et(),
  Bx = new Et();
class EI extends Me {
  constructor(t) {
    super();
    if (((this.type = "Sprite"), wa === void 0)) {
      wa = new Ge();
      const e = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        n = new Al(e, 5);
      wa.setIndex([0, 1, 2, 0, 2, 3]),
        wa.setAttribute("position", new Ll(n, 3, 0, !1)),
        wa.setAttribute("uv", new Ll(n, 2, 3, !1));
    }
    (this.geometry = wa),
      (this.material = t !== void 0 ? t : new Fx()),
      (this.center = new Et(0.5, 0.5));
  }
  raycast(t, e) {
    t.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      ba.setFromMatrixScale(this.matrixWorld),
      Ox.copy(t.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        t.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      Ma.setFromMatrixPosition(this.modelViewMatrix),
      t.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        ba.multiplyScalar(-Ma.z);
    const n = this.material.rotation;
    let i, r;
    n !== 0 && ((r = Math.cos(n)), (i = Math.sin(n)));
    const o = this.center;
    Vu(Gu.set(-0.5, -0.5, 0), Ma, o, ba, i, r),
      Vu(Pl.set(0.5, -0.5, 0), Ma, o, ba, i, r),
      Vu(Hu.set(0.5, 0.5, 0), Ma, o, ba, i, r),
      Nx.set(0, 0),
      up.set(1, 0),
      Bx.set(1, 1);
    let l = t.ray.intersectTriangle(Gu, Pl, Hu, !1, Cl);
    if (
      l === null &&
      (Vu(Pl.set(-0.5, 0.5, 0), Ma, o, ba, i, r),
      up.set(0, 1),
      (l = t.ray.intersectTriangle(Gu, Hu, Pl, !1, Cl)),
      l === null)
    )
      return;
    const u = t.ray.origin.distanceTo(Cl);
    u < t.near ||
      u > t.far ||
      e.push({
        distance: u,
        point: Cl.clone(),
        uv: an.getUV(Cl, Gu, Pl, Hu, Nx, up, Bx, new Et()),
        face: null,
        object: this,
      });
  }
  copy(t) {
    return (
      super.copy(t),
      t.center !== void 0 && this.center.copy(t.center),
      (this.material = t.material),
      this
    );
  }
}
EI.prototype.isSprite = !0;
function Vu(a, t, e, n, i, r) {
  Sa.subVectors(a, e).addScalar(0.5).multiply(n),
    i !== void 0
      ? ((Rl.x = r * Sa.x - i * Sa.y), (Rl.y = i * Sa.x + r * Sa.y))
      : Rl.copy(Sa),
    a.copy(t),
    (a.x += Rl.x),
    (a.y += Rl.y),
    a.applyMatrix4(Ox);
}
const zx = new k(),
  Ux = new Fe(),
  kx = new Fe(),
  AI = new k(),
  Gx = new Jt();
class Hx extends ti {
  constructor(t, e) {
    super(t, e);
    (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new Jt()),
      (this.bindMatrixInverse = new Jt());
  }
  copy(t) {
    return (
      super.copy(t),
      (this.bindMode = t.bindMode),
      this.bindMatrix.copy(t.bindMatrix),
      this.bindMatrixInverse.copy(t.bindMatrixInverse),
      (this.skeleton = t.skeleton),
      this
    );
  }
  bind(t, e) {
    (this.skeleton = t),
      e === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (e = this.matrixWorld)),
      this.bindMatrix.copy(e),
      this.bindMatrixInverse.copy(e).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const t = new Fe(),
      e = this.geometry.attributes.skinWeight;
    for (let n = 0, i = e.count; n < i; n++) {
      (t.x = e.getX(n)),
        (t.y = e.getY(n)),
        (t.z = e.getZ(n)),
        (t.w = e.getW(n));
      const r = 1 / t.manhattanLength();
      r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
        e.setXYZW(n, t.x, t.y, t.z, t.w);
    }
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  boneTransform(t, e) {
    const n = this.skeleton,
      i = this.geometry;
    Ux.fromBufferAttribute(i.attributes.skinIndex, t),
      kx.fromBufferAttribute(i.attributes.skinWeight, t),
      zx.copy(e).applyMatrix4(this.bindMatrix),
      e.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const o = kx.getComponent(r);
      if (o !== 0) {
        const l = Ux.getComponent(r);
        Gx.multiplyMatrices(n.bones[l].matrixWorld, n.boneInverses[l]),
          e.addScaledVector(AI.copy(zx).applyMatrix4(Gx), o);
      }
    }
    return e.applyMatrix4(this.bindMatrixInverse);
  }
}
Hx.prototype.isSkinnedMesh = !0;
class LI extends Me {
  constructor() {
    super();
    this.type = "Bone";
  }
}
LI.prototype.isBone = !0;
class CI extends Sn {
  constructor(t = null, e = 1, n = 1, i, r, o, l, u, h = mn, f = mn, m, g) {
    super(null, o, l, u, h, f, i, r, m, g);
    (this.image = { data: t, width: e, height: n }),
      (this.magFilter = h),
      (this.minFilter = f),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
}
CI.prototype.isDataTexture = !0;
class hp extends hn {
  constructor(t, e, n, i = 1) {
    typeof n == "number" &&
      ((i = n),
      (n = !1),
      console.error(
        "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
      ));
    super(t, e, n);
    this.meshPerAttribute = i;
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.meshPerAttribute = this.meshPerAttribute),
      (t.isInstancedBufferAttribute = !0),
      t
    );
  }
}
hp.prototype.isInstancedBufferAttribute = !0;
const Vx = new Jt(),
  Wx = new Jt(),
  Wu = [],
  Il = new ti();
class RI extends ti {
  constructor(t, e, n) {
    super(t, e);
    (this.instanceMatrix = new hp(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.count = n),
      (this.frustumCulled = !1);
  }
  copy(t) {
    return (
      super.copy(t),
      this.instanceMatrix.copy(t.instanceMatrix),
      t.instanceColor !== null &&
        (this.instanceColor = t.instanceColor.clone()),
      (this.count = t.count),
      this
    );
  }
  getColorAt(t, e) {
    e.fromArray(this.instanceColor.array, t * 3);
  }
  getMatrixAt(t, e) {
    e.fromArray(this.instanceMatrix.array, t * 16);
  }
  raycast(t, e) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((Il.geometry = this.geometry),
      (Il.material = this.material),
      Il.material !== void 0)
    )
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, Vx),
          Wx.multiplyMatrices(n, Vx),
          (Il.matrixWorld = Wx),
          Il.raycast(t, Wu);
        for (let o = 0, l = Wu.length; o < l; o++) {
          const u = Wu[o];
          (u.instanceId = r), (u.object = this), e.push(u);
        }
        Wu.length = 0;
      }
  }
  setColorAt(t, e) {
    this.instanceColor === null &&
      (this.instanceColor = new hp(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      e.toArray(this.instanceColor.array, t * 3);
  }
  setMatrixAt(t, e) {
    e.toArray(this.instanceMatrix.array, t * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
RI.prototype.isInstancedMesh = !0;
class Dl extends Rn {
  constructor(t) {
    super();
    (this.type = "LineBasicMaterial"),
      (this.color = new Xt(16777215)),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.linewidth = t.linewidth),
      (this.linecap = t.linecap),
      (this.linejoin = t.linejoin),
      this
    );
  }
}
Dl.prototype.isLineBasicMaterial = !0;
const Xx = new k(),
  Yx = new k(),
  qx = new Jt(),
  fp = new to(),
  Xu = new sa();
class dp extends Me {
  constructor(t = new Ge(), e = new Dl()) {
    super();
    (this.type = "Line"),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets();
  }
  copy(t) {
    return (
      super.copy(t),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (t.index === null) {
        const e = t.attributes.position,
          n = [0];
        for (let i = 1, r = e.count; i < r; i++)
          Xx.fromBufferAttribute(e, i - 1),
            Yx.fromBufferAttribute(e, i),
            (n[i] = n[i - 1]),
            (n[i] += Xx.distanceTo(Yx));
        t.setAttribute("lineDistance", new en(n, 1));
      } else
        console.warn(
          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
    else
      t.isGeometry &&
        console.error(
          "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    return this;
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = t.params.Line.threshold,
      o = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Xu.copy(n.boundingSphere),
      Xu.applyMatrix4(i),
      (Xu.radius += r),
      t.ray.intersectsSphere(Xu) === !1)
    )
      return;
    qx.copy(i).invert(), fp.copy(t.ray).applyMatrix4(qx);
    const l = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = l * l,
      h = new k(),
      f = new k(),
      m = new k(),
      g = new k(),
      p = this.isLineSegments ? 2 : 1;
    if (n.isBufferGeometry) {
      const v = n.index,
        b = n.attributes.position;
      if (v !== null) {
        const _ = Math.max(0, o.start),
          y = Math.min(v.count, o.start + o.count);
        for (let E = _, M = y - 1; E < M; E += p) {
          const A = v.getX(E),
            R = v.getX(E + 1);
          if (
            (h.fromBufferAttribute(b, A),
            f.fromBufferAttribute(b, R),
            fp.distanceSqToSegment(h, f, g, m) > u)
          )
            continue;
          g.applyMatrix4(this.matrixWorld);
          const B = t.ray.origin.distanceTo(g);
          B < t.near ||
            B > t.far ||
            e.push({
              distance: B,
              point: m.clone().applyMatrix4(this.matrixWorld),
              index: E,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else {
        const _ = Math.max(0, o.start),
          y = Math.min(b.count, o.start + o.count);
        for (let E = _, M = y - 1; E < M; E += p) {
          if (
            (h.fromBufferAttribute(b, E),
            f.fromBufferAttribute(b, E + 1),
            fp.distanceSqToSegment(h, f, g, m) > u)
          )
            continue;
          g.applyMatrix4(this.matrixWorld);
          const R = t.ray.origin.distanceTo(g);
          R < t.near ||
            R > t.far ||
            e.push({
              distance: R,
              point: m.clone().applyMatrix4(this.matrixWorld),
              index: E,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      }
    } else
      n.isGeometry &&
        console.error(
          "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
  }
  updateMorphTargets() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e);
      if (n.length > 0) {
        const i = e[n[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, o = i.length; r < o; r++) {
            const l = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[l] = r);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 &&
        e.length > 0 &&
        console.error(
          "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  }
}
dp.prototype.isLine = !0;
const Zx = new k(),
  jx = new k();
class pp extends dp {
  constructor(t, e) {
    super(t, e);
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.isBufferGeometry)
      if (t.index === null) {
        const e = t.attributes.position,
          n = [];
        for (let i = 0, r = e.count; i < r; i += 2)
          Zx.fromBufferAttribute(e, i),
            jx.fromBufferAttribute(e, i + 1),
            (n[i] = i === 0 ? 0 : n[i - 1]),
            (n[i + 1] = n[i] + Zx.distanceTo(jx));
        t.setAttribute("lineDistance", new en(n, 1));
      } else
        console.warn(
          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
    else
      t.isGeometry &&
        console.error(
          "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    return this;
  }
}
pp.prototype.isLineSegments = !0;
class PI extends dp {
  constructor(t, e) {
    super(t, e);
    this.type = "LineLoop";
  }
}
PI.prototype.isLineLoop = !0;
class Jx extends Rn {
  constructor(t) {
    super();
    (this.type = "PointsMaterial"),
      (this.color = new Xt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.alphaMap = t.alphaMap),
      (this.size = t.size),
      (this.sizeAttenuation = t.sizeAttenuation),
      this
    );
  }
}
Jx.prototype.isPointsMaterial = !0;
const $x = new Jt(),
  mp = new to(),
  Yu = new sa(),
  qu = new k();
class II extends Me {
  constructor(t = new Ge(), e = new Jx()) {
    super();
    (this.type = "Points"),
      (this.geometry = t),
      (this.material = e),
      this.updateMorphTargets();
  }
  copy(t) {
    return (
      super.copy(t),
      (this.material = t.material),
      (this.geometry = t.geometry),
      this
    );
  }
  raycast(t, e) {
    const n = this.geometry,
      i = this.matrixWorld,
      r = t.params.Points.threshold,
      o = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Yu.copy(n.boundingSphere),
      Yu.applyMatrix4(i),
      (Yu.radius += r),
      t.ray.intersectsSphere(Yu) === !1)
    )
      return;
    $x.copy(i).invert(), mp.copy(t.ray).applyMatrix4($x);
    const l = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      u = l * l;
    if (n.isBufferGeometry) {
      const h = n.index,
        m = n.attributes.position;
      if (h !== null) {
        const g = Math.max(0, o.start),
          p = Math.min(h.count, o.start + o.count);
        for (let v = g, x = p; v < x; v++) {
          const b = h.getX(v);
          qu.fromBufferAttribute(m, b), Kx(qu, b, u, i, t, e, this);
        }
      } else {
        const g = Math.max(0, o.start),
          p = Math.min(m.count, o.start + o.count);
        for (let v = g, x = p; v < x; v++)
          qu.fromBufferAttribute(m, v), Kx(qu, v, u, i, t, e, this);
      }
    } else
      console.error(
        "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
      );
  }
  updateMorphTargets() {
    const t = this.geometry;
    if (t.isBufferGeometry) {
      const e = t.morphAttributes,
        n = Object.keys(e);
      if (n.length > 0) {
        const i = e[n[0]];
        if (i !== void 0) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let r = 0, o = i.length; r < o; r++) {
            const l = i[r].name || String(r);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[l] = r);
          }
        }
      }
    } else {
      const e = t.morphTargets;
      e !== void 0 &&
        e.length > 0 &&
        console.error(
          "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
        );
    }
  }
}
II.prototype.isPoints = !0;
function Kx(a, t, e, n, i, r, o) {
  const l = mp.distanceSqToPoint(a);
  if (l < e) {
    const u = new k();
    mp.closestPointToPoint(a, u), u.applyMatrix4(n);
    const h = i.ray.origin.distanceTo(u);
    if (h < i.near || h > i.far) return;
    r.push({
      distance: h,
      distanceToRay: Math.sqrt(l),
      point: u,
      index: t,
      face: null,
      object: o,
    });
  }
}
class DI extends Sn {
  constructor(t, e, n, i, r, o, l, u, h) {
    super(t, e, n, i, r, o, l, u, h);
    (this.format = l !== void 0 ? l : jo),
      (this.minFilter = o !== void 0 ? o : Oi),
      (this.magFilter = r !== void 0 ? r : Oi),
      (this.generateMipmaps = !1);
    const f = this;
    function m() {
      (f.needsUpdate = !0), t.requestVideoFrameCallback(m);
    }
    "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(m);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const t = this.image;
    "requestVideoFrameCallback" in t === !1 &&
      t.readyState >= t.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
DI.prototype.isVideoTexture = !0;
class FI extends Sn {
  constructor(t, e, n, i, r, o, l, u, h, f, m, g) {
    super(null, o, l, u, h, f, i, r, m, g);
    (this.image = { width: e, height: n }),
      (this.mipmaps = t),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
FI.prototype.isCompressedTexture = !0;
class OI extends Sn {
  constructor(t, e, n, i, r, o, l, u, h) {
    super(t, e, n, i, r, o, l, u, h);
    this.needsUpdate = !0;
  }
}
OI.prototype.isCanvasTexture = !0;
class NI extends Sn {
  constructor(t, e, n, i, r, o, l, u, h, f) {
    if (((f = f !== void 0 ? f : Jo), f !== Jo && f !== _l))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    n === void 0 && f === Jo && (n = fu), n === void 0 && f === _l && (n = gl);
    super(null, i, r, o, l, u, f, n, h);
    (this.image = { width: t, height: e }),
      (this.magFilter = l !== void 0 ? l : mn),
      (this.minFilter = u !== void 0 ? u : mn),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
NI.prototype.isDepthTexture = !0;
new k();
new k();
new k();
new an();
class Bi {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getPoint(n, e);
  }
  getPoints(t = 5) {
    const e = [];
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
    return e;
  }
  getSpacedPoints(t = 5) {
    const e = [];
    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
    return e;
  }
  getLength() {
    const t = this.getLengths();
    return t[t.length - 1];
  }
  getLengths(t = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === t + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const e = [];
    let n,
      i = this.getPoint(0),
      r = 0;
    e.push(0);
    for (let o = 1; o <= t; o++)
      (n = this.getPoint(o / t)), (r += n.distanceTo(i)), e.push(r), (i = n);
    return (this.cacheArcLengths = e), e;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(t, e) {
    const n = this.getLengths();
    let i = 0;
    const r = n.length;
    let o;
    e ? (o = e) : (o = t * n[r - 1]);
    let l = 0,
      u = r - 1,
      h;
    for (; l <= u; )
      if (((i = Math.floor(l + (u - l) / 2)), (h = n[i] - o), h < 0)) l = i + 1;
      else if (h > 0) u = i - 1;
      else {
        u = i;
        break;
      }
    if (((i = u), n[i] === o)) return i / (r - 1);
    const f = n[i],
      g = n[i + 1] - f,
      p = (o - f) / g;
    return (i + p) / (r - 1);
  }
  getTangent(t, e) {
    const n = 1e-4;
    let i = t - n,
      r = t + n;
    i < 0 && (i = 0), r > 1 && (r = 1);
    const o = this.getPoint(i),
      l = this.getPoint(r),
      u = e || (o.isVector2 ? new Et() : new k());
    return u.copy(l).sub(o).normalize(), u;
  }
  getTangentAt(t, e) {
    const n = this.getUtoTmapping(t);
    return this.getTangent(n, e);
  }
  computeFrenetFrames(t, e) {
    const n = new k(),
      i = [],
      r = [],
      o = [],
      l = new k(),
      u = new Jt();
    for (let p = 0; p <= t; p++) {
      const v = p / t;
      i[p] = this.getTangentAt(v, new k());
    }
    (r[0] = new k()), (o[0] = new k());
    let h = Number.MAX_VALUE;
    const f = Math.abs(i[0].x),
      m = Math.abs(i[0].y),
      g = Math.abs(i[0].z);
    f <= h && ((h = f), n.set(1, 0, 0)),
      m <= h && ((h = m), n.set(0, 1, 0)),
      g <= h && n.set(0, 0, 1),
      l.crossVectors(i[0], n).normalize(),
      r[0].crossVectors(i[0], l),
      o[0].crossVectors(i[0], r[0]);
    for (let p = 1; p <= t; p++) {
      if (
        ((r[p] = r[p - 1].clone()),
        (o[p] = o[p - 1].clone()),
        l.crossVectors(i[p - 1], i[p]),
        l.length() > Number.EPSILON)
      ) {
        l.normalize();
        const v = Math.acos(pi(i[p - 1].dot(i[p]), -1, 1));
        r[p].applyMatrix4(u.makeRotationAxis(l, v));
      }
      o[p].crossVectors(i[p], r[p]);
    }
    if (e === !0) {
      let p = Math.acos(pi(r[0].dot(r[t]), -1, 1));
      (p /= t), i[0].dot(l.crossVectors(r[0], r[t])) > 0 && (p = -p);
      for (let v = 1; v <= t; v++)
        r[v].applyMatrix4(u.makeRotationAxis(i[v], p * v)),
          o[v].crossVectors(i[v], r[v]);
    }
    return { tangents: i, normals: r, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
  }
  toJSON() {
    const t = {
      metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t
    );
  }
  fromJSON(t) {
    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
  }
}
class Zu extends Bi {
  constructor(
    t = 0,
    e = 0,
    n = 1,
    i = 1,
    r = 0,
    o = Math.PI * 2,
    l = !1,
    u = 0
  ) {
    super();
    (this.type = "EllipseCurve"),
      (this.aX = t),
      (this.aY = e),
      (this.xRadius = n),
      (this.yRadius = i),
      (this.aStartAngle = r),
      (this.aEndAngle = o),
      (this.aClockwise = l),
      (this.aRotation = u);
  }
  getPoint(t, e) {
    const n = e || new Et(),
      i = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += i;
    for (; r > i; ) r -= i;
    r < Number.EPSILON && (o ? (r = 0) : (r = i)),
      this.aClockwise === !0 && !o && (r === i ? (r = -i) : (r = r - i));
    const l = this.aStartAngle + t * r;
    let u = this.aX + this.xRadius * Math.cos(l),
      h = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const f = Math.cos(this.aRotation),
        m = Math.sin(this.aRotation),
        g = u - this.aX,
        p = h - this.aY;
      (u = g * f - p * m + this.aX), (h = g * m + p * f + this.aY);
    }
    return n.set(u, h);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.aX = this.aX),
      (t.aY = this.aY),
      (t.xRadius = this.xRadius),
      (t.yRadius = this.yRadius),
      (t.aStartAngle = this.aStartAngle),
      (t.aEndAngle = this.aEndAngle),
      (t.aClockwise = this.aClockwise),
      (t.aRotation = this.aRotation),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      (this.aX = t.aX),
      (this.aY = t.aY),
      (this.xRadius = t.xRadius),
      (this.yRadius = t.yRadius),
      (this.aStartAngle = t.aStartAngle),
      (this.aEndAngle = t.aEndAngle),
      (this.aClockwise = t.aClockwise),
      (this.aRotation = t.aRotation),
      this
    );
  }
}
Zu.prototype.isEllipseCurve = !0;
class Qx extends Zu {
  constructor(t, e, n, i, r, o) {
    super(t, e, n, n, i, r, o);
    this.type = "ArcCurve";
  }
}
Qx.prototype.isArcCurve = !0;
function gp() {
  let a = 0,
    t = 0,
    e = 0,
    n = 0;
  function i(r, o, l, u) {
    (a = r),
      (t = l),
      (e = -3 * r + 3 * o - 2 * l - u),
      (n = 2 * r - 2 * o + l + u);
  }
  return {
    initCatmullRom: function (r, o, l, u, h) {
      i(o, l, h * (l - r), h * (u - o));
    },
    initNonuniformCatmullRom: function (r, o, l, u, h, f, m) {
      let g = (o - r) / h - (l - r) / (h + f) + (l - o) / f,
        p = (l - o) / f - (u - o) / (f + m) + (u - l) / m;
      (g *= f), (p *= f), i(o, l, g, p);
    },
    calc: function (r) {
      const o = r * r,
        l = o * r;
      return a + t * r + e * o + n * l;
    },
  };
}
const ju = new k(),
  _p = new gp(),
  vp = new gp(),
  xp = new gp();
class ty extends Bi {
  constructor(t = [], e = !1, n = "centripetal", i = 0.5) {
    super();
    (this.type = "CatmullRomCurve3"),
      (this.points = t),
      (this.closed = e),
      (this.curveType = n),
      (this.tension = i);
  }
  getPoint(t, e = new k()) {
    const n = e,
      i = this.points,
      r = i.length,
      o = (r - (this.closed ? 0 : 1)) * t;
    let l = Math.floor(o),
      u = o - l;
    this.closed
      ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
      : u === 0 && l === r - 1 && ((l = r - 2), (u = 1));
    let h, f;
    this.closed || l > 0
      ? (h = i[(l - 1) % r])
      : (ju.subVectors(i[0], i[1]).add(i[0]), (h = ju));
    const m = i[l % r],
      g = i[(l + 1) % r];
    if (
      (this.closed || l + 2 < r
        ? (f = i[(l + 2) % r])
        : (ju.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (f = ju)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const p = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(h.distanceToSquared(m), p),
        x = Math.pow(m.distanceToSquared(g), p),
        b = Math.pow(g.distanceToSquared(f), p);
      x < 1e-4 && (x = 1),
        v < 1e-4 && (v = x),
        b < 1e-4 && (b = x),
        _p.initNonuniformCatmullRom(h.x, m.x, g.x, f.x, v, x, b),
        vp.initNonuniformCatmullRom(h.y, m.y, g.y, f.y, v, x, b),
        xp.initNonuniformCatmullRom(h.z, m.z, g.z, f.z, v, x, b);
    } else
      this.curveType === "catmullrom" &&
        (_p.initCatmullRom(h.x, m.x, g.x, f.x, this.tension),
        vp.initCatmullRom(h.y, m.y, g.y, f.y, this.tension),
        xp.initCatmullRom(h.z, m.z, g.z, f.z, this.tension));
    return n.set(_p.calc(u), vp.calc(u), xp.calc(u)), n;
  }
  copy(t) {
    super.copy(t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const i = t.points[e];
      this.points.push(i.clone());
    }
    return (
      (this.closed = t.closed),
      (this.curveType = t.curveType),
      (this.tension = t.tension),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, n = this.points.length; e < n; e++) {
      const i = this.points[e];
      t.points.push(i.toArray());
    }
    return (
      (t.closed = this.closed),
      (t.curveType = this.curveType),
      (t.tension = this.tension),
      t
    );
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const i = t.points[e];
      this.points.push(new k().fromArray(i));
    }
    return (
      (this.closed = t.closed),
      (this.curveType = t.curveType),
      (this.tension = t.tension),
      this
    );
  }
}
ty.prototype.isCatmullRomCurve3 = !0;
function ey(a, t, e, n, i) {
  const r = (n - t) * 0.5,
    o = (i - e) * 0.5,
    l = a * a,
    u = a * l;
  return (
    (2 * e - 2 * n + r + o) * u + (-3 * e + 3 * n - 2 * r - o) * l + r * a + e
  );
}
function BI(a, t) {
  const e = 1 - a;
  return e * e * t;
}
function zI(a, t) {
  return 2 * (1 - a) * a * t;
}
function UI(a, t) {
  return a * a * t;
}
function Fl(a, t, e, n) {
  return BI(a, t) + zI(a, e) + UI(a, n);
}
function kI(a, t) {
  const e = 1 - a;
  return e * e * e * t;
}
function GI(a, t) {
  const e = 1 - a;
  return 3 * e * e * a * t;
}
function HI(a, t) {
  return 3 * (1 - a) * a * a * t;
}
function VI(a, t) {
  return a * a * a * t;
}
function Ol(a, t, e, n, i) {
  return kI(a, t) + GI(a, e) + HI(a, n) + VI(a, i);
}
class yp extends Bi {
  constructor(t = new Et(), e = new Et(), n = new Et(), i = new Et()) {
    super();
    (this.type = "CubicBezierCurve"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(t, e = new Et()) {
    const n = e,
      i = this.v0,
      r = this.v1,
      o = this.v2,
      l = this.v3;
    return n.set(Ol(t, i.x, r.x, o.x, l.x), Ol(t, i.y, r.y, o.y, l.y)), n;
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    );
  }
}
yp.prototype.isCubicBezierCurve = !0;
class ny extends Bi {
  constructor(t = new k(), e = new k(), n = new k(), i = new k()) {
    super();
    (this.type = "CubicBezierCurve3"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n),
      (this.v3 = i);
  }
  getPoint(t, e = new k()) {
    const n = e,
      i = this.v0,
      r = this.v1,
      o = this.v2,
      l = this.v3;
    return (
      n.set(
        Ol(t, i.x, r.x, o.x, l.x),
        Ol(t, i.y, r.y, o.y, l.y),
        Ol(t, i.z, r.z, o.z, l.z)
      ),
      n
    );
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this.v3.copy(t.v3),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      (t.v3 = this.v3.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this.v3.fromArray(t.v3),
      this
    );
  }
}
ny.prototype.isCubicBezierCurve3 = !0;
class Ju extends Bi {
  constructor(t = new Et(), e = new Et()) {
    super();
    (this.type = "LineCurve"), (this.v1 = t), (this.v2 = e);
  }
  getPoint(t, e = new Et()) {
    const n = e;
    return (
      t === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    );
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  getTangent(t, e) {
    const n = e || new Et();
    return n.copy(this.v2).sub(this.v1).normalize(), n;
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }
  fromJSON(t) {
    return (
      super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    );
  }
}
Ju.prototype.isLineCurve = !0;
class WI extends Bi {
  constructor(t = new k(), e = new k()) {
    super();
    (this.type = "LineCurve3"),
      (this.isLineCurve3 = !0),
      (this.v1 = t),
      (this.v2 = e);
  }
  getPoint(t, e = new k()) {
    const n = e;
    return (
      t === 1
        ? n.copy(this.v2)
        : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
      n
    );
  }
  getPointAt(t, e) {
    return this.getPoint(t, e);
  }
  copy(t) {
    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
  }
  fromJSON(t) {
    return (
      super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    );
  }
}
class wp extends Bi {
  constructor(t = new Et(), e = new Et(), n = new Et()) {
    super();
    (this.type = "QuadraticBezierCurve"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n);
  }
  getPoint(t, e = new Et()) {
    const n = e,
      i = this.v0,
      r = this.v1,
      o = this.v2;
    return n.set(Fl(t, i.x, r.x, o.x), Fl(t, i.y, r.y, o.y)), n;
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }
}
wp.prototype.isQuadraticBezierCurve = !0;
class iy extends Bi {
  constructor(t = new k(), e = new k(), n = new k()) {
    super();
    (this.type = "QuadraticBezierCurve3"),
      (this.v0 = t),
      (this.v1 = e),
      (this.v2 = n);
  }
  getPoint(t, e = new k()) {
    const n = e,
      i = this.v0,
      r = this.v1,
      o = this.v2;
    return (
      n.set(Fl(t, i.x, r.x, o.x), Fl(t, i.y, r.y, o.y), Fl(t, i.z, r.z, o.z)), n
    );
  }
  copy(t) {
    return (
      super.copy(t),
      this.v0.copy(t.v0),
      this.v1.copy(t.v1),
      this.v2.copy(t.v2),
      this
    );
  }
  toJSON() {
    const t = super.toJSON();
    return (
      (t.v0 = this.v0.toArray()),
      (t.v1 = this.v1.toArray()),
      (t.v2 = this.v2.toArray()),
      t
    );
  }
  fromJSON(t) {
    return (
      super.fromJSON(t),
      this.v0.fromArray(t.v0),
      this.v1.fromArray(t.v1),
      this.v2.fromArray(t.v2),
      this
    );
  }
}
iy.prototype.isQuadraticBezierCurve3 = !0;
class bp extends Bi {
  constructor(t = []) {
    super();
    (this.type = "SplineCurve"), (this.points = t);
  }
  getPoint(t, e = new Et()) {
    const n = e,
      i = this.points,
      r = (i.length - 1) * t,
      o = Math.floor(r),
      l = r - o,
      u = i[o === 0 ? o : o - 1],
      h = i[o],
      f = i[o > i.length - 2 ? i.length - 1 : o + 1],
      m = i[o > i.length - 3 ? i.length - 1 : o + 2];
    return n.set(ey(l, u.x, h.x, f.x, m.x), ey(l, u.y, h.y, f.y, m.y)), n;
  }
  copy(t) {
    super.copy(t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const i = t.points[e];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    t.points = [];
    for (let e = 0, n = this.points.length; e < n; e++) {
      const i = this.points[e];
      t.points.push(i.toArray());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.points = []);
    for (let e = 0, n = t.points.length; e < n; e++) {
      const i = t.points[e];
      this.points.push(new Et().fromArray(i));
    }
    return this;
  }
}
bp.prototype.isSplineCurve = !0;
var ry = Object.freeze({
  __proto__: null,
  ArcCurve: Qx,
  CatmullRomCurve3: ty,
  CubicBezierCurve: yp,
  CubicBezierCurve3: ny,
  EllipseCurve: Zu,
  LineCurve: Ju,
  LineCurve3: WI,
  QuadraticBezierCurve: wp,
  QuadraticBezierCurve3: iy,
  SplineCurve: bp,
});
class XI extends Bi {
  constructor() {
    super();
    (this.type = "CurvePath"), (this.curves = []), (this.autoClose = !1);
  }
  add(t) {
    this.curves.push(t);
  }
  closePath() {
    const t = this.curves[0].getPoint(0),
      e = this.curves[this.curves.length - 1].getPoint(1);
    t.equals(e) || this.curves.push(new Ju(e, t));
  }
  getPoint(t, e) {
    const n = t * this.getLength(),
      i = this.getCurveLengths();
    let r = 0;
    for (; r < i.length; ) {
      if (i[r] >= n) {
        const o = i[r] - n,
          l = this.curves[r],
          u = l.getLength(),
          h = u === 0 ? 0 : 1 - o / u;
        return l.getPointAt(h, e);
      }
      r++;
    }
    return null;
  }
  getLength() {
    const t = this.getCurveLengths();
    return t[t.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const t = [];
    let e = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      (e += this.curves[n].getLength()), t.push(e);
    return (this.cacheLengths = t), t;
  }
  getSpacedPoints(t = 40) {
    const e = [];
    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
    return this.autoClose && e.push(e[0]), e;
  }
  getPoints(t = 12) {
    const e = [];
    let n;
    for (let i = 0, r = this.curves; i < r.length; i++) {
      const o = r[i],
        l =
          o && o.isEllipseCurve
            ? t * 2
            : o && (o.isLineCurve || o.isLineCurve3)
            ? 1
            : o && o.isSplineCurve
            ? t * o.points.length
            : t,
        u = o.getPoints(l);
      for (let h = 0; h < u.length; h++) {
        const f = u[h];
        (n && n.equals(f)) || (e.push(f), (n = f));
      }
    }
    return (
      this.autoClose &&
        e.length > 1 &&
        !e[e.length - 1].equals(e[0]) &&
        e.push(e[0]),
      e
    );
  }
  copy(t) {
    super.copy(t), (this.curves = []);
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const i = t.curves[e];
      this.curves.push(i.clone());
    }
    return (this.autoClose = t.autoClose), this;
  }
  toJSON() {
    const t = super.toJSON();
    (t.autoClose = this.autoClose), (t.curves = []);
    for (let e = 0, n = this.curves.length; e < n; e++) {
      const i = this.curves[e];
      t.curves.push(i.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
    for (let e = 0, n = t.curves.length; e < n; e++) {
      const i = t.curves[e];
      this.curves.push(new ry[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Mp extends XI {
  constructor(t) {
    super();
    (this.type = "Path"),
      (this.currentPoint = new Et()),
      t && this.setFromPoints(t);
  }
  setFromPoints(t) {
    this.moveTo(t[0].x, t[0].y);
    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
    return this;
  }
  moveTo(t, e) {
    return this.currentPoint.set(t, e), this;
  }
  lineTo(t, e) {
    const n = new Ju(this.currentPoint.clone(), new Et(t, e));
    return this.curves.push(n), this.currentPoint.set(t, e), this;
  }
  quadraticCurveTo(t, e, n, i) {
    const r = new wp(this.currentPoint.clone(), new Et(t, e), new Et(n, i));
    return this.curves.push(r), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(t, e, n, i, r, o) {
    const l = new yp(
      this.currentPoint.clone(),
      new Et(t, e),
      new Et(n, i),
      new Et(r, o)
    );
    return this.curves.push(l), this.currentPoint.set(r, o), this;
  }
  splineThru(t) {
    const e = [this.currentPoint.clone()].concat(t),
      n = new bp(e);
    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
  }
  arc(t, e, n, i, r, o) {
    const l = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absarc(t + l, e + u, n, i, r, o), this;
  }
  absarc(t, e, n, i, r, o) {
    return this.absellipse(t, e, n, n, i, r, o), this;
  }
  ellipse(t, e, n, i, r, o, l, u) {
    const h = this.currentPoint.x,
      f = this.currentPoint.y;
    return this.absellipse(t + h, e + f, n, i, r, o, l, u), this;
  }
  absellipse(t, e, n, i, r, o, l, u) {
    const h = new Zu(t, e, n, i, r, o, l, u);
    if (this.curves.length > 0) {
      const m = h.getPoint(0);
      m.equals(this.currentPoint) || this.lineTo(m.x, m.y);
    }
    this.curves.push(h);
    const f = h.getPoint(1);
    return this.currentPoint.copy(f), this;
  }
  copy(t) {
    return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
  }
  toJSON() {
    const t = super.toJSON();
    return (t.currentPoint = this.currentPoint.toArray()), t;
  }
  fromJSON(t) {
    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
  }
}
class Nl extends Mp {
  constructor(t) {
    super(t);
    (this.uuid = sr()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(t) {
    const e = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      e[n] = this.holes[n].getPoints(t);
    return e;
  }
  extractPoints(t) {
    return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
  }
  copy(t) {
    super.copy(t), (this.holes = []);
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const i = t.holes[e];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const t = super.toJSON();
    (t.uuid = this.uuid), (t.holes = []);
    for (let e = 0, n = this.holes.length; e < n; e++) {
      const i = this.holes[e];
      t.holes.push(i.toJSON());
    }
    return t;
  }
  fromJSON(t) {
    super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
    for (let e = 0, n = t.holes.length; e < n; e++) {
      const i = t.holes[e];
      this.holes.push(new Mp().fromJSON(i));
    }
    return this;
  }
}
const YI = {
  triangulate: function (a, t, e = 2) {
    const n = t && t.length,
      i = n ? t[0] * e : a.length;
    let r = sy(a, 0, i, e, !0);
    const o = [];
    if (!r || r.next === r.prev) return o;
    let l, u, h, f, m, g, p;
    if ((n && (r = $I(a, t, r, e)), a.length > 80 * e)) {
      (l = h = a[0]), (u = f = a[1]);
      for (let v = e; v < i; v += e)
        (m = a[v]),
          (g = a[v + 1]),
          m < l && (l = m),
          g < u && (u = g),
          m > h && (h = m),
          g > f && (f = g);
      (p = Math.max(h - l, f - u)), (p = p !== 0 ? 1 / p : 0);
    }
    return Bl(r, o, e, l, u, p), o;
  },
};
function sy(a, t, e, n, i) {
  let r, o;
  if (i === lD(a, t, e, n) > 0)
    for (r = t; r < e; r += n) o = ly(r, a[r], a[r + 1], o);
  else for (r = e - n; r >= t; r -= n) o = ly(r, a[r], a[r + 1], o);
  return o && $u(o, o.next) && (Ul(o), (o = o.next)), o;
}
function bs(a, t) {
  if (!a) return a;
  t || (t = a);
  let e = a,
    n;
  do
    if (
      ((n = !1), !e.steiner && ($u(e, e.next) || Ze(e.prev, e, e.next) === 0))
    ) {
      if ((Ul(e), (e = t = e.prev), e === e.next)) break;
      n = !0;
    } else e = e.next;
  while (n || e !== t);
  return t;
}
function Bl(a, t, e, n, i, r, o) {
  if (!a) return;
  !o && r && nD(a, n, i, r);
  let l = a,
    u,
    h;
  for (; a.prev !== a.next; ) {
    if (((u = a.prev), (h = a.next), r ? ZI(a, n, i, r) : qI(a))) {
      t.push(u.i / e),
        t.push(a.i / e),
        t.push(h.i / e),
        Ul(a),
        (a = h.next),
        (l = h.next);
      continue;
    }
    if (((a = h), a === l)) {
      o
        ? o === 1
          ? ((a = jI(bs(a), t, e)), Bl(a, t, e, n, i, r, 2))
          : o === 2 && JI(a, t, e, n, i, r)
        : Bl(bs(a), t, e, n, i, r, 1);
      break;
    }
  }
}
function qI(a) {
  const t = a.prev,
    e = a,
    n = a.next;
  if (Ze(t, e, n) >= 0) return !1;
  let i = a.next.next;
  for (; i !== a.prev; ) {
    if (
      Ta(t.x, t.y, e.x, e.y, n.x, n.y, i.x, i.y) &&
      Ze(i.prev, i, i.next) >= 0
    )
      return !1;
    i = i.next;
  }
  return !0;
}
function ZI(a, t, e, n) {
  const i = a.prev,
    r = a,
    o = a.next;
  if (Ze(i, r, o) >= 0) return !1;
  const l = i.x < r.x ? (i.x < o.x ? i.x : o.x) : r.x < o.x ? r.x : o.x,
    u = i.y < r.y ? (i.y < o.y ? i.y : o.y) : r.y < o.y ? r.y : o.y,
    h = i.x > r.x ? (i.x > o.x ? i.x : o.x) : r.x > o.x ? r.x : o.x,
    f = i.y > r.y ? (i.y > o.y ? i.y : o.y) : r.y > o.y ? r.y : o.y,
    m = Sp(l, u, t, e, n),
    g = Sp(h, f, t, e, n);
  let p = a.prevZ,
    v = a.nextZ;
  for (; p && p.z >= m && v && v.z <= g; ) {
    if (
      (p !== a.prev &&
        p !== a.next &&
        Ta(i.x, i.y, r.x, r.y, o.x, o.y, p.x, p.y) &&
        Ze(p.prev, p, p.next) >= 0) ||
      ((p = p.prevZ),
      v !== a.prev &&
        v !== a.next &&
        Ta(i.x, i.y, r.x, r.y, o.x, o.y, v.x, v.y) &&
        Ze(v.prev, v, v.next) >= 0)
    )
      return !1;
    v = v.nextZ;
  }
  for (; p && p.z >= m; ) {
    if (
      p !== a.prev &&
      p !== a.next &&
      Ta(i.x, i.y, r.x, r.y, o.x, o.y, p.x, p.y) &&
      Ze(p.prev, p, p.next) >= 0
    )
      return !1;
    p = p.prevZ;
  }
  for (; v && v.z <= g; ) {
    if (
      v !== a.prev &&
      v !== a.next &&
      Ta(i.x, i.y, r.x, r.y, o.x, o.y, v.x, v.y) &&
      Ze(v.prev, v, v.next) >= 0
    )
      return !1;
    v = v.nextZ;
  }
  return !0;
}
function jI(a, t, e) {
  let n = a;
  do {
    const i = n.prev,
      r = n.next.next;
    !$u(i, r) &&
      oy(i, n, n.next, r) &&
      zl(i, r) &&
      zl(r, i) &&
      (t.push(i.i / e),
      t.push(n.i / e),
      t.push(r.i / e),
      Ul(n),
      Ul(n.next),
      (n = a = r)),
      (n = n.next);
  } while (n !== a);
  return bs(n);
}
function JI(a, t, e, n, i, r) {
  let o = a;
  do {
    let l = o.next.next;
    for (; l !== o.prev; ) {
      if (o.i !== l.i && sD(o, l)) {
        let u = ay(o, l);
        (o = bs(o, o.next)),
          (u = bs(u, u.next)),
          Bl(o, t, e, n, i, r),
          Bl(u, t, e, n, i, r);
        return;
      }
      l = l.next;
    }
    o = o.next;
  } while (o !== a);
}
function $I(a, t, e, n) {
  const i = [];
  let r, o, l, u, h;
  for (r = 0, o = t.length; r < o; r++)
    (l = t[r] * n),
      (u = r < o - 1 ? t[r + 1] * n : a.length),
      (h = sy(a, l, u, n, !1)),
      h === h.next && (h.steiner = !0),
      i.push(rD(h));
  for (i.sort(KI), r = 0; r < i.length; r++) QI(i[r], e), (e = bs(e, e.next));
  return e;
}
function KI(a, t) {
  return a.x - t.x;
}
function QI(a, t) {
  if (((t = tD(a, t)), t)) {
    const e = ay(t, a);
    bs(t, t.next), bs(e, e.next);
  }
}
function tD(a, t) {
  let e = t;
  const n = a.x,
    i = a.y;
  let r = -1 / 0,
    o;
  do {
    if (i <= e.y && i >= e.next.y && e.next.y !== e.y) {
      const g = e.x + ((i - e.y) * (e.next.x - e.x)) / (e.next.y - e.y);
      if (g <= n && g > r) {
        if (((r = g), g === n)) {
          if (i === e.y) return e;
          if (i === e.next.y) return e.next;
        }
        o = e.x < e.next.x ? e : e.next;
      }
    }
    e = e.next;
  } while (e !== t);
  if (!o) return null;
  if (n === r) return o;
  const l = o,
    u = o.x,
    h = o.y;
  let f = 1 / 0,
    m;
  e = o;
  do
    n >= e.x &&
      e.x >= u &&
      n !== e.x &&
      Ta(i < h ? n : r, i, u, h, i < h ? r : n, i, e.x, e.y) &&
      ((m = Math.abs(i - e.y) / (n - e.x)),
      zl(e, a) &&
        (m < f || (m === f && (e.x > o.x || (e.x === o.x && eD(o, e))))) &&
        ((o = e), (f = m))),
      (e = e.next);
  while (e !== l);
  return o;
}
function eD(a, t) {
  return Ze(a.prev, a, t.prev) < 0 && Ze(t.next, a, a.next) < 0;
}
function nD(a, t, e, n) {
  let i = a;
  do
    i.z === null && (i.z = Sp(i.x, i.y, t, e, n)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== a);
  (i.prevZ.nextZ = null), (i.prevZ = null), iD(i);
}
function iD(a) {
  let t,
    e,
    n,
    i,
    r,
    o,
    l,
    u,
    h = 1;
  do {
    for (e = a, a = null, r = null, o = 0; e; ) {
      for (o++, n = e, l = 0, t = 0; t < h && (l++, (n = n.nextZ), !!n); t++);
      for (u = h; l > 0 || (u > 0 && n); )
        l !== 0 && (u === 0 || !n || e.z <= n.z)
          ? ((i = e), (e = e.nextZ), l--)
          : ((i = n), (n = n.nextZ), u--),
          r ? (r.nextZ = i) : (a = i),
          (i.prevZ = r),
          (r = i);
      e = n;
    }
    (r.nextZ = null), (h *= 2);
  } while (o > 1);
  return a;
}
function Sp(a, t, e, n, i) {
  return (
    (a = 32767 * (a - e) * i),
    (t = 32767 * (t - n) * i),
    (a = (a | (a << 8)) & 16711935),
    (a = (a | (a << 4)) & 252645135),
    (a = (a | (a << 2)) & 858993459),
    (a = (a | (a << 1)) & 1431655765),
    (t = (t | (t << 8)) & 16711935),
    (t = (t | (t << 4)) & 252645135),
    (t = (t | (t << 2)) & 858993459),
    (t = (t | (t << 1)) & 1431655765),
    a | (t << 1)
  );
}
function rD(a) {
  let t = a,
    e = a;
  do (t.x < e.x || (t.x === e.x && t.y < e.y)) && (e = t), (t = t.next);
  while (t !== a);
  return e;
}
function Ta(a, t, e, n, i, r, o, l) {
  return (
    (i - o) * (t - l) - (a - o) * (r - l) >= 0 &&
    (a - o) * (n - l) - (e - o) * (t - l) >= 0 &&
    (e - o) * (r - l) - (i - o) * (n - l) >= 0
  );
}
function sD(a, t) {
  return (
    a.next.i !== t.i &&
    a.prev.i !== t.i &&
    !oD(a, t) &&
    ((zl(a, t) &&
      zl(t, a) &&
      aD(a, t) &&
      (Ze(a.prev, a, t.prev) || Ze(a, t.prev, t))) ||
      ($u(a, t) && Ze(a.prev, a, a.next) > 0 && Ze(t.prev, t, t.next) > 0))
  );
}
function Ze(a, t, e) {
  return (t.y - a.y) * (e.x - t.x) - (t.x - a.x) * (e.y - t.y);
}
function $u(a, t) {
  return a.x === t.x && a.y === t.y;
}
function oy(a, t, e, n) {
  const i = Qu(Ze(a, t, e)),
    r = Qu(Ze(a, t, n)),
    o = Qu(Ze(e, n, a)),
    l = Qu(Ze(e, n, t));
  return !!(
    (i !== r && o !== l) ||
    (i === 0 && Ku(a, e, t)) ||
    (r === 0 && Ku(a, n, t)) ||
    (o === 0 && Ku(e, a, n)) ||
    (l === 0 && Ku(e, t, n))
  );
}
function Ku(a, t, e) {
  return (
    t.x <= Math.max(a.x, e.x) &&
    t.x >= Math.min(a.x, e.x) &&
    t.y <= Math.max(a.y, e.y) &&
    t.y >= Math.min(a.y, e.y)
  );
}
function Qu(a) {
  return a > 0 ? 1 : a < 0 ? -1 : 0;
}
function oD(a, t) {
  let e = a;
  do {
    if (
      e.i !== a.i &&
      e.next.i !== a.i &&
      e.i !== t.i &&
      e.next.i !== t.i &&
      oy(e, e.next, a, t)
    )
      return !0;
    e = e.next;
  } while (e !== a);
  return !1;
}
function zl(a, t) {
  return Ze(a.prev, a, a.next) < 0
    ? Ze(a, t, a.next) >= 0 && Ze(a, a.prev, t) >= 0
    : Ze(a, t, a.prev) < 0 || Ze(a, a.next, t) < 0;
}
function aD(a, t) {
  let e = a,
    n = !1;
  const i = (a.x + t.x) / 2,
    r = (a.y + t.y) / 2;
  do
    e.y > r != e.next.y > r &&
      e.next.y !== e.y &&
      i < ((e.next.x - e.x) * (r - e.y)) / (e.next.y - e.y) + e.x &&
      (n = !n),
      (e = e.next);
  while (e !== a);
  return n;
}
function ay(a, t) {
  const e = new Tp(a.i, a.x, a.y),
    n = new Tp(t.i, t.x, t.y),
    i = a.next,
    r = t.prev;
  return (
    (a.next = t),
    (t.prev = a),
    (e.next = i),
    (i.prev = e),
    (n.next = e),
    (e.prev = n),
    (r.next = n),
    (n.prev = r),
    n
  );
}
function ly(a, t, e, n) {
  const i = new Tp(a, t, e);
  return (
    n
      ? ((i.next = n.next), (i.prev = n), (n.next.prev = i), (n.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function Ul(a) {
  (a.next.prev = a.prev),
    (a.prev.next = a.next),
    a.prevZ && (a.prevZ.nextZ = a.nextZ),
    a.nextZ && (a.nextZ.prevZ = a.prevZ);
}
function Tp(a, t, e) {
  (this.i = a),
    (this.x = t),
    (this.y = e),
    (this.prev = null),
    (this.next = null),
    (this.z = null),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function lD(a, t, e, n) {
  let i = 0;
  for (let r = t, o = e - n; r < e; r += n)
    (i += (a[o] - a[r]) * (a[r + 1] + a[o + 1])), (o = r);
  return i;
}
class Ms {
  static area(t) {
    const e = t.length;
    let n = 0;
    for (let i = e - 1, r = 0; r < e; i = r++)
      n += t[i].x * t[r].y - t[r].x * t[i].y;
    return n * 0.5;
  }
  static isClockWise(t) {
    return Ms.area(t) < 0;
  }
  static triangulateShape(t, e) {
    const n = [],
      i = [],
      r = [];
    cy(t), uy(n, t);
    let o = t.length;
    e.forEach(cy);
    for (let u = 0; u < e.length; u++)
      i.push(o), (o += e[u].length), uy(n, e[u]);
    const l = YI.triangulate(n, i);
    for (let u = 0; u < l.length; u += 3) r.push(l.slice(u, u + 3));
    return r;
  }
}
function cy(a) {
  const t = a.length;
  t > 2 && a[t - 1].equals(a[0]) && a.pop();
}
function uy(a, t) {
  for (let e = 0; e < t.length; e++) a.push(t[e].x), a.push(t[e].y);
}
class Ea extends Ge {
  constructor(
    t = new Nl([
      new Et(0.5, 0.5),
      new Et(-0.5, 0.5),
      new Et(-0.5, -0.5),
      new Et(0.5, -0.5),
    ]),
    e = {}
  ) {
    super();
    (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: t, options: e }),
      (t = Array.isArray(t) ? t : [t]);
    const n = this,
      i = [],
      r = [];
    for (let l = 0, u = t.length; l < u; l++) {
      const h = t[l];
      o(h);
    }
    this.setAttribute("position", new en(i, 3)),
      this.setAttribute("uv", new en(r, 2)),
      this.computeVertexNormals();
    function o(l) {
      const u = [],
        h = e.curveSegments !== void 0 ? e.curveSegments : 12,
        f = e.steps !== void 0 ? e.steps : 1;
      let m = e.depth !== void 0 ? e.depth : 1,
        g = e.bevelEnabled !== void 0 ? e.bevelEnabled : !0,
        p = e.bevelThickness !== void 0 ? e.bevelThickness : 0.2,
        v = e.bevelSize !== void 0 ? e.bevelSize : p - 0.1,
        x = e.bevelOffset !== void 0 ? e.bevelOffset : 0,
        b = e.bevelSegments !== void 0 ? e.bevelSegments : 3;
      const _ = e.extrudePath,
        y = e.UVGenerator !== void 0 ? e.UVGenerator : cD;
      e.amount !== void 0 &&
        (console.warn(
          "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
        ),
        (m = e.amount));
      let E,
        M = !1,
        A,
        R,
        T,
        B;
      _ &&
        ((E = _.getSpacedPoints(f)),
        (M = !0),
        (g = !1),
        (A = _.computeFrenetFrames(f, !1)),
        (R = new k()),
        (T = new k()),
        (B = new k())),
        g || ((b = 0), (p = 0), (v = 0), (x = 0));
      const X = l.extractPoints(h);
      let H = X.shape;
      const O = X.holes;
      if (!Ms.isClockWise(H)) {
        H = H.reverse();
        for (let j = 0, ot = O.length; j < ot; j++) {
          const ct = O[j];
          Ms.isClockWise(ct) && (O[j] = ct.reverse());
        }
      }
      const W = Ms.triangulateShape(H, O),
        q = H;
      for (let j = 0, ot = O.length; j < ot; j++) {
        const ct = O[j];
        H = H.concat(ct);
      }
      function tt(j, ot, ct) {
        return (
          ot || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          ot.clone().multiplyScalar(ct).add(j)
        );
      }
      const V = H.length,
        Q = W.length;
      function st(j, ot, ct) {
        let St, xt, I;
        const P = j.x - ot.x,
          lt = j.y - ot.y,
          yt = ct.x - j.x,
          wt = ct.y - j.y,
          At = P * P + lt * lt,
          Ht = P * wt - lt * yt;
        if (Math.abs(Ht) > Number.EPSILON) {
          const Ut = Math.sqrt(At),
            Vt = Math.sqrt(yt * yt + wt * wt),
            Nt = ot.x - lt / Ut,
            Y = ot.y + P / Ut,
            Ct = ct.x - wt / Vt,
            _t = ct.y + yt / Vt,
            Bt = ((Ct - Nt) * wt - (_t - Y) * yt) / (P * wt - lt * yt);
          (St = Nt + P * Bt - j.x), (xt = Y + lt * Bt - j.y);
          const Ft = St * St + xt * xt;
          if (Ft <= 2) return new Et(St, xt);
          I = Math.sqrt(Ft / 2);
        } else {
          let Ut = !1;
          P > Number.EPSILON
            ? yt > Number.EPSILON && (Ut = !0)
            : P < -Number.EPSILON
            ? yt < -Number.EPSILON && (Ut = !0)
            : Math.sign(lt) === Math.sign(wt) && (Ut = !0),
            Ut
              ? ((St = -lt), (xt = P), (I = Math.sqrt(At)))
              : ((St = P), (xt = lt), (I = Math.sqrt(At / 2)));
        }
        return new Et(St / I, xt / I);
      }
      const Lt = [];
      for (
        let j = 0, ot = q.length, ct = ot - 1, St = j + 1;
        j < ot;
        j++, ct++, St++
      )
        ct === ot && (ct = 0),
          St === ot && (St = 0),
          (Lt[j] = st(q[j], q[ct], q[St]));
      const J = [];
      let vt,
        zt = Lt.concat();
      for (let j = 0, ot = O.length; j < ot; j++) {
        const ct = O[j];
        vt = [];
        for (
          let St = 0, xt = ct.length, I = xt - 1, P = St + 1;
          St < xt;
          St++, I++, P++
        )
          I === xt && (I = 0),
            P === xt && (P = 0),
            (vt[St] = st(ct[St], ct[I], ct[P]));
        J.push(vt), (zt = zt.concat(vt));
      }
      for (let j = 0; j < b; j++) {
        const ot = j / b,
          ct = p * Math.cos((ot * Math.PI) / 2),
          St = v * Math.sin((ot * Math.PI) / 2) + x;
        for (let xt = 0, I = q.length; xt < I; xt++) {
          const P = tt(q[xt], Lt[xt], St);
          F(P.x, P.y, -ct);
        }
        for (let xt = 0, I = O.length; xt < I; xt++) {
          const P = O[xt];
          vt = J[xt];
          for (let lt = 0, yt = P.length; lt < yt; lt++) {
            const wt = tt(P[lt], vt[lt], St);
            F(wt.x, wt.y, -ct);
          }
        }
      }
      const ft = v + x;
      for (let j = 0; j < V; j++) {
        const ot = g ? tt(H[j], zt[j], ft) : H[j];
        M
          ? (T.copy(A.normals[0]).multiplyScalar(ot.x),
            R.copy(A.binormals[0]).multiplyScalar(ot.y),
            B.copy(E[0]).add(T).add(R),
            F(B.x, B.y, B.z))
          : F(ot.x, ot.y, 0);
      }
      for (let j = 1; j <= f; j++)
        for (let ot = 0; ot < V; ot++) {
          const ct = g ? tt(H[ot], zt[ot], ft) : H[ot];
          M
            ? (T.copy(A.normals[j]).multiplyScalar(ct.x),
              R.copy(A.binormals[j]).multiplyScalar(ct.y),
              B.copy(E[j]).add(T).add(R),
              F(B.x, B.y, B.z))
            : F(ct.x, ct.y, (m / f) * j);
        }
      for (let j = b - 1; j >= 0; j--) {
        const ot = j / b,
          ct = p * Math.cos((ot * Math.PI) / 2),
          St = v * Math.sin((ot * Math.PI) / 2) + x;
        for (let xt = 0, I = q.length; xt < I; xt++) {
          const P = tt(q[xt], Lt[xt], St);
          F(P.x, P.y, m + ct);
        }
        for (let xt = 0, I = O.length; xt < I; xt++) {
          const P = O[xt];
          vt = J[xt];
          for (let lt = 0, yt = P.length; lt < yt; lt++) {
            const wt = tt(P[lt], vt[lt], St);
            M
              ? F(wt.x, wt.y + E[f - 1].y, E[f - 1].x + ct)
              : F(wt.x, wt.y, m + ct);
          }
        }
      }
      Mt(), Tt();
      function Mt() {
        const j = i.length / 3;
        if (g) {
          let ot = 0,
            ct = V * ot;
          for (let St = 0; St < Q; St++) {
            const xt = W[St];
            U(xt[2] + ct, xt[1] + ct, xt[0] + ct);
          }
          (ot = f + b * 2), (ct = V * ot);
          for (let St = 0; St < Q; St++) {
            const xt = W[St];
            U(xt[0] + ct, xt[1] + ct, xt[2] + ct);
          }
        } else {
          for (let ot = 0; ot < Q; ot++) {
            const ct = W[ot];
            U(ct[2], ct[1], ct[0]);
          }
          for (let ot = 0; ot < Q; ot++) {
            const ct = W[ot];
            U(ct[0] + V * f, ct[1] + V * f, ct[2] + V * f);
          }
        }
        n.addGroup(j, i.length / 3 - j, 0);
      }
      function Tt() {
        const j = i.length / 3;
        let ot = 0;
        z(q, ot), (ot += q.length);
        for (let ct = 0, St = O.length; ct < St; ct++) {
          const xt = O[ct];
          z(xt, ot), (ot += xt.length);
        }
        n.addGroup(j, i.length / 3 - j, 1);
      }
      function z(j, ot) {
        let ct = j.length;
        for (; --ct >= 0; ) {
          const St = ct;
          let xt = ct - 1;
          xt < 0 && (xt = j.length - 1);
          for (let I = 0, P = f + b * 2; I < P; I++) {
            const lt = V * I,
              yt = V * (I + 1),
              wt = ot + St + lt,
              At = ot + xt + lt,
              Ht = ot + xt + yt,
              Ut = ot + St + yt;
            et(wt, At, Ht, Ut);
          }
        }
      }
      function F(j, ot, ct) {
        u.push(j), u.push(ot), u.push(ct);
      }
      function U(j, ot, ct) {
        dt(j), dt(ot), dt(ct);
        const St = i.length / 3,
          xt = y.generateTopUV(n, i, St - 3, St - 2, St - 1);
        gt(xt[0]), gt(xt[1]), gt(xt[2]);
      }
      function et(j, ot, ct, St) {
        dt(j), dt(ot), dt(St), dt(ot), dt(ct), dt(St);
        const xt = i.length / 3,
          I = y.generateSideWallUV(n, i, xt - 6, xt - 3, xt - 2, xt - 1);
        gt(I[0]), gt(I[1]), gt(I[3]), gt(I[1]), gt(I[2]), gt(I[3]);
      }
      function dt(j) {
        i.push(u[j * 3 + 0]), i.push(u[j * 3 + 1]), i.push(u[j * 3 + 2]);
      }
      function gt(j) {
        r.push(j.x), r.push(j.y);
      }
    }
  }
  toJSON() {
    const t = super.toJSON(),
      e = this.parameters.shapes,
      n = this.parameters.options;
    return uD(e, n, t);
  }
  static fromJSON(t, e) {
    const n = [];
    for (let r = 0, o = t.shapes.length; r < o; r++) {
      const l = e[t.shapes[r]];
      n.push(l);
    }
    const i = t.options.extrudePath;
    return (
      i !== void 0 && (t.options.extrudePath = new ry[i.type]().fromJSON(i)),
      new Ea(n, t.options)
    );
  }
}
const cD = {
  generateTopUV: function (a, t, e, n, i) {
    const r = t[e * 3],
      o = t[e * 3 + 1],
      l = t[n * 3],
      u = t[n * 3 + 1],
      h = t[i * 3],
      f = t[i * 3 + 1];
    return [new Et(r, o), new Et(l, u), new Et(h, f)];
  },
  generateSideWallUV: function (a, t, e, n, i, r) {
    const o = t[e * 3],
      l = t[e * 3 + 1],
      u = t[e * 3 + 2],
      h = t[n * 3],
      f = t[n * 3 + 1],
      m = t[n * 3 + 2],
      g = t[i * 3],
      p = t[i * 3 + 1],
      v = t[i * 3 + 2],
      x = t[r * 3],
      b = t[r * 3 + 1],
      _ = t[r * 3 + 2];
    return Math.abs(l - f) < Math.abs(o - h)
      ? [new Et(o, 1 - u), new Et(h, 1 - m), new Et(g, 1 - v), new Et(x, 1 - _)]
      : [
          new Et(l, 1 - u),
          new Et(f, 1 - m),
          new Et(p, 1 - v),
          new Et(b, 1 - _),
        ];
  },
};
function uD(a, t, e) {
  if (((e.shapes = []), Array.isArray(a)))
    for (let n = 0, i = a.length; n < i; n++) {
      const r = a[n];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(a.uuid);
  return (
    t.extrudePath !== void 0 &&
      (e.options.extrudePath = t.extrudePath.toJSON()),
    e
  );
}
class Ep extends Ge {
  constructor(
    t = new Nl([new Et(0, 0.5), new Et(-0.5, -0.5), new Et(0.5, -0.5)]),
    e = 12
  ) {
    super();
    (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: t, curveSegments: e });
    const n = [],
      i = [],
      r = [],
      o = [];
    let l = 0,
      u = 0;
    if (Array.isArray(t) === !1) h(t);
    else
      for (let f = 0; f < t.length; f++)
        h(t[f]), this.addGroup(l, u, f), (l += u), (u = 0);
    this.setIndex(n),
      this.setAttribute("position", new en(i, 3)),
      this.setAttribute("normal", new en(r, 3)),
      this.setAttribute("uv", new en(o, 2));
    function h(f) {
      const m = i.length / 3,
        g = f.extractPoints(e);
      let p = g.shape;
      const v = g.holes;
      Ms.isClockWise(p) === !1 && (p = p.reverse());
      for (let b = 0, _ = v.length; b < _; b++) {
        const y = v[b];
        Ms.isClockWise(y) === !0 && (v[b] = y.reverse());
      }
      const x = Ms.triangulateShape(p, v);
      for (let b = 0, _ = v.length; b < _; b++) {
        const y = v[b];
        p = p.concat(y);
      }
      for (let b = 0, _ = p.length; b < _; b++) {
        const y = p[b];
        i.push(y.x, y.y, 0), r.push(0, 0, 1), o.push(y.x, y.y);
      }
      for (let b = 0, _ = x.length; b < _; b++) {
        const y = x[b],
          E = y[0] + m,
          M = y[1] + m,
          A = y[2] + m;
        n.push(E, M, A), (u += 3);
      }
    }
  }
  toJSON() {
    const t = super.toJSON(),
      e = this.parameters.shapes;
    return hD(e, t);
  }
  static fromJSON(t, e) {
    const n = [];
    for (let i = 0, r = t.shapes.length; i < r; i++) {
      const o = e[t.shapes[i]];
      n.push(o);
    }
    return new Ep(n, t.curveSegments);
  }
}
function hD(a, t) {
  if (((t.shapes = []), Array.isArray(a)))
    for (let e = 0, n = a.length; e < n; e++) {
      const i = a[e];
      t.shapes.push(i.uuid);
    }
  else t.shapes.push(a.uuid);
  return t;
}
class hy extends Ge {
  constructor(
    t = 1,
    e = 32,
    n = 16,
    i = 0,
    r = Math.PI * 2,
    o = 0,
    l = Math.PI
  ) {
    super();
    (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: n,
        phiStart: i,
        phiLength: r,
        thetaStart: o,
        thetaLength: l,
      }),
      (e = Math.max(3, Math.floor(e))),
      (n = Math.max(2, Math.floor(n)));
    const u = Math.min(o + l, Math.PI);
    let h = 0;
    const f = [],
      m = new k(),
      g = new k(),
      p = [],
      v = [],
      x = [],
      b = [];
    for (let _ = 0; _ <= n; _++) {
      const y = [],
        E = _ / n;
      let M = 0;
      _ == 0 && o == 0
        ? (M = 0.5 / e)
        : _ == n && u == Math.PI && (M = -0.5 / e);
      for (let A = 0; A <= e; A++) {
        const R = A / e;
        (m.x = -t * Math.cos(i + R * r) * Math.sin(o + E * l)),
          (m.y = t * Math.cos(o + E * l)),
          (m.z = t * Math.sin(i + R * r) * Math.sin(o + E * l)),
          v.push(m.x, m.y, m.z),
          g.copy(m).normalize(),
          x.push(g.x, g.y, g.z),
          b.push(R + M, 1 - E),
          y.push(h++);
      }
      f.push(y);
    }
    for (let _ = 0; _ < n; _++)
      for (let y = 0; y < e; y++) {
        const E = f[_][y + 1],
          M = f[_][y],
          A = f[_ + 1][y],
          R = f[_ + 1][y + 1];
        (_ !== 0 || o > 0) && p.push(E, M, R),
          (_ !== n - 1 || u < Math.PI) && p.push(M, A, R);
      }
    this.setIndex(p),
      this.setAttribute("position", new en(v, 3)),
      this.setAttribute("normal", new en(x, 3)),
      this.setAttribute("uv", new en(b, 2));
  }
  static fromJSON(t) {
    return new hy(
      t.radius,
      t.widthSegments,
      t.heightSegments,
      t.phiStart,
      t.phiLength,
      t.thetaStart,
      t.thetaLength
    );
  }
}
class fD extends Rn {
  constructor(t) {
    super();
    (this.type = "ShadowMaterial"),
      (this.color = new Xt(0)),
      (this.transparent = !0),
      this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this;
  }
}
fD.prototype.isShadowMaterial = !0;
class fy extends Rn {
  constructor(t) {
    super();
    (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Xt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Xt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Qo),
      (this.normalScale = new Et(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { STANDARD: "" }),
      this.color.copy(t.color),
      (this.roughness = t.roughness),
      (this.metalness = t.metalness),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.roughnessMap = t.roughnessMap),
      (this.metalnessMap = t.metalnessMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.envMapIntensity = t.envMapIntensity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      this
    );
  }
}
fy.prototype.isMeshStandardMaterial = !0;
class dD extends fy {
  constructor(t) {
    super();
    (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Et(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return pi((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (e) {
          this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
        },
      }),
      (this.sheenColor = new Xt(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0.01),
      (this.thicknessMap = null),
      (this.attenuationDistance = 0),
      (this.attenuationColor = new Xt(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Xt(1, 1, 1)),
      (this.specularColorMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._transmission = 0),
      this.setValues(t);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(t) {
    this._sheen > 0 != t > 0 && this.version++, (this._sheen = t);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, (this._clearcoat = t);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, (this._transmission = t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = t.clearcoat),
      (this.clearcoatMap = t.clearcoatMap),
      (this.clearcoatRoughness = t.clearcoatRoughness),
      (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = t.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
      (this.ior = t.ior),
      (this.sheen = t.sheen),
      this.sheenColor.copy(t.sheenColor),
      (this.sheenColorMap = t.sheenColorMap),
      (this.sheenRoughness = t.sheenRoughness),
      (this.sheenRoughnessMap = t.sheenRoughnessMap),
      (this.transmission = t.transmission),
      (this.transmissionMap = t.transmissionMap),
      (this.thickness = t.thickness),
      (this.thicknessMap = t.thicknessMap),
      (this.attenuationDistance = t.attenuationDistance),
      this.attenuationColor.copy(t.attenuationColor),
      (this.specularIntensity = t.specularIntensity),
      (this.specularIntensityMap = t.specularIntensityMap),
      this.specularColor.copy(t.specularColor),
      (this.specularColorMap = t.specularColorMap),
      this
    );
  }
}
dD.prototype.isMeshPhysicalMaterial = !0;
class pD extends Rn {
  constructor(t) {
    super();
    (this.type = "MeshPhongMaterial"),
      (this.color = new Xt(16777215)),
      (this.specular = new Xt(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Xt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Qo),
      (this.normalScale = new Et(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = cu),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      this.specular.copy(t.specular),
      (this.shininess = t.shininess),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      (this.flatShading = t.flatShading),
      this
    );
  }
}
pD.prototype.isMeshPhongMaterial = !0;
class mD extends Rn {
  constructor(t) {
    super();
    (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Xt(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Xt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Qo),
      (this.normalScale = new Et(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.gradientMap = t.gradientMap),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.alphaMap = t.alphaMap),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      this
    );
  }
}
mD.prototype.isMeshToonMaterial = !0;
class gD extends Rn {
  constructor(t) {
    super();
    (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Qo),
      (this.normalScale = new Et(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.flatShading = !1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.flatShading = t.flatShading),
      this
    );
  }
}
gD.prototype.isMeshNormalMaterial = !0;
class _D extends Rn {
  constructor(t) {
    super();
    (this.type = "MeshLambertMaterial"),
      (this.color = new Xt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Xt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = cu),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.map = t.map),
      (this.lightMap = t.lightMap),
      (this.lightMapIntensity = t.lightMapIntensity),
      (this.aoMap = t.aoMap),
      (this.aoMapIntensity = t.aoMapIntensity),
      this.emissive.copy(t.emissive),
      (this.emissiveMap = t.emissiveMap),
      (this.emissiveIntensity = t.emissiveIntensity),
      (this.specularMap = t.specularMap),
      (this.alphaMap = t.alphaMap),
      (this.envMap = t.envMap),
      (this.combine = t.combine),
      (this.reflectivity = t.reflectivity),
      (this.refractionRatio = t.refractionRatio),
      (this.wireframe = t.wireframe),
      (this.wireframeLinewidth = t.wireframeLinewidth),
      (this.wireframeLinecap = t.wireframeLinecap),
      (this.wireframeLinejoin = t.wireframeLinejoin),
      this
    );
  }
}
_D.prototype.isMeshLambertMaterial = !0;
class vD extends Rn {
  constructor(t) {
    super();
    (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Xt(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Qo),
      (this.normalScale = new Et(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.defines = { MATCAP: "" }),
      this.color.copy(t.color),
      (this.matcap = t.matcap),
      (this.map = t.map),
      (this.bumpMap = t.bumpMap),
      (this.bumpScale = t.bumpScale),
      (this.normalMap = t.normalMap),
      (this.normalMapType = t.normalMapType),
      this.normalScale.copy(t.normalScale),
      (this.displacementMap = t.displacementMap),
      (this.displacementScale = t.displacementScale),
      (this.displacementBias = t.displacementBias),
      (this.alphaMap = t.alphaMap),
      (this.flatShading = t.flatShading),
      this
    );
  }
}
vD.prototype.isMeshMatcapMaterial = !0;
class xD extends Dl {
  constructor(t) {
    super();
    (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(t);
  }
  copy(t) {
    return (
      super.copy(t),
      (this.scale = t.scale),
      (this.dashSize = t.dashSize),
      (this.gapSize = t.gapSize),
      this
    );
  }
}
xD.prototype.isLineDashedMaterial = !0;
const Xe = {
  arraySlice: function (a, t, e) {
    return Xe.isTypedArray(a)
      ? new a.constructor(a.subarray(t, e !== void 0 ? e : a.length))
      : a.slice(t, e);
  },
  convertArray: function (a, t, e) {
    return !a || (!e && a.constructor === t)
      ? a
      : typeof t.BYTES_PER_ELEMENT == "number"
      ? new t(a)
      : Array.prototype.slice.call(a);
  },
  isTypedArray: function (a) {
    return ArrayBuffer.isView(a) && !(a instanceof DataView);
  },
  getKeyframeOrder: function (a) {
    function t(i, r) {
      return a[i] - a[r];
    }
    const e = a.length,
      n = new Array(e);
    for (let i = 0; i !== e; ++i) n[i] = i;
    return n.sort(t), n;
  },
  sortedArray: function (a, t, e) {
    const n = a.length,
      i = new a.constructor(n);
    for (let r = 0, o = 0; o !== n; ++r) {
      const l = e[r] * t;
      for (let u = 0; u !== t; ++u) i[o++] = a[l + u];
    }
    return i;
  },
  flattenJSON: function (a, t, e, n) {
    let i = 1,
      r = a[0];
    for (; r !== void 0 && r[n] === void 0; ) r = a[i++];
    if (r === void 0) return;
    let o = r[n];
    if (o !== void 0)
      if (Array.isArray(o))
        do
          (o = r[n]),
            o !== void 0 && (t.push(r.time), e.push.apply(e, o)),
            (r = a[i++]);
        while (r !== void 0);
      else if (o.toArray !== void 0)
        do
          (o = r[n]),
            o !== void 0 && (t.push(r.time), o.toArray(e, e.length)),
            (r = a[i++]);
        while (r !== void 0);
      else
        do
          (o = r[n]), o !== void 0 && (t.push(r.time), e.push(o)), (r = a[i++]);
        while (r !== void 0);
  },
  subclip: function (a, t, e, n, i = 30) {
    const r = a.clone();
    r.name = t;
    const o = [];
    for (let u = 0; u < r.tracks.length; ++u) {
      const h = r.tracks[u],
        f = h.getValueSize(),
        m = [],
        g = [];
      for (let p = 0; p < h.times.length; ++p) {
        const v = h.times[p] * i;
        if (!(v < e || v >= n)) {
          m.push(h.times[p]);
          for (let x = 0; x < f; ++x) g.push(h.values[p * f + x]);
        }
      }
      m.length !== 0 &&
        ((h.times = Xe.convertArray(m, h.times.constructor)),
        (h.values = Xe.convertArray(g, h.values.constructor)),
        o.push(h));
    }
    r.tracks = o;
    let l = 1 / 0;
    for (let u = 0; u < r.tracks.length; ++u)
      l > r.tracks[u].times[0] && (l = r.tracks[u].times[0]);
    for (let u = 0; u < r.tracks.length; ++u) r.tracks[u].shift(-1 * l);
    return r.resetDuration(), r;
  },
  makeClipAdditive: function (a, t = 0, e = a, n = 30) {
    n <= 0 && (n = 30);
    const i = e.tracks.length,
      r = t / n;
    for (let o = 0; o < i; ++o) {
      const l = e.tracks[o],
        u = l.ValueTypeName;
      if (u === "bool" || u === "string") continue;
      const h = a.tracks.find(function (_) {
        return _.name === l.name && _.ValueTypeName === u;
      });
      if (h === void 0) continue;
      let f = 0;
      const m = l.getValueSize();
      l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (f = m / 3);
      let g = 0;
      const p = h.getValueSize();
      h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (g = p / 3);
      const v = l.times.length - 1;
      let x;
      if (r <= l.times[0]) {
        const _ = f,
          y = m - f;
        x = Xe.arraySlice(l.values, _, y);
      } else if (r >= l.times[v]) {
        const _ = v * m + f,
          y = _ + m - f;
        x = Xe.arraySlice(l.values, _, y);
      } else {
        const _ = l.createInterpolant(),
          y = f,
          E = m - f;
        _.evaluate(r), (x = Xe.arraySlice(_.resultBuffer, y, E));
      }
      u === "quaternion" &&
        new Qn().fromArray(x).normalize().conjugate().toArray(x);
      const b = h.times.length;
      for (let _ = 0; _ < b; ++_) {
        const y = _ * p + g;
        if (u === "quaternion")
          Qn.multiplyQuaternionsFlat(h.values, y, x, 0, h.values, y);
        else {
          const E = p - g * 2;
          for (let M = 0; M < E; ++M) h.values[y + M] -= x[M];
        }
      }
    }
    return (a.blendMode = Tv), a;
  },
};
class Ss {
  constructor(t, e, n, i) {
    (this.parameterPositions = t),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new e.constructor(n)),
      (this.sampleValues = e),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(t) {
    const e = this.parameterPositions;
    let n = this._cachedIndex,
      i = e[n],
      r = e[n - 1];
    t: {
      e: {
        let o;
        n: {
          i: if (!(t < i)) {
            for (let l = n + 2; ; ) {
              if (i === void 0) {
                if (t < r) break i;
                return (
                  (n = e.length),
                  (this._cachedIndex = n),
                  this.afterEnd_(n - 1, t, r)
                );
              }
              if (n === l) break;
              if (((r = i), (i = e[++n]), t < i)) break e;
            }
            o = e.length;
            break n;
          }
          if (!(t >= r)) {
            const l = e[1];
            t < l && ((n = 2), (r = l));
            for (let u = n - 2; ; ) {
              if (r === void 0)
                return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
              if (n === u) break;
              if (((i = r), (r = e[--n - 1]), t >= r)) break e;
            }
            (o = n), (n = 0);
            break n;
          }
          break t;
        }
        for (; n < o; ) {
          const l = (n + o) >>> 1;
          t < e[l] ? (o = l) : (n = l + 1);
        }
        if (((i = e[n]), (r = e[n - 1]), r === void 0))
          return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
        if (i === void 0)
          return (
            (n = e.length), (this._cachedIndex = n), this.afterEnd_(n - 1, r, t)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, t, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(t) {
    const e = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      r = t * i;
    for (let o = 0; o !== i; ++o) e[o] = n[r + o];
    return e;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
Ss.prototype.beforeStart_ = Ss.prototype.copySampleValue_;
Ss.prototype.afterEnd_ = Ss.prototype.copySampleValue_;
class yD extends Ss {
  constructor(t, e, n, i) {
    super(t, e, n, i);
    (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: $o, endingEnd: $o });
  }
  intervalChanged_(t, e, n) {
    const i = this.parameterPositions;
    let r = t - 2,
      o = t + 1,
      l = i[r],
      u = i[o];
    if (l === void 0)
      switch (this.getSettings_().endingStart) {
        case Ko:
          (r = t), (l = 2 * e - n);
          break;
        case gu:
          (r = i.length - 2), (l = e + i[r] - i[r + 1]);
          break;
        default:
          (r = t), (l = n);
      }
    if (u === void 0)
      switch (this.getSettings_().endingEnd) {
        case Ko:
          (o = t), (u = 2 * n - e);
          break;
        case gu:
          (o = 1), (u = n + i[1] - i[0]);
          break;
        default:
          (o = t - 1), (u = e);
      }
    const h = (n - e) * 0.5,
      f = this.valueSize;
    (this._weightPrev = h / (e - l)),
      (this._weightNext = h / (u - n)),
      (this._offsetPrev = r * f),
      (this._offsetNext = o * f);
  }
  interpolate_(t, e, n, i) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      l = this.valueSize,
      u = t * l,
      h = u - l,
      f = this._offsetPrev,
      m = this._offsetNext,
      g = this._weightPrev,
      p = this._weightNext,
      v = (n - e) / (i - e),
      x = v * v,
      b = x * v,
      _ = -g * b + 2 * g * x - g * v,
      y = (1 + g) * b + (-1.5 - 2 * g) * x + (-0.5 + g) * v + 1,
      E = (-1 - p) * b + (1.5 + p) * x + 0.5 * v,
      M = p * b - p * x;
    for (let A = 0; A !== l; ++A)
      r[A] = _ * o[f + A] + y * o[h + A] + E * o[u + A] + M * o[m + A];
    return r;
  }
}
class dy extends Ss {
  constructor(t, e, n, i) {
    super(t, e, n, i);
  }
  interpolate_(t, e, n, i) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      l = this.valueSize,
      u = t * l,
      h = u - l,
      f = (n - e) / (i - e),
      m = 1 - f;
    for (let g = 0; g !== l; ++g) r[g] = o[h + g] * m + o[u + g] * f;
    return r;
  }
}
class wD extends Ss {
  constructor(t, e, n, i) {
    super(t, e, n, i);
  }
  interpolate_(t) {
    return this.copySampleValue_(t - 1);
  }
}
class cr {
  constructor(t, e, n, i) {
    if (t === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (e === void 0 || e.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    (this.name = t),
      (this.times = Xe.convertArray(e, this.TimeBufferType)),
      (this.values = Xe.convertArray(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(t) {
    const e = t.constructor;
    let n;
    if (e.toJSON !== this.toJSON) n = e.toJSON(t);
    else {
      n = {
        name: t.name,
        times: Xe.convertArray(t.times, Array),
        values: Xe.convertArray(t.values, Array),
      };
      const i = t.getInterpolation();
      i !== t.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = t.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(t) {
    return new wD(this.times, this.values, this.getValueSize(), t);
  }
  InterpolantFactoryMethodLinear(t) {
    return new dy(this.times, this.values, this.getValueSize(), t);
  }
  InterpolantFactoryMethodSmooth(t) {
    return new yD(this.times, this.values, this.getValueSize(), t);
  }
  setInterpolation(t) {
    let e;
    switch (t) {
      case pu:
        e = this.InterpolantFactoryMethodDiscrete;
        break;
      case mu:
        e = this.InterpolantFactoryMethodLinear;
        break;
      case yd:
        e = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (e === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (t !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return (this.createInterpolant = e), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return pu;
      case this.InterpolantFactoryMethodLinear:
        return mu;
      case this.InterpolantFactoryMethodSmooth:
        return yd;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(t) {
    if (t !== 0) {
      const e = this.times;
      for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
    }
    return this;
  }
  scale(t) {
    if (t !== 1) {
      const e = this.times;
      for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
    }
    return this;
  }
  trim(t, e) {
    const n = this.times,
      i = n.length;
    let r = 0,
      o = i - 1;
    for (; r !== i && n[r] < t; ) ++r;
    for (; o !== -1 && n[o] > e; ) --o;
    if ((++o, r !== 0 || o !== i)) {
      r >= o && ((o = Math.max(o, 1)), (r = o - 1));
      const l = this.getValueSize();
      (this.times = Xe.arraySlice(n, r, o)),
        (this.values = Xe.arraySlice(this.values, r * l, o * l));
    }
    return this;
  }
  validate() {
    let t = !0;
    const e = this.getValueSize();
    e - Math.floor(e) != 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (t = !1));
    const n = this.times,
      i = this.values,
      r = n.length;
    r === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
    let o = null;
    for (let l = 0; l !== r; l++) {
      const u = n[l];
      if (typeof u == "number" && isNaN(u)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          l,
          u
        ),
          (t = !1);
        break;
      }
      if (o !== null && o > u) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, l, u, o),
          (t = !1);
        break;
      }
      o = u;
    }
    if (i !== void 0 && Xe.isTypedArray(i))
      for (let l = 0, u = i.length; l !== u; ++l) {
        const h = i[l];
        if (isNaN(h)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            l,
            h
          ),
            (t = !1);
          break;
        }
      }
    return t;
  }
  optimize() {
    const t = Xe.arraySlice(this.times),
      e = Xe.arraySlice(this.values),
      n = this.getValueSize(),
      i = this.getInterpolation() === yd,
      r = t.length - 1;
    let o = 1;
    for (let l = 1; l < r; ++l) {
      let u = !1;
      const h = t[l],
        f = t[l + 1];
      if (h !== f && (l !== 1 || h !== t[0]))
        if (i) u = !0;
        else {
          const m = l * n,
            g = m - n,
            p = m + n;
          for (let v = 0; v !== n; ++v) {
            const x = e[m + v];
            if (x !== e[g + v] || x !== e[p + v]) {
              u = !0;
              break;
            }
          }
        }
      if (u) {
        if (l !== o) {
          t[o] = t[l];
          const m = l * n,
            g = o * n;
          for (let p = 0; p !== n; ++p) e[g + p] = e[m + p];
        }
        ++o;
      }
    }
    if (r > 0) {
      t[o] = t[r];
      for (let l = r * n, u = o * n, h = 0; h !== n; ++h) e[u + h] = e[l + h];
      ++o;
    }
    return (
      o !== t.length
        ? ((this.times = Xe.arraySlice(t, 0, o)),
          (this.values = Xe.arraySlice(e, 0, o * n)))
        : ((this.times = t), (this.values = e)),
      this
    );
  }
  clone() {
    const t = Xe.arraySlice(this.times, 0),
      e = Xe.arraySlice(this.values, 0),
      n = this.constructor,
      i = new n(this.name, t, e);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
cr.prototype.TimeBufferType = Float32Array;
cr.prototype.ValueBufferType = Float32Array;
cr.prototype.DefaultInterpolation = mu;
class Aa extends cr {}
Aa.prototype.ValueTypeName = "bool";
Aa.prototype.ValueBufferType = Array;
Aa.prototype.DefaultInterpolation = pu;
Aa.prototype.InterpolantFactoryMethodLinear = void 0;
Aa.prototype.InterpolantFactoryMethodSmooth = void 0;
class py extends cr {}
py.prototype.ValueTypeName = "color";
class th extends cr {}
th.prototype.ValueTypeName = "number";
class bD extends Ss {
  constructor(t, e, n, i) {
    super(t, e, n, i);
  }
  interpolate_(t, e, n, i) {
    const r = this.resultBuffer,
      o = this.sampleValues,
      l = this.valueSize,
      u = (n - e) / (i - e);
    let h = t * l;
    for (let f = h + l; h !== f; h += 4) Qn.slerpFlat(r, 0, o, h - l, o, h, u);
    return r;
  }
}
class kl extends cr {
  InterpolantFactoryMethodLinear(t) {
    return new bD(this.times, this.values, this.getValueSize(), t);
  }
}
kl.prototype.ValueTypeName = "quaternion";
kl.prototype.DefaultInterpolation = mu;
kl.prototype.InterpolantFactoryMethodSmooth = void 0;
class La extends cr {}
La.prototype.ValueTypeName = "string";
La.prototype.ValueBufferType = Array;
La.prototype.DefaultInterpolation = pu;
La.prototype.InterpolantFactoryMethodLinear = void 0;
La.prototype.InterpolantFactoryMethodSmooth = void 0;
class eh extends cr {}
eh.prototype.ValueTypeName = "vector";
class my {
  constructor(t, e = -1, n, i = wd) {
    (this.name = t),
      (this.tracks = n),
      (this.duration = e),
      (this.blendMode = i),
      (this.uuid = sr()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(t) {
    const e = [],
      n = t.tracks,
      i = 1 / (t.fps || 1);
    for (let o = 0, l = n.length; o !== l; ++o) e.push(SD(n[o]).scale(i));
    const r = new this(t.name, t.duration, e, t.blendMode);
    return (r.uuid = t.uuid), r;
  }
  static toJSON(t) {
    const e = [],
      n = t.tracks,
      i = {
        name: t.name,
        duration: t.duration,
        tracks: e,
        uuid: t.uuid,
        blendMode: t.blendMode,
      };
    for (let r = 0, o = n.length; r !== o; ++r) e.push(cr.toJSON(n[r]));
    return i;
  }
  static CreateFromMorphTargetSequence(t, e, n, i) {
    const r = e.length,
      o = [];
    for (let l = 0; l < r; l++) {
      let u = [],
        h = [];
      u.push((l + r - 1) % r, l, (l + 1) % r), h.push(0, 1, 0);
      const f = Xe.getKeyframeOrder(u);
      (u = Xe.sortedArray(u, 1, f)),
        (h = Xe.sortedArray(h, 1, f)),
        !i && u[0] === 0 && (u.push(r), h.push(h[0])),
        o.push(
          new th(".morphTargetInfluences[" + e[l].name + "]", u, h).scale(1 / n)
        );
    }
    return new this(t, -1, o);
  }
  static findByName(t, e) {
    let n = t;
    if (!Array.isArray(t)) {
      const i = t;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === e) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(t, e, n) {
    const i = {},
      r = /^([\w-]*?)([\d]+)$/;
    for (let l = 0, u = t.length; l < u; l++) {
      const h = t[l],
        f = h.name.match(r);
      if (f && f.length > 1) {
        const m = f[1];
        let g = i[m];
        g || (i[m] = g = []), g.push(h);
      }
    }
    const o = [];
    for (const l in i)
      o.push(this.CreateFromMorphTargetSequence(l, i[l], e, n));
    return o;
  }
  static parseAnimation(t, e) {
    if (!t)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const n = function (m, g, p, v, x) {
        if (p.length !== 0) {
          const b = [],
            _ = [];
          Xe.flattenJSON(p, b, _, v), b.length !== 0 && x.push(new m(g, b, _));
        }
      },
      i = [],
      r = t.name || "default",
      o = t.fps || 30,
      l = t.blendMode;
    let u = t.length || -1;
    const h = t.hierarchy || [];
    for (let m = 0; m < h.length; m++) {
      const g = h[m].keys;
      if (!(!g || g.length === 0))
        if (g[0].morphTargets) {
          const p = {};
          let v;
          for (v = 0; v < g.length; v++)
            if (g[v].morphTargets)
              for (let x = 0; x < g[v].morphTargets.length; x++)
                p[g[v].morphTargets[x]] = -1;
          for (const x in p) {
            const b = [],
              _ = [];
            for (let y = 0; y !== g[v].morphTargets.length; ++y) {
              const E = g[v];
              b.push(E.time), _.push(E.morphTarget === x ? 1 : 0);
            }
            i.push(new th(".morphTargetInfluence[" + x + "]", b, _));
          }
          u = p.length * (o || 1);
        } else {
          const p = ".bones[" + e[m].name + "]";
          n(eh, p + ".position", g, "pos", i),
            n(kl, p + ".quaternion", g, "rot", i),
            n(eh, p + ".scale", g, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(r, u, i, l);
  }
  resetDuration() {
    const t = this.tracks;
    let e = 0;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const r = this.tracks[n];
      e = Math.max(e, r.times[r.times.length - 1]);
    }
    return (this.duration = e), this;
  }
  trim() {
    for (let t = 0; t < this.tracks.length; t++)
      this.tracks[t].trim(0, this.duration);
    return this;
  }
  validate() {
    let t = !0;
    for (let e = 0; e < this.tracks.length; e++)
      t = t && this.tracks[e].validate();
    return t;
  }
  optimize() {
    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
    return this;
  }
  clone() {
    const t = [];
    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
    return new this.constructor(this.name, this.duration, t, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function MD(a) {
  switch (a.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return th;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return eh;
    case "color":
      return py;
    case "quaternion":
      return kl;
    case "bool":
    case "boolean":
      return Aa;
    case "string":
      return La;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
}
function SD(a) {
  if (a.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const t = MD(a.type);
  if (a.times === void 0) {
    const e = [],
      n = [];
    Xe.flattenJSON(a.keys, e, n, "value"), (a.times = e), (a.values = n);
  }
  return t.parse !== void 0
    ? t.parse(a)
    : new t(a.name, a.times, a.values, a.interpolation);
}
const Ca = {
  enabled: !1,
  files: {},
  add: function (a, t) {
    this.enabled !== !1 && (this.files[a] = t);
  },
  get: function (a) {
    if (this.enabled !== !1) return this.files[a];
  },
  remove: function (a) {
    delete this.files[a];
  },
  clear: function () {
    this.files = {};
  },
};
class TD {
  constructor(t, e, n) {
    const i = this;
    let r = !1,
      o = 0,
      l = 0,
      u;
    const h = [];
    (this.onStart = void 0),
      (this.onLoad = t),
      (this.onProgress = e),
      (this.onError = n),
      (this.itemStart = function (f) {
        l++, r === !1 && i.onStart !== void 0 && i.onStart(f, o, l), (r = !0);
      }),
      (this.itemEnd = function (f) {
        o++,
          i.onProgress !== void 0 && i.onProgress(f, o, l),
          o === l && ((r = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (f) {
        i.onError !== void 0 && i.onError(f);
      }),
      (this.resolveURL = function (f) {
        return u ? u(f) : f;
      }),
      (this.setURLModifier = function (f) {
        return (u = f), this;
      }),
      (this.addHandler = function (f, m) {
        return h.push(f, m), this;
      }),
      (this.removeHandler = function (f) {
        const m = h.indexOf(f);
        return m !== -1 && h.splice(m, 2), this;
      }),
      (this.getHandler = function (f) {
        for (let m = 0, g = h.length; m < g; m += 2) {
          const p = h[m],
            v = h[m + 1];
          if ((p.global && (p.lastIndex = 0), p.test(f))) return v;
        }
        return null;
      });
  }
}
const ED = new TD();
class Ts {
  constructor(t) {
    (this.manager = t !== void 0 ? t : ED),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(t, e) {
    const n = this;
    return new Promise(function (i, r) {
      n.load(t, i, e, r);
    });
  }
  parse() {}
  setCrossOrigin(t) {
    return (this.crossOrigin = t), this;
  }
  setWithCredentials(t) {
    return (this.withCredentials = t), this;
  }
  setPath(t) {
    return (this.path = t), this;
  }
  setResourcePath(t) {
    return (this.resourcePath = t), this;
  }
  setRequestHeader(t) {
    return (this.requestHeader = t), this;
  }
}
const zr = {};
class AD extends Ts {
  constructor(t) {
    super(t);
  }
  load(t, e, n, i) {
    t === void 0 && (t = ""),
      this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = Ca.get(t);
    if (r !== void 0)
      return (
        this.manager.itemStart(t),
        setTimeout(() => {
          e && e(r), this.manager.itemEnd(t);
        }, 0),
        r
      );
    if (zr[t] !== void 0) {
      zr[t].push({ onLoad: e, onProgress: n, onError: i });
      return;
    }
    (zr[t] = []), zr[t].push({ onLoad: e, onProgress: n, onError: i });
    const o = new Request(t, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin",
    });
    fetch(o)
      .then((l) => {
        if (l.status === 200 || l.status === 0) {
          l.status === 0 &&
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          const u = zr[t],
            h = l.body.getReader(),
            f = l.headers.get("Content-Length"),
            m = f ? parseInt(f) : 0,
            g = m !== 0;
          let p = 0;
          return new ReadableStream({
            start(v) {
              x();
              function x() {
                h.read().then(({ done: b, value: _ }) => {
                  if (b) v.close();
                  else {
                    p += _.byteLength;
                    const y = new ProgressEvent("progress", {
                      lengthComputable: g,
                      loaded: p,
                      total: m,
                    });
                    for (let E = 0, M = u.length; E < M; E++) {
                      const A = u[E];
                      A.onProgress && A.onProgress(y);
                    }
                    v.enqueue(_), x();
                  }
                });
              }
            },
          });
        } else
          throw Error(
            `fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`
          );
      })
      .then((l) => {
        const u = new Response(l);
        switch (this.responseType) {
          case "arraybuffer":
            return u.arrayBuffer();
          case "blob":
            return u.blob();
          case "document":
            return u
              .text()
              .then((h) => new DOMParser().parseFromString(h, this.mimeType));
          case "json":
            return u.json();
          default:
            return u.text();
        }
      })
      .then((l) => {
        Ca.add(t, l);
        const u = zr[t];
        delete zr[t];
        for (let h = 0, f = u.length; h < f; h++) {
          const m = u[h];
          m.onLoad && m.onLoad(l);
        }
        this.manager.itemEnd(t);
      })
      .catch((l) => {
        const u = zr[t];
        delete zr[t];
        for (let h = 0, f = u.length; h < f; h++) {
          const m = u[h];
          m.onError && m.onError(l);
        }
        this.manager.itemError(t), this.manager.itemEnd(t);
      }),
      this.manager.itemStart(t);
  }
  setResponseType(t) {
    return (this.responseType = t), this;
  }
  setMimeType(t) {
    return (this.mimeType = t), this;
  }
}
class gy extends Ts {
  constructor(t) {
    super(t);
  }
  load(t, e, n, i) {
    this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = this,
      o = Ca.get(t);
    if (o !== void 0)
      return (
        r.manager.itemStart(t),
        setTimeout(function () {
          e && e(o), r.manager.itemEnd(t);
        }, 0),
        o
      );
    const l = vu("img");
    function u() {
      f(), Ca.add(t, this), e && e(this), r.manager.itemEnd(t);
    }
    function h(m) {
      f(), i && i(m), r.manager.itemError(t), r.manager.itemEnd(t);
    }
    function f() {
      l.removeEventListener("load", u, !1),
        l.removeEventListener("error", h, !1);
    }
    return (
      l.addEventListener("load", u, !1),
      l.addEventListener("error", h, !1),
      t.substr(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (l.crossOrigin = this.crossOrigin),
      r.manager.itemStart(t),
      (l.src = t),
      l
    );
  }
}
class LD extends Ts {
  constructor(t) {
    super(t);
  }
  load(t, e, n, i) {
    const r = new Ou(),
      o = new gy(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let l = 0;
    function u(h) {
      o.load(
        t[h],
        function (f) {
          (r.images[h] = f), l++, l === 6 && ((r.needsUpdate = !0), e && e(r));
        },
        void 0,
        i
      );
    }
    for (let h = 0; h < t.length; ++h) u(h);
    return r;
  }
}
class CD extends Ts {
  constructor(t) {
    super(t);
  }
  load(t, e, n, i) {
    const r = new Sn(),
      o = new gy(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        t,
        function (l) {
          (r.image = l), (r.needsUpdate = !0), e !== void 0 && e(r);
        },
        n,
        i
      ),
      r
    );
  }
}
class ur extends Me {
  constructor(t, e = 1) {
    super();
    (this.type = "Light"), (this.color = new Xt(t)), (this.intensity = e);
  }
  dispose() {}
  copy(t) {
    return (
      super.copy(t),
      this.color.copy(t.color),
      (this.intensity = t.intensity),
      this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.object.color = this.color.getHex()),
      (e.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (e.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (e.object.distance = this.distance),
      this.angle !== void 0 && (e.object.angle = this.angle),
      this.decay !== void 0 && (e.object.decay = this.decay),
      this.penumbra !== void 0 && (e.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()),
      e
    );
  }
}
ur.prototype.isLight = !0;
class RD extends ur {
  constructor(t, e, n) {
    super(t, n);
    (this.type = "HemisphereLight"),
      this.position.copy(Me.DefaultUp),
      this.updateMatrix(),
      (this.groundColor = new Xt(e));
  }
  copy(t) {
    return (
      ur.prototype.copy.call(this, t),
      this.groundColor.copy(t.groundColor),
      this
    );
  }
}
RD.prototype.isHemisphereLight = !0;
const _y = new Jt(),
  vy = new k(),
  xy = new k();
class Ap {
  constructor(t) {
    (this.camera = t),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Et(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Jt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Bu()),
      (this._frameExtents = new Et(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Fe(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t) {
    const e = this.camera,
      n = this.matrix;
    vy.setFromMatrixPosition(t.matrixWorld),
      e.position.copy(vy),
      xy.setFromMatrixPosition(t.target.matrixWorld),
      e.lookAt(xy),
      e.updateMatrixWorld(),
      _y.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(_y),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(e.projectionMatrix),
      n.multiply(e.matrixWorldInverse);
  }
  getViewport(t) {
    return this._viewports[t];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t) {
    return (
      (this.camera = t.camera.clone()),
      (this.bias = t.bias),
      (this.radius = t.radius),
      this.mapSize.copy(t.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t = {};
    return (
      this.bias !== 0 && (t.bias = this.bias),
      this.normalBias !== 0 && (t.normalBias = this.normalBias),
      this.radius !== 1 && (t.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (t.mapSize = this.mapSize.toArray()),
      (t.camera = this.camera.toJSON(!1).object),
      delete t.camera.matrix,
      t
    );
  }
}
class yy extends Ap {
  constructor() {
    super(new ei(50, 1, 0.5, 500));
    this.focus = 1;
  }
  updateMatrices(t) {
    const e = this.camera,
      n = Ed * 2 * t.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      r = t.distance || e.far;
    (n !== e.fov || i !== e.aspect || r !== e.far) &&
      ((e.fov = n), (e.aspect = i), (e.far = r), e.updateProjectionMatrix()),
      super.updateMatrices(t);
  }
  copy(t) {
    return super.copy(t), (this.focus = t.focus), this;
  }
}
yy.prototype.isSpotLightShadow = !0;
class PD extends ur {
  constructor(t, e, n = 0, i = Math.PI / 3, r = 0, o = 1) {
    super(t, e);
    (this.type = "SpotLight"),
      this.position.copy(Me.DefaultUp),
      this.updateMatrix(),
      (this.target = new Me()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = r),
      (this.decay = o),
      (this.shadow = new yy());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(t) {
    this.intensity = t / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return (
      super.copy(t),
      (this.distance = t.distance),
      (this.angle = t.angle),
      (this.penumbra = t.penumbra),
      (this.decay = t.decay),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    );
  }
}
PD.prototype.isSpotLight = !0;
const wy = new Jt(),
  Gl = new k(),
  Lp = new k();
class by extends Ap {
  constructor() {
    super(new ei(90, 1, 0.5, 500));
    (this._frameExtents = new Et(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Fe(2, 1, 1, 1),
        new Fe(0, 1, 1, 1),
        new Fe(3, 1, 1, 1),
        new Fe(1, 1, 1, 1),
        new Fe(3, 0, 1, 1),
        new Fe(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new k(1, 0, 0),
        new k(-1, 0, 0),
        new k(0, 0, 1),
        new k(0, 0, -1),
        new k(0, 1, 0),
        new k(0, -1, 0),
      ]),
      (this._cubeUps = [
        new k(0, 1, 0),
        new k(0, 1, 0),
        new k(0, 1, 0),
        new k(0, 1, 0),
        new k(0, 0, 1),
        new k(0, 0, -1),
      ]);
  }
  updateMatrices(t, e = 0) {
    const n = this.camera,
      i = this.matrix,
      r = t.distance || n.far;
    r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
      Gl.setFromMatrixPosition(t.matrixWorld),
      n.position.copy(Gl),
      Lp.copy(n.position),
      Lp.add(this._cubeDirections[e]),
      n.up.copy(this._cubeUps[e]),
      n.lookAt(Lp),
      n.updateMatrixWorld(),
      i.makeTranslation(-Gl.x, -Gl.y, -Gl.z),
      wy.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(wy);
  }
}
by.prototype.isPointLightShadow = !0;
class ID extends ur {
  constructor(t, e, n = 0, i = 1) {
    super(t, e);
    (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new by());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(t) {
    this.intensity = t / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return (
      super.copy(t),
      (this.distance = t.distance),
      (this.decay = t.decay),
      (this.shadow = t.shadow.clone()),
      this
    );
  }
}
ID.prototype.isPointLight = !0;
class My extends Ap {
  constructor() {
    super(new ep(-5, 5, 5, -5, 0.5, 500));
  }
}
My.prototype.isDirectionalLightShadow = !0;
class DD extends ur {
  constructor(t, e) {
    super(t, e);
    (this.type = "DirectionalLight"),
      this.position.copy(Me.DefaultUp),
      this.updateMatrix(),
      (this.target = new Me()),
      (this.shadow = new My());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return (
      super.copy(t),
      (this.target = t.target.clone()),
      (this.shadow = t.shadow.clone()),
      this
    );
  }
}
DD.prototype.isDirectionalLight = !0;
class FD extends ur {
  constructor(t, e) {
    super(t, e);
    this.type = "AmbientLight";
  }
}
FD.prototype.isAmbientLight = !0;
class OD extends ur {
  constructor(t, e, n = 10, i = 10) {
    super(t, e);
    (this.type = "RectAreaLight"), (this.width = n), (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(t) {
    this.intensity = t / (this.width * this.height * Math.PI);
  }
  copy(t) {
    return (
      super.copy(t), (this.width = t.width), (this.height = t.height), this
    );
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (e.object.width = this.width), (e.object.height = this.height), e;
  }
}
OD.prototype.isRectAreaLight = !0;
class Sy {
  constructor() {
    this.coefficients = [];
    for (let t = 0; t < 9; t++) this.coefficients.push(new k());
  }
  set(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
    return this;
  }
  zero() {
    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
    return this;
  }
  getAt(t, e) {
    const n = t.x,
      i = t.y,
      r = t.z,
      o = this.coefficients;
    return (
      e.copy(o[0]).multiplyScalar(0.282095),
      e.addScaledVector(o[1], 0.488603 * i),
      e.addScaledVector(o[2], 0.488603 * r),
      e.addScaledVector(o[3], 0.488603 * n),
      e.addScaledVector(o[4], 1.092548 * (n * i)),
      e.addScaledVector(o[5], 1.092548 * (i * r)),
      e.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
      e.addScaledVector(o[7], 1.092548 * (n * r)),
      e.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
      e
    );
  }
  getIrradianceAt(t, e) {
    const n = t.x,
      i = t.y,
      r = t.z,
      o = this.coefficients;
    return (
      e.copy(o[0]).multiplyScalar(0.886227),
      e.addScaledVector(o[1], 2 * 0.511664 * i),
      e.addScaledVector(o[2], 2 * 0.511664 * r),
      e.addScaledVector(o[3], 2 * 0.511664 * n),
      e.addScaledVector(o[4], 2 * 0.429043 * n * i),
      e.addScaledVector(o[5], 2 * 0.429043 * i * r),
      e.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
      e.addScaledVector(o[7], 2 * 0.429043 * n * r),
      e.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
      e
    );
  }
  add(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
    return this;
  }
  addScaledSH(t, e) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(t.coefficients[n], e);
    return this;
  }
  scale(t) {
    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
    return this;
  }
  lerp(t, e) {
    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
    return this;
  }
  equals(t) {
    for (let e = 0; e < 9; e++)
      if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
    return !0;
  }
  copy(t) {
    return this.set(t.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(t, e = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].fromArray(t, e + i * 3);
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++) n[i].toArray(t, e + i * 3);
    return t;
  }
  static getBasisAt(t, e) {
    const n = t.x,
      i = t.y,
      r = t.z;
    (e[0] = 0.282095),
      (e[1] = 0.488603 * i),
      (e[2] = 0.488603 * r),
      (e[3] = 0.488603 * n),
      (e[4] = 1.092548 * n * i),
      (e[5] = 1.092548 * i * r),
      (e[6] = 0.315392 * (3 * r * r - 1)),
      (e[7] = 1.092548 * n * r),
      (e[8] = 0.546274 * (n * n - i * i));
  }
}
Sy.prototype.isSphericalHarmonics3 = !0;
class Cp extends ur {
  constructor(t = new Sy(), e = 1) {
    super(void 0, e);
    this.sh = t;
  }
  copy(t) {
    return super.copy(t), this.sh.copy(t.sh), this;
  }
  fromJSON(t) {
    return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (e.object.sh = this.sh.toArray()), e;
  }
}
Cp.prototype.isLightProbe = !0;
class ND {
  static decodeText(t) {
    if (typeof TextDecoder != "undefined") return new TextDecoder().decode(t);
    let e = "";
    for (let n = 0, i = t.length; n < i; n++) e += String.fromCharCode(t[n]);
    try {
      return decodeURIComponent(escape(e));
    } catch {
      return e;
    }
  }
  static extractUrlBase(t) {
    const e = t.lastIndexOf("/");
    return e === -1 ? "./" : t.substr(0, e + 1);
  }
  static resolveURL(t, e) {
    return typeof t != "string" || t === ""
      ? ""
      : (/^https?:\/\//i.test(e) &&
          /^\//.test(t) &&
          (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(t) ||
        /^data:.*,.*$/i.test(t) ||
        /^blob:.*$/i.test(t)
          ? t
          : e + t);
  }
}
class BD extends Ge {
  constructor() {
    super();
    (this.type = "InstancedBufferGeometry"), (this.instanceCount = 1 / 0);
  }
  copy(t) {
    return super.copy(t), (this.instanceCount = t.instanceCount), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t = super.toJSON(this);
    return (
      (t.instanceCount = this.instanceCount),
      (t.isInstancedBufferGeometry = !0),
      t
    );
  }
}
BD.prototype.isInstancedBufferGeometry = !0;
class zD extends Ts {
  constructor(t) {
    super(t);
    typeof createImageBitmap == "undefined" &&
      console.warn(
        "THREE.ImageBitmapLoader: createImageBitmap() not supported."
      ),
      typeof fetch == "undefined" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(t) {
    return (this.options = t), this;
  }
  load(t, e, n, i) {
    t === void 0 && (t = ""),
      this.path !== void 0 && (t = this.path + t),
      (t = this.manager.resolveURL(t));
    const r = this,
      o = Ca.get(t);
    if (o !== void 0)
      return (
        r.manager.itemStart(t),
        setTimeout(function () {
          e && e(o), r.manager.itemEnd(t);
        }, 0),
        o
      );
    const l = {};
    (l.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (l.headers = this.requestHeader),
      fetch(t, l)
        .then(function (u) {
          return u.blob();
        })
        .then(function (u) {
          return createImageBitmap(
            u,
            Object.assign(r.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (u) {
          Ca.add(t, u), e && e(u), r.manager.itemEnd(t);
        })
        .catch(function (u) {
          i && i(u), r.manager.itemError(t), r.manager.itemEnd(t);
        }),
      r.manager.itemStart(t);
  }
}
zD.prototype.isImageBitmapLoader = !0;
let nh;
const UD = {
  getContext: function () {
    return (
      nh === void 0 &&
        (nh = new (window.AudioContext || window.webkitAudioContext)()),
      nh
    );
  },
  setContext: function (a) {
    nh = a;
  },
};
class kD extends Ts {
  constructor(t) {
    super(t);
  }
  load(t, e, n, i) {
    const r = this,
      o = new AD(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        t,
        function (l) {
          try {
            const u = l.slice(0);
            UD.getContext().decodeAudioData(u, function (f) {
              e(f);
            });
          } catch (u) {
            i ? i(u) : console.error(u), r.manager.itemError(t);
          }
        },
        n,
        i
      );
  }
}
class GD extends Cp {
  constructor(t, e, n = 1) {
    super(void 0, n);
    const i = new Xt().set(t),
      r = new Xt().set(e),
      o = new k(i.r, i.g, i.b),
      l = new k(r.r, r.g, r.b),
      u = Math.sqrt(Math.PI),
      h = u * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(o).add(l).multiplyScalar(u),
      this.sh.coefficients[1].copy(o).sub(l).multiplyScalar(h);
  }
}
GD.prototype.isHemisphereLightProbe = !0;
class HD extends Cp {
  constructor(t, e = 1) {
    super(void 0, e);
    const n = new Xt().set(t);
    this.sh.coefficients[0]
      .set(n.r, n.g, n.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
HD.prototype.isAmbientLightProbe = !0;
class cF {
  constructor(t = !0) {
    (this.autoStart = t),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = Ty()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let t = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const e = Ty();
      (t = (e - this.oldTime) / 1e3),
        (this.oldTime = e),
        (this.elapsedTime += t);
    }
    return t;
  }
}
function Ty() {
  return (typeof performance == "undefined" ? Date : performance).now();
}
class VD extends Me {
  constructor(t) {
    super();
    (this.type = "Audio"),
      (this.listener = t),
      (this.context = t.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(t.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = t),
      this.connect(),
      this
    );
  }
  setMediaElementSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(t)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(t) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(t)),
      this.connect(),
      this
    );
  }
  setBuffer(t) {
    return (
      (this.buffer = t),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(t = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + t;
    const e = this.context.createBufferSource();
    return (
      (e.buffer = this.buffer),
      (e.loop = this.loop),
      (e.loopStart = this.loopStart),
      (e.loopEnd = this.loopEnd),
      (e.onended = this.onEnded.bind(this)),
      e.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = e),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source.stop(),
      (this.source.onended = null),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].connect(this.filters[t]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let t = 1, e = this.filters.length; t < e; t++)
        this.filters[t - 1].disconnect(this.filters[t]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return (this._connected = !1), this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(t) {
    return (
      t || (t = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = t.slice()), this.connect())
        : (this.filters = t.slice()),
      this
    );
  }
  setDetune(t) {
    if (((this.detune = t), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(t) {
    return this.setFilters(t ? [t] : []);
  }
  setPlaybackRate(t) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = t),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(t) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = t),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(t) {
    return (this.loopStart = t), this;
  }
  setLoopEnd(t) {
    return (this.loopEnd = t), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(t) {
    return (
      this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
    );
  }
}
class WD {
  constructor(t, e, n) {
    (this.binding = t), (this.valueSize = n);
    let i, r, o;
    switch (e) {
      case "quaternion":
        (i = this._slerp),
          (r = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(n * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (r = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(n * 5));
        break;
      default:
        (i = this._lerp),
          (r = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(n * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = r),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(t, e) {
    const n = this.buffer,
      i = this.valueSize,
      r = t * i + i;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let l = 0; l !== i; ++l) n[r + l] = n[l];
      o = e;
    } else {
      o += e;
      const l = e / o;
      this._mixBufferRegion(n, r, 0, l, i);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(t) {
    const e = this.buffer,
      n = this.valueSize,
      i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(e, i, 0, t, n),
      (this.cumulativeWeightAdditive += t);
  }
  apply(t) {
    const e = this.valueSize,
      n = this.buffer,
      i = t * e + e,
      r = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      l = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)
    ) {
      const u = e * this._origIndex;
      this._mixBufferRegion(n, i, u, 1 - r, e);
    }
    o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
    for (let u = e, h = e + e; u !== h; ++u)
      if (n[u] !== n[u + e]) {
        l.setValue(n, i);
        break;
      }
  }
  saveOriginalState() {
    const t = this.binding,
      e = this.buffer,
      n = this.valueSize,
      i = n * this._origIndex;
    t.getValue(e, i);
    for (let r = n, o = i; r !== o; ++r) e[r] = e[i + (r % n)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const t = this.valueSize * 3;
    this.binding.setValue(this.buffer, t);
  }
  _setAdditiveIdentityNumeric() {
    const t = this._addIndex * this.valueSize,
      e = t + this.valueSize;
    for (let n = t; n < e; n++) this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const t = this._origIndex * this.valueSize,
      e = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[e + n] = this.buffer[t + n];
  }
  _select(t, e, n, i, r) {
    if (i >= 0.5) for (let o = 0; o !== r; ++o) t[e + o] = t[n + o];
  }
  _slerp(t, e, n, i) {
    Qn.slerpFlat(t, e, t, e, t, n, i);
  }
  _slerpAdditive(t, e, n, i, r) {
    const o = this._workIndex * r;
    Qn.multiplyQuaternionsFlat(t, o, t, e, t, n),
      Qn.slerpFlat(t, e, t, e, t, o, i);
  }
  _lerp(t, e, n, i, r) {
    const o = 1 - i;
    for (let l = 0; l !== r; ++l) {
      const u = e + l;
      t[u] = t[u] * o + t[n + l] * i;
    }
  }
  _lerpAdditive(t, e, n, i, r) {
    for (let o = 0; o !== r; ++o) {
      const l = e + o;
      t[l] = t[l] + t[n + o] * i;
    }
  }
}
const Rp = "\\[\\]\\.:\\/",
  XD = new RegExp("[" + Rp + "]", "g"),
  Pp = "[^" + Rp + "]",
  YD = "[^" + Rp.replace("\\.", "") + "]",
  qD = /((?:WC+[\/:])*)/.source.replace("WC", Pp),
  ZD = /(WCOD+)?/.source.replace("WCOD", YD),
  jD = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Pp),
  JD = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Pp),
  $D = new RegExp("^" + qD + ZD + jD + JD + "$"),
  KD = ["material", "materials", "bones"];
class QD {
  constructor(t, e, n) {
    const i = n || Se.parseTrackName(e);
    (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
  }
  getValue(t, e) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(t, e);
  }
  setValue(t, e) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(t, e);
  }
  bind() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].bind();
  }
  unbind() {
    const t = this._bindings;
    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
      t[e].unbind();
  }
}
class Se {
  constructor(t, e, n) {
    (this.path = e),
      (this.parsedPath = n || Se.parseTrackName(e)),
      (this.node = Se.findNode(t, this.parsedPath.nodeName) || t),
      (this.rootNode = t),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(t, e, n) {
    return t && t.isAnimationObjectGroup
      ? new Se.Composite(t, e, n)
      : new Se(t, e, n);
  }
  static sanitizeNodeName(t) {
    return t.replace(/\s/g, "_").replace(XD, "");
  }
  static parseTrackName(t) {
    const e = $D.exec(t);
    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const n = {
        nodeName: e[2],
        objectName: e[3],
        objectIndex: e[4],
        propertyName: e[5],
        propertyIndex: e[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const r = n.nodeName.substring(i + 1);
      KD.indexOf(r) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + t
      );
    return n;
  }
  static findNode(t, e) {
    if (!e || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid)
      return t;
    if (t.skeleton) {
      const n = t.skeleton.getBoneByName(e);
      if (n !== void 0) return n;
    }
    if (t.children) {
      const n = function (r) {
          for (let o = 0; o < r.length; o++) {
            const l = r[o];
            if (l.name === e || l.uuid === e) return l;
            const u = n(l.children);
            if (u) return u;
          }
          return null;
        },
        i = n(t.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(t, e) {
    t[e] = this.targetObject[this.propertyName];
  }
  _getValue_array(t, e) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
  }
  _getValue_arrayElement(t, e) {
    t[e] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(t, e) {
    this.resolvedProperty.toArray(t, e);
  }
  _setValue_direct(t, e) {
    this.targetObject[this.propertyName] = t[e];
  }
  _setValue_direct_setNeedsUpdate(t, e) {
    (this.targetObject[this.propertyName] = t[e]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
    (this.targetObject[this.propertyName] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(t, e) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
  }
  _setValue_array_setNeedsUpdate(t, e) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(t, e) {
    this.resolvedProperty[this.propertyIndex] = t[e];
  }
  _setValue_arrayElement_setNeedsUpdate(t, e) {
    (this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
    (this.resolvedProperty[this.propertyIndex] = t[e]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(t, e) {
    this.resolvedProperty.fromArray(t, e);
  }
  _setValue_fromArray_setNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
    this.resolvedProperty.fromArray(t, e),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(t, e) {
    this.bind(), this.getValue(t, e);
  }
  _setValue_unbound(t, e) {
    this.bind(), this.setValue(t, e);
  }
  bind() {
    let t = this.node;
    const e = this.parsedPath,
      n = e.objectName,
      i = e.propertyName;
    let r = e.propertyIndex;
    if (
      (t ||
        ((t = Se.findNode(this.rootNode, e.nodeName) || this.rootNode),
        (this.node = t)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !t)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (n) {
      let h = e.objectIndex;
      switch (n) {
        case "materials":
          if (!t.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!t.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          t = t.skeleton.bones;
          for (let f = 0; f < t.length; f++)
            if (t[f].name === h) {
              h = f;
              break;
            }
          break;
        default:
          if (t[n] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          t = t[n];
      }
      if (h !== void 0) {
        if (t[h] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            t
          );
          return;
        }
        t = t[h];
      }
    }
    const o = t[i];
    if (o === void 0) {
      const h = e.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          h +
          "." +
          i +
          " but it wasn't found.",
        t
      );
      return;
    }
    let l = this.Versioning.None;
    (this.targetObject = t),
      t.needsUpdate !== void 0
        ? (l = this.Versioning.NeedsUpdate)
        : t.matrixWorldNeedsUpdate !== void 0 &&
          (l = this.Versioning.MatrixWorldNeedsUpdate);
    let u = this.BindingType.Direct;
    if (r !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!t.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (t.geometry.isBufferGeometry) {
          if (!t.geometry.morphAttributes) {
            console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            );
            return;
          }
          t.morphTargetDictionary[r] !== void 0 &&
            (r = t.morphTargetDictionary[r]);
        } else {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
            this
          );
          return;
        }
      }
      (u = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = r);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((u = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((u = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[u]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[u][l]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Se.Composite = QD;
Se.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Se.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Se.prototype.GetterByBindingType = [
  Se.prototype._getValue_direct,
  Se.prototype._getValue_array,
  Se.prototype._getValue_arrayElement,
  Se.prototype._getValue_toArray,
];
Se.prototype.SetterByBindingTypeAndVersioning = [
  [
    Se.prototype._setValue_direct,
    Se.prototype._setValue_direct_setNeedsUpdate,
    Se.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Se.prototype._setValue_array,
    Se.prototype._setValue_array_setNeedsUpdate,
    Se.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Se.prototype._setValue_arrayElement,
    Se.prototype._setValue_arrayElement_setNeedsUpdate,
    Se.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Se.prototype._setValue_fromArray,
    Se.prototype._setValue_fromArray_setNeedsUpdate,
    Se.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class tF {
  constructor(t, e, n = null, i = e.blendMode) {
    (this._mixer = t),
      (this._clip = e),
      (this._localRoot = n),
      (this.blendMode = i);
    const r = e.tracks,
      o = r.length,
      l = new Array(o),
      u = { endingStart: $o, endingEnd: $o };
    for (let h = 0; h !== o; ++h) {
      const f = r[h].createInterpolant(null);
      (l[h] = f), (f.settings = u);
    }
    (this._interpolantSettings = u),
      (this._interpolants = l),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = FC),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(t) {
    return (this._startTime = t), this;
  }
  setLoop(t, e) {
    return (this.loop = t), (this.repetitions = e), this;
  }
  setEffectiveWeight(t) {
    return (
      (this.weight = t),
      (this._effectiveWeight = this.enabled ? t : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(t) {
    return this._scheduleFading(t, 0, 1);
  }
  fadeOut(t) {
    return this._scheduleFading(t, 1, 0);
  }
  crossFadeFrom(t, e, n) {
    if ((t.fadeOut(e), this.fadeIn(e), n)) {
      const i = this._clip.duration,
        r = t._clip.duration,
        o = r / i,
        l = i / r;
      t.warp(1, o, e), this.warp(l, 1, e);
    }
    return this;
  }
  crossFadeTo(t, e, n) {
    return t.crossFadeFrom(this, e, n);
  }
  stopFading() {
    const t = this._weightInterpolant;
    return (
      t !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    );
  }
  setEffectiveTimeScale(t) {
    return (
      (this.timeScale = t),
      (this._effectiveTimeScale = this.paused ? 0 : t),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(t) {
    return (this.timeScale = this._clip.duration / t), this.stopWarping();
  }
  syncWith(t) {
    return (
      (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping()
    );
  }
  halt(t) {
    return this.warp(this._effectiveTimeScale, 0, t);
  }
  warp(t, e, n) {
    const i = this._mixer,
      r = i.time,
      o = this.timeScale;
    let l = this._timeScaleInterpolant;
    l === null &&
      ((l = i._lendControlInterpolant()), (this._timeScaleInterpolant = l));
    const u = l.parameterPositions,
      h = l.sampleValues;
    return (u[0] = r), (u[1] = r + n), (h[0] = t / o), (h[1] = e / o), this;
  }
  stopWarping() {
    const t = this._timeScaleInterpolant;
    return (
      t !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(t)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(t, e, n, i) {
    if (!this.enabled) {
      this._updateWeight(t);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const u = (t - r) * n;
      if (u < 0 || n === 0) return;
      (this._startTime = null), (e = n * u);
    }
    e *= this._updateTimeScale(t);
    const o = this._updateTime(e),
      l = this._updateWeight(t);
    if (l > 0) {
      const u = this._interpolants,
        h = this._propertyBindings;
      switch (this.blendMode) {
        case Tv:
          for (let f = 0, m = u.length; f !== m; ++f)
            u[f].evaluate(o), h[f].accumulateAdditive(l);
          break;
        case wd:
        default:
          for (let f = 0, m = u.length; f !== m; ++f)
            u[f].evaluate(o), h[f].accumulate(i, l);
      }
    }
  }
  _updateWeight(t) {
    let e = 0;
    if (this.enabled) {
      e = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(t)[0];
        (e *= i),
          t > n.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = e), e;
  }
  _updateTimeScale(t) {
    let e = 0;
    if (!this.paused) {
      e = this.timeScale;
      const n = this._timeScaleInterpolant;
      n !== null &&
        ((e *= n.evaluate(t)[0]),
        t > n.parameterPositions[1] &&
          (this.stopWarping(),
          e === 0 ? (this.paused = !0) : (this.timeScale = e)));
    }
    return (this._effectiveTimeScale = e), e;
  }
  _updateTime(t) {
    const e = this._clip.duration,
      n = this.loop;
    let i = this.time + t,
      r = this._loopCount;
    const o = n === OC;
    if (t === 0) return r === -1 ? i : o && (r & 1) == 1 ? e - i : i;
    if (n === DC) {
      r === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      t: {
        if (i >= e) i = e;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break t;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (r === -1 &&
          (t >= 0
            ? ((r = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        i >= e || i < 0)
      ) {
        const l = Math.floor(i / e);
        (i -= e * l), (r += Math.abs(l));
        const u = this.repetitions - r;
        if (u <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = t > 0 ? e : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: t > 0 ? 1 : -1,
            });
        else {
          if (u === 1) {
            const h = t < 0;
            this._setEndings(h, !h, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = r),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: l,
            });
        }
      } else this.time = i;
      if (o && (r & 1) == 1) return e - i;
    }
    return i;
  }
  _setEndings(t, e, n) {
    const i = this._interpolantSettings;
    n
      ? ((i.endingStart = Ko), (i.endingEnd = Ko))
      : (t
          ? (i.endingStart = this.zeroSlopeAtStart ? Ko : $o)
          : (i.endingStart = gu),
        e ? (i.endingEnd = this.zeroSlopeAtEnd ? Ko : $o) : (i.endingEnd = gu));
  }
  _scheduleFading(t, e, n) {
    const i = this._mixer,
      r = i.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
    const l = o.parameterPositions,
      u = o.sampleValues;
    return (l[0] = r), (u[0] = e), (l[1] = r + t), (u[1] = n), this;
  }
}
class eF extends $s {
  constructor(t) {
    super();
    (this._root = t),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(t, e) {
    const n = t._localRoot || this._root,
      i = t._clip.tracks,
      r = i.length,
      o = t._propertyBindings,
      l = t._interpolants,
      u = n.uuid,
      h = this._bindingsByRootAndName;
    let f = h[u];
    f === void 0 && ((f = {}), (h[u] = f));
    for (let m = 0; m !== r; ++m) {
      const g = i[m],
        p = g.name;
      let v = f[p];
      if (v !== void 0) o[m] = v;
      else {
        if (((v = o[m]), v !== void 0)) {
          v._cacheIndex === null &&
            (++v.referenceCount, this._addInactiveBinding(v, u, p));
          continue;
        }
        const x = e && e._propertyBindings[m].binding.parsedPath;
        (v = new WD(Se.create(n, p, x), g.ValueTypeName, g.getValueSize())),
          ++v.referenceCount,
          this._addInactiveBinding(v, u, p),
          (o[m] = v);
      }
      l[m].resultBuffer = v.buffer;
    }
  }
  _activateAction(t) {
    if (!this._isActiveAction(t)) {
      if (t._cacheIndex === null) {
        const n = (t._localRoot || this._root).uuid,
          i = t._clip.uuid,
          r = this._actionsByClip[i];
        this._bindAction(t, r && r.knownActions[0]),
          this._addInactiveAction(t, i, n);
      }
      const e = t._propertyBindings;
      for (let n = 0, i = e.length; n !== i; ++n) {
        const r = e[n];
        r.useCount++ == 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(t);
    }
  }
  _deactivateAction(t) {
    if (this._isActiveAction(t)) {
      const e = t._propertyBindings;
      for (let n = 0, i = e.length; n !== i; ++n) {
        const r = e[n];
        --r.useCount == 0 &&
          (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(t);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const t = this;
    this.stats = {
      actions: {
        get total() {
          return t._actions.length;
        },
        get inUse() {
          return t._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return t._bindings.length;
        },
        get inUse() {
          return t._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return t._controlInterpolants.length;
        },
        get inUse() {
          return t._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(t) {
    const e = t._cacheIndex;
    return e !== null && e < this._nActiveActions;
  }
  _addInactiveAction(t, e, n) {
    const i = this._actions,
      r = this._actionsByClip;
    let o = r[e];
    if (o === void 0)
      (o = { knownActions: [t], actionByRoot: {} }),
        (t._byClipCacheIndex = 0),
        (r[e] = o);
    else {
      const l = o.knownActions;
      (t._byClipCacheIndex = l.length), l.push(t);
    }
    (t._cacheIndex = i.length), i.push(t), (o.actionByRoot[n] = t);
  }
  _removeInactiveAction(t) {
    const e = this._actions,
      n = e[e.length - 1],
      i = t._cacheIndex;
    (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
    const r = t._clip.uuid,
      o = this._actionsByClip,
      l = o[r],
      u = l.knownActions,
      h = u[u.length - 1],
      f = t._byClipCacheIndex;
    (h._byClipCacheIndex = f),
      (u[f] = h),
      u.pop(),
      (t._byClipCacheIndex = null);
    const m = l.actionByRoot,
      g = (t._localRoot || this._root).uuid;
    delete m[g],
      u.length === 0 && delete o[r],
      this._removeInactiveBindingsForAction(t);
  }
  _removeInactiveBindingsForAction(t) {
    const e = t._propertyBindings;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const r = e[n];
      --r.referenceCount == 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(t) {
    const e = this._actions,
      n = t._cacheIndex,
      i = this._nActiveActions++,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  }
  _takeBackAction(t) {
    const e = this._actions,
      n = t._cacheIndex,
      i = --this._nActiveActions,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  }
  _addInactiveBinding(t, e, n) {
    const i = this._bindingsByRootAndName,
      r = this._bindings;
    let o = i[e];
    o === void 0 && ((o = {}), (i[e] = o)),
      (o[n] = t),
      (t._cacheIndex = r.length),
      r.push(t);
  }
  _removeInactiveBinding(t) {
    const e = this._bindings,
      n = t.binding,
      i = n.rootNode.uuid,
      r = n.path,
      o = this._bindingsByRootAndName,
      l = o[i],
      u = e[e.length - 1],
      h = t._cacheIndex;
    (u._cacheIndex = h),
      (e[h] = u),
      e.pop(),
      delete l[r],
      Object.keys(l).length === 0 && delete o[i];
  }
  _lendBinding(t) {
    const e = this._bindings,
      n = t._cacheIndex,
      i = this._nActiveBindings++,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  }
  _takeBackBinding(t) {
    const e = this._bindings,
      n = t._cacheIndex,
      i = --this._nActiveBindings,
      r = e[i];
    (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
  }
  _lendControlInterpolant() {
    const t = this._controlInterpolants,
      e = this._nActiveControlInterpolants++;
    let n = t[e];
    return (
      n === void 0 &&
        ((n = new dy(
          new Float32Array(2),
          new Float32Array(2),
          1,
          this._controlInterpolantsResultBuffer
        )),
        (n.__cacheIndex = e),
        (t[e] = n)),
      n
    );
  }
  _takeBackControlInterpolant(t) {
    const e = this._controlInterpolants,
      n = t.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      r = e[i];
    (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
  }
  clipAction(t, e, n) {
    const i = e || this._root,
      r = i.uuid;
    let o = typeof t == "string" ? my.findByName(i, t) : t;
    const l = o !== null ? o.uuid : t,
      u = this._actionsByClip[l];
    let h = null;
    if (
      (n === void 0 && (o !== null ? (n = o.blendMode) : (n = wd)),
      u !== void 0)
    ) {
      const m = u.actionByRoot[r];
      if (m !== void 0 && m.blendMode === n) return m;
      (h = u.knownActions[0]), o === null && (o = h._clip);
    }
    if (o === null) return null;
    const f = new tF(this, o, e, n);
    return this._bindAction(f, h), this._addInactiveAction(f, l, r), f;
  }
  existingAction(t, e) {
    const n = e || this._root,
      i = n.uuid,
      r = typeof t == "string" ? my.findByName(n, t) : t,
      o = r ? r.uuid : t,
      l = this._actionsByClip[o];
    return (l !== void 0 && l.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const t = this._actions,
      e = this._nActiveActions;
    for (let n = e - 1; n >= 0; --n) t[n].stop();
    return this;
  }
  update(t) {
    t *= this.timeScale;
    const e = this._actions,
      n = this._nActiveActions,
      i = (this.time += t),
      r = Math.sign(t),
      o = (this._accuIndex ^= 1);
    for (let h = 0; h !== n; ++h) e[h]._update(i, t, r, o);
    const l = this._bindings,
      u = this._nActiveBindings;
    for (let h = 0; h !== u; ++h) l[h].apply(o);
    return this;
  }
  setTime(t) {
    this.time = 0;
    for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
    return this.update(t);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(t) {
    const e = this._actions,
      n = t.uuid,
      i = this._actionsByClip,
      r = i[n];
    if (r !== void 0) {
      const o = r.knownActions;
      for (let l = 0, u = o.length; l !== u; ++l) {
        const h = o[l];
        this._deactivateAction(h);
        const f = h._cacheIndex,
          m = e[e.length - 1];
        (h._cacheIndex = null),
          (h._byClipCacheIndex = null),
          (m._cacheIndex = f),
          (e[f] = m),
          e.pop(),
          this._removeInactiveBindingsForAction(h);
      }
      delete i[n];
    }
  }
  uncacheRoot(t) {
    const e = t.uuid,
      n = this._actionsByClip;
    for (const o in n) {
      const l = n[o].actionByRoot,
        u = l[e];
      u !== void 0 &&
        (this._deactivateAction(u), this._removeInactiveAction(u));
    }
    const i = this._bindingsByRootAndName,
      r = i[e];
    if (r !== void 0)
      for (const o in r) {
        const l = r[o];
        l.restoreOriginalState(), this._removeInactiveBinding(l);
      }
  }
  uncacheAction(t, e) {
    const n = this.existingAction(t, e);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
eF.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class nF extends Al {
  constructor(t, e, n = 1) {
    super(t, e);
    this.meshPerAttribute = n;
  }
  copy(t) {
    return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
  }
  clone(t) {
    const e = super.clone(t);
    return (e.meshPerAttribute = this.meshPerAttribute), e;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return (
      (e.isInstancedInterleavedBuffer = !0),
      (e.meshPerAttribute = this.meshPerAttribute),
      e
    );
  }
}
nF.prototype.isInstancedInterleavedBuffer = !0;
class uF {
  constructor(t, e, n = 0, i = 1 / 0) {
    (this.ray = new to(t, e)),
      (this.near = n),
      (this.far = i),
      (this.camera = null),
      (this.layers = new zv()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(t, e) {
    this.ray.set(t, e);
  }
  setFromCamera(t, e) {
    e && e.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
        this.ray.direction
          .set(t.x, t.y, 0.5)
          .unproject(e)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = e))
      : e && e.isOrthographicCamera
      ? (this.ray.origin
          .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
          .unproject(e),
        this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
        (this.camera = e))
      : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
  }
  intersectObject(t, e = !0, n = []) {
    return Ip(t, this, n, e), n.sort(Ey), n;
  }
  intersectObjects(t, e = !0, n = []) {
    for (let i = 0, r = t.length; i < r; i++) Ip(t[i], this, n, e);
    return n.sort(Ey), n;
  }
}
function Ey(a, t) {
  return a.distance - t.distance;
}
function Ip(a, t, e, n) {
  if ((a.layers.test(t.layers) && a.raycast(t, e), n === !0)) {
    const i = a.children;
    for (let r = 0, o = i.length; r < o; r++) Ip(i[r], t, e, !0);
  }
}
const Es = new k(),
  ih = new Jt(),
  Dp = new Jt();
class iF extends pp {
  constructor(t) {
    const e = Ay(t),
      n = new Ge(),
      i = [],
      r = [],
      o = new Xt(0, 0, 1),
      l = new Xt(0, 1, 0);
    for (let h = 0; h < e.length; h++) {
      const f = e[h];
      f.parent &&
        f.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        r.push(o.r, o.g, o.b),
        r.push(l.r, l.g, l.b));
    }
    n.setAttribute("position", new en(i, 3)),
      n.setAttribute("color", new en(r, 3));
    const u = new Dl({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(n, u);
    (this.type = "SkeletonHelper"),
      (this.isSkeletonHelper = !0),
      (this.root = t),
      (this.bones = e),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(t) {
    const e = this.bones,
      n = this.geometry,
      i = n.getAttribute("position");
    Dp.copy(this.root.matrixWorld).invert();
    for (let r = 0, o = 0; r < e.length; r++) {
      const l = e[r];
      l.parent &&
        l.parent.isBone &&
        (ih.multiplyMatrices(Dp, l.matrixWorld),
        Es.setFromMatrixPosition(ih),
        i.setXYZ(o, Es.x, Es.y, Es.z),
        ih.multiplyMatrices(Dp, l.parent.matrixWorld),
        Es.setFromMatrixPosition(ih),
        i.setXYZ(o + 1, Es.x, Es.y, Es.z),
        (o += 2));
    }
    (n.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(t);
  }
}
function Ay(a) {
  const t = [];
  a && a.isBone && t.push(a);
  for (let e = 0; e < a.children.length; e++)
    t.push.apply(t, Ay(a.children[e]));
  return t;
}
class rF extends pp {
  constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
    (n = new Xt(n)), (i = new Xt(i));
    const r = e / 2,
      o = t / e,
      l = t / 2,
      u = [],
      h = [];
    for (let g = 0, p = 0, v = -l; g <= e; g++, v += o) {
      u.push(-l, 0, v, l, 0, v), u.push(v, 0, -l, v, 0, l);
      const x = g === r ? n : i;
      x.toArray(h, p),
        (p += 3),
        x.toArray(h, p),
        (p += 3),
        x.toArray(h, p),
        (p += 3),
        x.toArray(h, p),
        (p += 3);
    }
    const f = new Ge();
    f.setAttribute("position", new en(u, 3)),
      f.setAttribute("color", new en(h, 3));
    const m = new Dl({ vertexColors: !0, toneMapped: !1 });
    super(f, m);
    this.type = "GridHelper";
  }
}
const sF = new Float32Array(1);
new Int32Array(sF.buffer);
Bi.create = function (a, t) {
  return (
    console.log("THREE.Curve.create() has been deprecated"),
    (a.prototype = Object.create(Bi.prototype)),
    (a.prototype.constructor = a),
    (a.prototype.getPoint = t),
    a
  );
};
Mp.prototype.fromPoints = function (a) {
  return (
    console.warn(
      "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
    ),
    this.setFromPoints(a)
  );
};
rF.prototype.setColors = function () {
  console.error(
    "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
  );
};
iF.prototype.update = function () {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
};
Ts.prototype.extractUrlBase = function (a) {
  return (
    console.warn(
      "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
    ),
    ND.extractUrlBase(a)
  );
};
Ts.Handlers = {
  add: function () {
    console.error(
      "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
    );
  },
  get: function () {
    console.error(
      "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
    );
  },
};
Wi.prototype.center = function (a) {
  return (
    console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
    this.getCenter(a)
  );
};
Wi.prototype.empty = function () {
  return (
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
  );
};
Wi.prototype.isIntersectionBox = function (a) {
  return (
    console.warn(
      "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
    ),
    this.intersectsBox(a)
  );
};
Wi.prototype.isIntersectionSphere = function (a) {
  return (
    console.warn(
      "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
    ),
    this.intersectsSphere(a)
  );
};
Wi.prototype.size = function (a) {
  return (
    console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
    this.getSize(a)
  );
};
sa.prototype.empty = function () {
  return (
    console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
  );
};
Bu.prototype.setFromMatrix = function (a) {
  return (
    console.warn(
      "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
    ),
    this.setFromProjectionMatrix(a)
  );
};
Mn.prototype.flattenToArrayOffset = function (a, t) {
  return (
    console.warn(
      "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
    ),
    this.toArray(a, t)
  );
};
Mn.prototype.multiplyVector3 = function (a) {
  return (
    console.warn(
      "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
    ),
    a.applyMatrix3(this)
  );
};
Mn.prototype.multiplyVector3Array = function () {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
};
Mn.prototype.applyToBufferAttribute = function (a) {
  return (
    console.warn(
      "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
    ),
    a.applyMatrix3(this)
  );
};
Mn.prototype.applyToVector3Array = function () {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
};
Mn.prototype.getInverse = function (a) {
  return (
    console.warn(
      "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
    ),
    this.copy(a).invert()
  );
};
Jt.prototype.extractPosition = function (a) {
  return (
    console.warn(
      "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
    ),
    this.copyPosition(a)
  );
};
Jt.prototype.flattenToArrayOffset = function (a, t) {
  return (
    console.warn(
      "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
    ),
    this.toArray(a, t)
  );
};
Jt.prototype.getPosition = function () {
  return (
    console.warn(
      "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
    ),
    new k().setFromMatrixColumn(this, 3)
  );
};
Jt.prototype.setRotationFromQuaternion = function (a) {
  return (
    console.warn(
      "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
    ),
    this.makeRotationFromQuaternion(a)
  );
};
Jt.prototype.multiplyToArray = function () {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
};
Jt.prototype.multiplyVector3 = function (a) {
  return (
    console.warn(
      "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
    ),
    a.applyMatrix4(this)
  );
};
Jt.prototype.multiplyVector4 = function (a) {
  return (
    console.warn(
      "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
    ),
    a.applyMatrix4(this)
  );
};
Jt.prototype.multiplyVector3Array = function () {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
};
Jt.prototype.rotateAxis = function (a) {
  console.warn(
    "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
  ),
    a.transformDirection(this);
};
Jt.prototype.crossVector = function (a) {
  return (
    console.warn(
      "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
    ),
    a.applyMatrix4(this)
  );
};
Jt.prototype.translate = function () {
  console.error("THREE.Matrix4: .translate() has been removed.");
};
Jt.prototype.rotateX = function () {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
};
Jt.prototype.rotateY = function () {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
};
Jt.prototype.rotateZ = function () {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
};
Jt.prototype.rotateByAxis = function () {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
};
Jt.prototype.applyToBufferAttribute = function (a) {
  return (
    console.warn(
      "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
    ),
    a.applyMatrix4(this)
  );
};
Jt.prototype.applyToVector3Array = function () {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
};
Jt.prototype.makeFrustum = function (a, t, e, n, i, r) {
  return (
    console.warn(
      "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
    ),
    this.makePerspective(a, t, n, e, i, r)
  );
};
Jt.prototype.getInverse = function (a) {
  return (
    console.warn(
      "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
    ),
    this.copy(a).invert()
  );
};
Br.prototype.isIntersectionLine = function (a) {
  return (
    console.warn(
      "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
    ),
    this.intersectsLine(a)
  );
};
Qn.prototype.multiplyVector3 = function (a) {
  return (
    console.warn(
      "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
    ),
    a.applyQuaternion(this)
  );
};
Qn.prototype.inverse = function () {
  return (
    console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
    this.invert()
  );
};
to.prototype.isIntersectionBox = function (a) {
  return (
    console.warn(
      "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
    ),
    this.intersectsBox(a)
  );
};
to.prototype.isIntersectionPlane = function (a) {
  return (
    console.warn(
      "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
    ),
    this.intersectsPlane(a)
  );
};
to.prototype.isIntersectionSphere = function (a) {
  return (
    console.warn(
      "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
    ),
    this.intersectsSphere(a)
  );
};
an.prototype.area = function () {
  return (
    console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
    this.getArea()
  );
};
an.prototype.barycoordFromPoint = function (a, t) {
  return (
    console.warn(
      "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
    ),
    this.getBarycoord(a, t)
  );
};
an.prototype.midpoint = function (a) {
  return (
    console.warn(
      "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
    ),
    this.getMidpoint(a)
  );
};
an.prototypenormal = function (a) {
  return (
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    this.getNormal(a)
  );
};
an.prototype.plane = function (a) {
  return (
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
    this.getPlane(a)
  );
};
an.barycoordFromPoint = function (a, t, e, n, i) {
  return (
    console.warn(
      "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
    ),
    an.getBarycoord(a, t, e, n, i)
  );
};
an.normal = function (a, t, e, n) {
  return (
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    an.getNormal(a, t, e, n)
  );
};
Nl.prototype.extractAllPoints = function (a) {
  return (
    console.warn(
      "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
    ),
    this.extractPoints(a)
  );
};
Nl.prototype.extrude = function (a) {
  return (
    console.warn(
      "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
    ),
    new Ea(this, a)
  );
};
Nl.prototype.makeGeometry = function (a) {
  return (
    console.warn(
      "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
    ),
    new Ep(this, a)
  );
};
Et.prototype.fromAttribute = function (a, t, e) {
  return (
    console.warn(
      "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
    ),
    this.fromBufferAttribute(a, t, e)
  );
};
Et.prototype.distanceToManhattan = function (a) {
  return (
    console.warn(
      "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
    ),
    this.manhattanDistanceTo(a)
  );
};
Et.prototype.lengthManhattan = function () {
  return (
    console.warn(
      "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
    ),
    this.manhattanLength()
  );
};
k.prototype.setEulerFromRotationMatrix = function () {
  console.error(
    "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
  );
};
k.prototype.setEulerFromQuaternion = function () {
  console.error(
    "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
  );
};
k.prototype.getPositionFromMatrix = function (a) {
  return (
    console.warn(
      "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
    ),
    this.setFromMatrixPosition(a)
  );
};
k.prototype.getScaleFromMatrix = function (a) {
  return (
    console.warn(
      "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
    ),
    this.setFromMatrixScale(a)
  );
};
k.prototype.getColumnFromMatrix = function (a, t) {
  return (
    console.warn(
      "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
    ),
    this.setFromMatrixColumn(t, a)
  );
};
k.prototype.applyProjection = function (a) {
  return (
    console.warn(
      "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
    ),
    this.applyMatrix4(a)
  );
};
k.prototype.fromAttribute = function (a, t, e) {
  return (
    console.warn(
      "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
    ),
    this.fromBufferAttribute(a, t, e)
  );
};
k.prototype.distanceToManhattan = function (a) {
  return (
    console.warn(
      "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
    ),
    this.manhattanDistanceTo(a)
  );
};
k.prototype.lengthManhattan = function () {
  return (
    console.warn(
      "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
    ),
    this.manhattanLength()
  );
};
Fe.prototype.fromAttribute = function (a, t, e) {
  return (
    console.warn(
      "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
    ),
    this.fromBufferAttribute(a, t, e)
  );
};
Fe.prototype.lengthManhattan = function () {
  return (
    console.warn(
      "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
    ),
    this.manhattanLength()
  );
};
Me.prototype.getChildByName = function (a) {
  return (
    console.warn(
      "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
    ),
    this.getObjectByName(a)
  );
};
Me.prototype.renderDepth = function () {
  console.warn(
    "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
  );
};
Me.prototype.translate = function (a, t) {
  return (
    console.warn(
      "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
    ),
    this.translateOnAxis(t, a)
  );
};
Me.prototype.getWorldRotation = function () {
  console.error(
    "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
  );
};
Me.prototype.applyMatrix = function (a) {
  return (
    console.warn(
      "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
    ),
    this.applyMatrix4(a)
  );
};
Object.defineProperties(Me.prototype, {
  eulerOrder: {
    get: function () {
      return (
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
        this.rotation.order
      );
    },
    set: function (a) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
        (this.rotation.order = a);
    },
  },
  useQuaternion: {
    get: function () {
      console.warn(
        "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
      );
    },
    set: function () {
      console.warn(
        "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
      );
    },
  },
});
ti.prototype.setDrawMode = function () {
  console.error(
    "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
  );
};
Object.defineProperties(ti.prototype, {
  drawMode: {
    get: function () {
      return (
        console.error(
          "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
        ),
        NC
      );
    },
    set: function () {
      console.error(
        "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
      );
    },
  },
});
Hx.prototype.initBones = function () {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
};
ei.prototype.setLens = function (a, t) {
  console.warn(
    "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
  ),
    t !== void 0 && (this.filmGauge = t),
    this.setFocalLength(a);
};
Object.defineProperties(ur.prototype, {
  onlyShadow: {
    set: function () {
      console.warn("THREE.Light: .onlyShadow has been removed.");
    },
  },
  shadowCameraFov: {
    set: function (a) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
        (this.shadow.camera.fov = a);
    },
  },
  shadowCameraLeft: {
    set: function (a) {
      console.warn(
        "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
      ),
        (this.shadow.camera.left = a);
    },
  },
  shadowCameraRight: {
    set: function (a) {
      console.warn(
        "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
      ),
        (this.shadow.camera.right = a);
    },
  },
  shadowCameraTop: {
    set: function (a) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
        (this.shadow.camera.top = a);
    },
  },
  shadowCameraBottom: {
    set: function (a) {
      console.warn(
        "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
      ),
        (this.shadow.camera.bottom = a);
    },
  },
  shadowCameraNear: {
    set: function (a) {
      console.warn(
        "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
      ),
        (this.shadow.camera.near = a);
    },
  },
  shadowCameraFar: {
    set: function (a) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
        (this.shadow.camera.far = a);
    },
  },
  shadowCameraVisible: {
    set: function () {
      console.warn(
        "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
      );
    },
  },
  shadowBias: {
    set: function (a) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
        (this.shadow.bias = a);
    },
  },
  shadowDarkness: {
    set: function () {
      console.warn("THREE.Light: .shadowDarkness has been removed.");
    },
  },
  shadowMapWidth: {
    set: function (a) {
      console.warn(
        "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
      ),
        (this.shadow.mapSize.width = a);
    },
  },
  shadowMapHeight: {
    set: function (a) {
      console.warn(
        "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
      ),
        (this.shadow.mapSize.height = a);
    },
  },
});
Object.defineProperties(hn.prototype, {
  length: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
        ),
        this.array.length
      );
    },
  },
  dynamic: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
        ),
        this.usage === _u
      );
    },
    set: function () {
      console.warn(
        "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
      ),
        this.setUsage(_u);
    },
  },
});
hn.prototype.setDynamic = function (a) {
  return (
    console.warn(
      "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
    ),
    this.setUsage(a === !0 ? _u : vl),
    this
  );
};
(hn.prototype.copyIndicesArray = function () {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}),
  (hn.prototype.setArray = function () {
    console.error(
      "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
    );
  });
Ge.prototype.addIndex = function (a) {
  console.warn(
    "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
  ),
    this.setIndex(a);
};
Ge.prototype.addAttribute = function (a, t) {
  return (
    console.warn(
      "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
    ),
    !(t && t.isBufferAttribute) && !(t && t.isInterleavedBufferAttribute)
      ? (console.warn(
          "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
        ),
        this.setAttribute(a, new hn(arguments[1], arguments[2])))
      : a === "index"
      ? (console.warn(
          "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
        ),
        this.setIndex(t),
        this)
      : this.setAttribute(a, t)
  );
};
Ge.prototype.addDrawCall = function (a, t, e) {
  e !== void 0 &&
    console.warn(
      "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
    ),
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
    this.addGroup(a, t);
};
Ge.prototype.clearDrawCalls = function () {
  console.warn(
    "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
  ),
    this.clearGroups();
};
Ge.prototype.computeOffsets = function () {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
};
Ge.prototype.removeAttribute = function (a) {
  return (
    console.warn(
      "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
    ),
    this.deleteAttribute(a)
  );
};
Ge.prototype.applyMatrix = function (a) {
  return (
    console.warn(
      "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
    ),
    this.applyMatrix4(a)
  );
};
Object.defineProperties(Ge.prototype, {
  drawcalls: {
    get: function () {
      return (
        console.error(
          "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
        ),
        this.groups
      );
    },
  },
  offsets: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferGeometry: .offsets has been renamed to .groups."
        ),
        this.groups
      );
    },
  },
});
Al.prototype.setDynamic = function (a) {
  return (
    console.warn(
      "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
    ),
    this.setUsage(a === !0 ? _u : vl),
    this
  );
};
Al.prototype.setArray = function () {
  console.error(
    "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
  );
};
Ea.prototype.getArrays = function () {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
};
Ea.prototype.addShapeList = function () {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
};
Ea.prototype.addShape = function () {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
};
Dx.prototype.dispose = function () {
  console.error("THREE.Scene: .dispose() has been removed.");
};
Object.defineProperties(Rn.prototype, {
  wrapAround: {
    get: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
    set: function () {
      console.warn("THREE.Material: .wrapAround has been removed.");
    },
  },
  overdraw: {
    get: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
    set: function () {
      console.warn("THREE.Material: .overdraw has been removed.");
    },
  },
  wrapRGB: {
    get: function () {
      return (
        console.warn("THREE.Material: .wrapRGB has been removed."), new Xt()
      );
    },
  },
  shading: {
    get: function () {
      console.error(
        "THREE." +
          this.type +
          ": .shading has been removed. Use the boolean .flatShading instead."
      );
    },
    set: function (a) {
      console.warn(
        "THREE." +
          this.type +
          ": .shading has been removed. Use the boolean .flatShading instead."
      ),
        (this.flatShading = a === rv);
    },
  },
  stencilMask: {
    get: function () {
      return (
        console.warn(
          "THREE." +
            this.type +
            ": .stencilMask has been removed. Use .stencilFuncMask instead."
        ),
        this.stencilFuncMask
      );
    },
    set: function (a) {
      console.warn(
        "THREE." +
          this.type +
          ": .stencilMask has been removed. Use .stencilFuncMask instead."
      ),
        (this.stencilFuncMask = a);
    },
  },
  vertexTangents: {
    get: function () {
      console.warn(
        "THREE." + this.type + ": .vertexTangents has been removed."
      );
    },
    set: function () {
      console.warn(
        "THREE." + this.type + ": .vertexTangents has been removed."
      );
    },
  },
});
Object.defineProperties(eo.prototype, {
  derivatives: {
    get: function () {
      return (
        console.warn(
          "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ),
        this.extensions.derivatives
      );
    },
    set: function (a) {
      console.warn(
        "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
      ),
        (this.extensions.derivatives = a);
    },
  },
});
Le.prototype.clearTarget = function (a, t, e, n) {
  console.warn(
    "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
  ),
    this.setRenderTarget(a),
    this.clear(t, e, n);
};
Le.prototype.animate = function (a) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
    this.setAnimationLoop(a);
};
Le.prototype.getCurrentRenderTarget = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
    ),
    this.getRenderTarget()
  );
};
Le.prototype.getMaxAnisotropy = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
    ),
    this.capabilities.getMaxAnisotropy()
  );
};
Le.prototype.getPrecision = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
    ),
    this.capabilities.precision
  );
};
Le.prototype.resetGLState = function () {
  return (
    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
    this.state.reset()
  );
};
Le.prototype.supportsFloatTextures = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
    ),
    this.extensions.get("OES_texture_float")
  );
};
Le.prototype.supportsHalfFloatTextures = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
    ),
    this.extensions.get("OES_texture_half_float")
  );
};
Le.prototype.supportsStandardDerivatives = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
    ),
    this.extensions.get("OES_standard_derivatives")
  );
};
Le.prototype.supportsCompressedTextureS3TC = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
    ),
    this.extensions.get("WEBGL_compressed_texture_s3tc")
  );
};
Le.prototype.supportsCompressedTexturePVRTC = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
    ),
    this.extensions.get("WEBGL_compressed_texture_pvrtc")
  );
};
Le.prototype.supportsBlendMinMax = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
    ),
    this.extensions.get("EXT_blend_minmax")
  );
};
Le.prototype.supportsVertexTextures = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
    ),
    this.capabilities.vertexTextures
  );
};
Le.prototype.supportsInstancedArrays = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
    ),
    this.extensions.get("ANGLE_instanced_arrays")
  );
};
Le.prototype.enableScissorTest = function (a) {
  console.warn(
    "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
  ),
    this.setScissorTest(a);
};
Le.prototype.initMaterial = function () {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
};
Le.prototype.addPrePlugin = function () {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
};
Le.prototype.addPostPlugin = function () {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
};
Le.prototype.updateShadowMap = function () {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
};
Le.prototype.setFaceCulling = function () {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
};
Le.prototype.allocTextureUnit = function () {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
};
Le.prototype.setTexture = function () {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
};
Le.prototype.setTexture2D = function () {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
};
Le.prototype.setTextureCube = function () {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
};
Le.prototype.getActiveMipMapLevel = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
    ),
    this.getActiveMipmapLevel()
  );
};
Object.defineProperties(Le.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (a) {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
      ),
        (this.shadowMap.enabled = a);
    },
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (a) {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
      ),
        (this.shadowMap.type = a);
    },
  },
  shadowMapCullFace: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
      );
    },
  },
  context: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
        ),
        this.getContext()
      );
    },
  },
  vr: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
        this.xr
      );
    },
  },
  gammaInput: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
        ),
        !1
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
      );
    },
  },
  gammaOutput: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
        ),
        !1
      );
    },
    set: function (a) {
      console.warn(
        "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
      ),
        (this.outputEncoding = a === !0 ? Js : Cn);
    },
  },
  toneMappingWhitePoint: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
        ),
        1
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
      );
    },
  },
});
Object.defineProperties(Px.prototype, {
  cullFace: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
      );
    },
  },
  renderReverseSided: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
      );
    },
  },
  renderSingleSided: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
      );
    },
  },
});
Object.defineProperties(or.prototype, {
  wrapS: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
        this.texture.wrapS
      );
    },
    set: function (a) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
        (this.texture.wrapS = a);
    },
  },
  wrapT: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
        this.texture.wrapT
      );
    },
    set: function (a) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
        (this.texture.wrapT = a);
    },
  },
  magFilter: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ),
        this.texture.magFilter
      );
    },
    set: function (a) {
      console.warn(
        "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
      ),
        (this.texture.magFilter = a);
    },
  },
  minFilter: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ),
        this.texture.minFilter
      );
    },
    set: function (a) {
      console.warn(
        "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
      ),
        (this.texture.minFilter = a);
    },
  },
  anisotropy: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ),
        this.texture.anisotropy
      );
    },
    set: function (a) {
      console.warn(
        "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
      ),
        (this.texture.anisotropy = a);
    },
  },
  offset: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ),
        this.texture.offset
      );
    },
    set: function (a) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
        (this.texture.offset = a);
    },
  },
  repeat: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ),
        this.texture.repeat
      );
    },
    set: function (a) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
        (this.texture.repeat = a);
    },
  },
  format: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ),
        this.texture.format
      );
    },
    set: function (a) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
        (this.texture.format = a);
    },
  },
  type: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
        this.texture.type
      );
    },
    set: function (a) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
        (this.texture.type = a);
    },
  },
  generateMipmaps: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ),
        this.texture.generateMipmaps
      );
    },
    set: function (a) {
      console.warn(
        "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
      ),
        (this.texture.generateMipmaps = a);
    },
  },
});
VD.prototype.load = function (a) {
  console.warn(
    "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
  );
  const t = this;
  return (
    new kD().load(a, function (n) {
      t.setBuffer(n);
    }),
    this
  );
};
Kd.prototype.updateCubeMap = function (a, t) {
  return (
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
    this.update(a, t)
  );
};
Kd.prototype.clear = function (a, t, e, n) {
  return (
    console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
    this.renderTarget.clear(a, t, e, n)
  );
};
ea.crossOrigin = void 0;
ea.loadTexture = function (a, t, e, n) {
  console.warn(
    "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
  );
  const i = new CD();
  i.setCrossOrigin(this.crossOrigin);
  const r = i.load(a, e, void 0, n);
  return t && (r.mapping = t), r;
};
ea.loadTextureCube = function (a, t, e, n) {
  console.warn(
    "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
  );
  const i = new LD();
  i.setCrossOrigin(this.crossOrigin);
  const r = i.load(a, e, void 0, n);
  return t && (r.mapping = t), r;
};
ea.loadCompressedTexture = function () {
  console.error(
    "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
  );
};
ea.loadCompressedTextureCube = function () {
  console.error(
    "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
  );
};
typeof __THREE_DEVTOOLS__ != "undefined" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: ev } })
  );
typeof window != "undefined" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = ev));
var Ly = { exports: {} },
  Cy = { exports: {} };
(function (a) {
  (function (t, e) {
    a.exports ? (a.exports = e()) : (t.EvEmitter = e());
  })(typeof window != "undefined" ? window : Bs, function () {
    function t() {}
    var e = t.prototype;
    return (
      (e.on = function (n, i) {
        if (!(!n || !i)) {
          var r = (this._events = this._events || {}),
            o = (r[n] = r[n] || []);
          return o.indexOf(i) == -1 && o.push(i), this;
        }
      }),
      (e.once = function (n, i) {
        if (!(!n || !i)) {
          this.on(n, i);
          var r = (this._onceEvents = this._onceEvents || {}),
            o = (r[n] = r[n] || {});
          return (o[i] = !0), this;
        }
      }),
      (e.off = function (n, i) {
        var r = this._events && this._events[n];
        if (!(!r || !r.length)) {
          var o = r.indexOf(i);
          return o != -1 && r.splice(o, 1), this;
        }
      }),
      (e.emitEvent = function (n, i) {
        var r = this._events && this._events[n];
        if (!(!r || !r.length)) {
          (r = r.slice(0)), (i = i || []);
          for (
            var o = this._onceEvents && this._onceEvents[n], l = 0;
            l < r.length;
            l++
          ) {
            var u = r[l],
              h = o && o[u];
            h && (this.off(n, u), delete o[u]), u.apply(this, i);
          }
          return this;
        }
      }),
      (e.allOff = function () {
        delete this._events, delete this._onceEvents;
      }),
      t
    );
  });
})(Cy);
/*!
 * imagesLoaded v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */ (function (a) {
  (function (t, e) {
    a.exports
      ? (a.exports = e(t, Cy.exports))
      : (t.imagesLoaded = e(t, t.EvEmitter));
  })(typeof window != "undefined" ? window : Bs, function (e, n) {
    var i = e.jQuery,
      r = e.console;
    function o(p, v) {
      for (var x in v) p[x] = v[x];
      return p;
    }
    var l = Array.prototype.slice;
    function u(p) {
      if (Array.isArray(p)) return p;
      var v = typeof p == "object" && typeof p.length == "number";
      return v ? l.call(p) : [p];
    }
    function h(p, v, x) {
      if (!(this instanceof h)) return new h(p, v, x);
      var b = p;
      if ((typeof p == "string" && (b = document.querySelectorAll(p)), !b)) {
        r.error("Bad element for imagesLoaded " + (b || p));
        return;
      }
      (this.elements = u(b)),
        (this.options = o({}, this.options)),
        typeof v == "function" ? (x = v) : o(this.options, v),
        x && this.on("always", x),
        this.getImages(),
        i && (this.jqDeferred = new i.Deferred()),
        setTimeout(this.check.bind(this));
    }
    (h.prototype = Object.create(n.prototype)),
      (h.prototype.options = {}),
      (h.prototype.getImages = function () {
        (this.images = []), this.elements.forEach(this.addElementImages, this);
      }),
      (h.prototype.addElementImages = function (p) {
        p.nodeName == "IMG" && this.addImage(p),
          this.options.background === !0 && this.addElementBackgroundImages(p);
        var v = p.nodeType;
        if (!(!v || !f[v])) {
          for (var x = p.querySelectorAll("img"), b = 0; b < x.length; b++) {
            var _ = x[b];
            this.addImage(_);
          }
          if (typeof this.options.background == "string") {
            var y = p.querySelectorAll(this.options.background);
            for (b = 0; b < y.length; b++) {
              var E = y[b];
              this.addElementBackgroundImages(E);
            }
          }
        }
      });
    var f = { 1: !0, 9: !0, 11: !0 };
    (h.prototype.addElementBackgroundImages = function (p) {
      var v = getComputedStyle(p);
      if (!!v)
        for (
          var x = /url\((['"])?(.*?)\1\)/gi, b = x.exec(v.backgroundImage);
          b !== null;

        ) {
          var _ = b && b[2];
          _ && this.addBackground(_, p), (b = x.exec(v.backgroundImage));
        }
    }),
      (h.prototype.addImage = function (p) {
        var v = new m(p);
        this.images.push(v);
      }),
      (h.prototype.addBackground = function (p, v) {
        var x = new g(p, v);
        this.images.push(x);
      }),
      (h.prototype.check = function () {
        var p = this;
        if (
          ((this.progressedCount = 0),
          (this.hasAnyBroken = !1),
          !this.images.length)
        ) {
          this.complete();
          return;
        }
        function v(x, b, _) {
          setTimeout(function () {
            p.progress(x, b, _);
          });
        }
        this.images.forEach(function (x) {
          x.once("progress", v), x.check();
        });
      }),
      (h.prototype.progress = function (p, v, x) {
        this.progressedCount++,
          (this.hasAnyBroken = this.hasAnyBroken || !p.isLoaded),
          this.emitEvent("progress", [this, p, v]),
          this.jqDeferred &&
            this.jqDeferred.notify &&
            this.jqDeferred.notify(this, p),
          this.progressedCount == this.images.length && this.complete(),
          this.options.debug && r && r.log("progress: " + x, p, v);
      }),
      (h.prototype.complete = function () {
        var p = this.hasAnyBroken ? "fail" : "done";
        if (
          ((this.isComplete = !0),
          this.emitEvent(p, [this]),
          this.emitEvent("always", [this]),
          this.jqDeferred)
        ) {
          var v = this.hasAnyBroken ? "reject" : "resolve";
          this.jqDeferred[v](this);
        }
      });
    function m(p) {
      this.img = p;
    }
    (m.prototype = Object.create(n.prototype)),
      (m.prototype.check = function () {
        var p = this.getIsImageComplete();
        if (p) {
          this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
          return;
        }
        (this.proxyImage = new Image()),
          this.proxyImage.addEventListener("load", this),
          this.proxyImage.addEventListener("error", this),
          this.img.addEventListener("load", this),
          this.img.addEventListener("error", this),
          (this.proxyImage.src = this.img.src);
      }),
      (m.prototype.getIsImageComplete = function () {
        return this.img.complete && this.img.naturalWidth;
      }),
      (m.prototype.confirm = function (p, v) {
        (this.isLoaded = p), this.emitEvent("progress", [this, this.img, v]);
      }),
      (m.prototype.handleEvent = function (p) {
        var v = "on" + p.type;
        this[v] && this[v](p);
      }),
      (m.prototype.onload = function () {
        this.confirm(!0, "onload"), this.unbindEvents();
      }),
      (m.prototype.onerror = function () {
        this.confirm(!1, "onerror"), this.unbindEvents();
      }),
      (m.prototype.unbindEvents = function () {
        this.proxyImage.removeEventListener("load", this),
          this.proxyImage.removeEventListener("error", this),
          this.img.removeEventListener("load", this),
          this.img.removeEventListener("error", this);
      });
    function g(p, v) {
      (this.url = p), (this.element = v), (this.img = new Image());
    }
    return (
      (g.prototype = Object.create(m.prototype)),
      (g.prototype.check = function () {
        this.img.addEventListener("load", this),
          this.img.addEventListener("error", this),
          (this.img.src = this.url);
        var p = this.getIsImageComplete();
        p &&
          (this.confirm(this.img.naturalWidth !== 0, "naturalWidth"),
          this.unbindEvents());
      }),
      (g.prototype.unbindEvents = function () {
        this.img.removeEventListener("load", this),
          this.img.removeEventListener("error", this);
      }),
      (g.prototype.confirm = function (p, v) {
        (this.isLoaded = p),
          this.emitEvent("progress", [this, this.element, v]);
      }),
      (h.makeJQueryPlugin = function (p) {
        (p = p || e.jQuery),
          !!p &&
            ((i = p),
            (i.fn.imagesLoaded = function (v, x) {
              var b = new h(this, v, x);
              return b.jqDeferred.promise(i(this));
            }));
      }),
      h.makeJQueryPlugin(),
      h
    );
  });
})(Ly);
var hF = Ly.exports,
  Ry = { exports: {} };
(function (a, t) {
  (function (n, i) {
    a.exports = i();
  })(self, function () {
    return (() => {
      var e = {
          4672: (o) => {
            const l = {
              html: document.documentElement,
              body: document.body,
              window: { w: window.innerWidth, h: window.innerHeight },
            };
            o.exports = l;
          },
          5336: (o) => {
            o.exports = function (u, h) {
              let f = null;
              return function () {
                clearTimeout(f);
                const m = arguments,
                  g = this;
                f = setTimeout(function () {
                  u.apply(g, m);
                }, h);
              };
            };
          },
          6077: (o, l, u) => {
            var h = u(111);
            o.exports = function (f) {
              if (!h(f) && f !== null)
                throw TypeError("Can't set " + String(f) + " as a prototype");
              return f;
            };
          },
          1223: (o, l, u) => {
            var h = u(5112),
              f = u(30),
              m = u(3070),
              g = h("unscopables"),
              p = Array.prototype;
            p[g] == null && m.f(p, g, { configurable: !0, value: f(null) }),
              (o.exports = function (v) {
                p[g][v] = !0;
              });
          },
          9670: (o, l, u) => {
            var h = u(111);
            o.exports = function (f) {
              if (!h(f)) throw TypeError(String(f) + " is not an object");
              return f;
            };
          },
          1318: (o, l, u) => {
            var h = u(5656),
              f = u(7466),
              m = u(1400),
              g = function (p) {
                return function (v, x, b) {
                  var _ = h(v),
                    y = f(_.length),
                    E = m(b, y),
                    M;
                  if (p && x != x) {
                    for (; y > E; ) if (((M = _[E++]), M != M)) return !0;
                  } else
                    for (; y > E; E++)
                      if ((p || E in _) && _[E] === x) return p || E || 0;
                  return !p && -1;
                };
              };
            o.exports = { includes: g(!0), indexOf: g(!1) };
          },
          4326: (o) => {
            var l = {}.toString;
            o.exports = function (u) {
              return l.call(u).slice(8, -1);
            };
          },
          9920: (o, l, u) => {
            var h = u(6656),
              f = u(3887),
              m = u(1236),
              g = u(3070);
            o.exports = function (p, v) {
              for (var x = f(v), b = g.f, _ = m.f, y = 0; y < x.length; y++) {
                var E = x[y];
                h(p, E) || b(p, E, _(v, E));
              }
            };
          },
          8544: (o, l, u) => {
            var h = u(7293);
            o.exports = !h(function () {
              function f() {}
              return (
                (f.prototype.constructor = null),
                Object.getPrototypeOf(new f()) !== f.prototype
              );
            });
          },
          4994: (o, l, u) => {
            var h = u(3383).IteratorPrototype,
              f = u(30),
              m = u(9114),
              g = u(8003),
              p = u(7497),
              v = function () {
                return this;
              };
            o.exports = function (x, b, _) {
              var y = b + " Iterator";
              return (
                (x.prototype = f(h, { next: m(1, _) })),
                g(x, y, !1, !0),
                (p[y] = v),
                x
              );
            };
          },
          8880: (o, l, u) => {
            var h = u(9781),
              f = u(3070),
              m = u(9114);
            o.exports = h
              ? function (g, p, v) {
                  return f.f(g, p, m(1, v));
                }
              : function (g, p, v) {
                  return (g[p] = v), g;
                };
          },
          9114: (o) => {
            o.exports = function (l, u) {
              return {
                enumerable: !(l & 1),
                configurable: !(l & 2),
                writable: !(l & 4),
                value: u,
              };
            };
          },
          654: (o, l, u) => {
            var h = u(2109),
              f = u(4994),
              m = u(9518),
              g = u(7674),
              p = u(8003),
              v = u(8880),
              x = u(1320),
              b = u(5112),
              _ = u(1913),
              y = u(7497),
              E = u(3383),
              M = E.IteratorPrototype,
              A = E.BUGGY_SAFARI_ITERATORS,
              R = b("iterator"),
              T = "keys",
              B = "values",
              X = "entries",
              H = function () {
                return this;
              };
            o.exports = function (O, it, W, q, tt, V, Q) {
              f(W, it, q);
              var st = function (U) {
                  if (U === tt && ft) return ft;
                  if (!A && U in vt) return vt[U];
                  switch (U) {
                    case T:
                      return function () {
                        return new W(this, U);
                      };
                    case B:
                      return function () {
                        return new W(this, U);
                      };
                    case X:
                      return function () {
                        return new W(this, U);
                      };
                  }
                  return function () {
                    return new W(this);
                  };
                },
                Lt = it + " Iterator",
                J = !1,
                vt = O.prototype,
                zt = vt[R] || vt["@@iterator"] || (tt && vt[tt]),
                ft = (!A && zt) || st(tt),
                Mt = (it == "Array" && vt.entries) || zt,
                Tt,
                z,
                F;
              if (
                (Mt &&
                  ((Tt = m(Mt.call(new O()))),
                  M !== Object.prototype &&
                    Tt.next &&
                    (!_ &&
                      m(Tt) !== M &&
                      (g
                        ? g(Tt, M)
                        : typeof Tt[R] != "function" && v(Tt, R, H)),
                    p(Tt, Lt, !0, !0),
                    _ && (y[Lt] = H))),
                tt == B &&
                  zt &&
                  zt.name !== B &&
                  ((J = !0),
                  (ft = function () {
                    return zt.call(this);
                  })),
                (!_ || Q) && vt[R] !== ft && v(vt, R, ft),
                (y[it] = ft),
                tt)
              )
                if (
                  ((z = {
                    values: st(B),
                    keys: V ? ft : st(T),
                    entries: st(X),
                  }),
                  Q)
                )
                  for (F in z) (A || J || !(F in vt)) && x(vt, F, z[F]);
                else h({ target: it, proto: !0, forced: A || J }, z);
              return z;
            };
          },
          9781: (o, l, u) => {
            var h = u(7293);
            o.exports = !h(function () {
              return (
                Object.defineProperty({}, 1, {
                  get: function () {
                    return 7;
                  },
                })[1] != 7
              );
            });
          },
          317: (o, l, u) => {
            var h = u(7854),
              f = u(111),
              m = h.document,
              g = f(m) && f(m.createElement);
            o.exports = function (p) {
              return g ? m.createElement(p) : {};
            };
          },
          8324: (o) => {
            o.exports = {
              CSSRuleList: 0,
              CSSStyleDeclaration: 0,
              CSSValueList: 0,
              ClientRectList: 0,
              DOMRectList: 0,
              DOMStringList: 0,
              DOMTokenList: 1,
              DataTransferItemList: 0,
              FileList: 0,
              HTMLAllCollection: 0,
              HTMLCollection: 0,
              HTMLFormElement: 0,
              HTMLSelectElement: 0,
              MediaList: 0,
              MimeTypeArray: 0,
              NamedNodeMap: 0,
              NodeList: 1,
              PaintRequestList: 0,
              Plugin: 0,
              PluginArray: 0,
              SVGLengthList: 0,
              SVGNumberList: 0,
              SVGPathSegList: 0,
              SVGPointList: 0,
              SVGStringList: 0,
              SVGTransformList: 0,
              SourceBufferList: 0,
              StyleSheetList: 0,
              TextTrackCueList: 0,
              TextTrackList: 0,
              TouchList: 0,
            };
          },
          5268: (o, l, u) => {
            var h = u(4326),
              f = u(7854);
            o.exports = h(f.process) == "process";
          },
          8113: (o, l, u) => {
            var h = u(5005);
            o.exports = h("navigator", "userAgent") || "";
          },
          7392: (o, l, u) => {
            var h = u(7854),
              f = u(8113),
              m = h.process,
              g = m && m.versions,
              p = g && g.v8,
              v,
              x;
            p
              ? ((v = p.split(".")), (x = v[0] + v[1]))
              : f &&
                ((v = f.match(/Edge\/(\d+)/)),
                (!v || v[1] >= 74) &&
                  ((v = f.match(/Chrome\/(\d+)/)), v && (x = v[1]))),
              (o.exports = x && +x);
          },
          748: (o) => {
            o.exports = [
              "constructor",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "toLocaleString",
              "toString",
              "valueOf",
            ];
          },
          2109: (o, l, u) => {
            var h = u(7854),
              f = u(1236).f,
              m = u(8880),
              g = u(1320),
              p = u(3505),
              v = u(9920),
              x = u(4705);
            o.exports = function (b, _) {
              var y = b.target,
                E = b.global,
                M = b.stat,
                A,
                R,
                T,
                B,
                X,
                H;
              if (
                (E
                  ? (R = h)
                  : M
                  ? (R = h[y] || p(y, {}))
                  : (R = (h[y] || {}).prototype),
                R)
              )
                for (T in _) {
                  if (
                    ((X = _[T]),
                    b.noTargetGet
                      ? ((H = f(R, T)), (B = H && H.value))
                      : (B = R[T]),
                    (A = x(E ? T : y + (M ? "." : "#") + T, b.forced)),
                    !A && B !== void 0)
                  ) {
                    if (typeof X == typeof B) continue;
                    v(X, B);
                  }
                  (b.sham || (B && B.sham)) && m(X, "sham", !0), g(R, T, X, b);
                }
            };
          },
          7293: (o) => {
            o.exports = function (l) {
              try {
                return !!l();
              } catch {
                return !0;
              }
            };
          },
          5005: (o, l, u) => {
            var h = u(857),
              f = u(7854),
              m = function (g) {
                return typeof g == "function" ? g : void 0;
              };
            o.exports = function (g, p) {
              return arguments.length < 2
                ? m(h[g]) || m(f[g])
                : (h[g] && h[g][p]) || (f[g] && f[g][p]);
            };
          },
          7854: (o, l, u) => {
            var h = function (f) {
              return f && f.Math == Math && f;
            };
            o.exports =
              h(typeof globalThis == "object" && globalThis) ||
              h(typeof window == "object" && window) ||
              h(typeof self == "object" && self) ||
              h(typeof u.g == "object" && u.g) ||
              (function () {
                return this;
              })() ||
              Function("return this")();
          },
          6656: (o, l, u) => {
            var h = u(7908),
              f = {}.hasOwnProperty;
            o.exports = function (g, p) {
              return f.call(h(g), p);
            };
          },
          3501: (o) => {
            o.exports = {};
          },
          490: (o, l, u) => {
            var h = u(5005);
            o.exports = h("document", "documentElement");
          },
          4664: (o, l, u) => {
            var h = u(9781),
              f = u(7293),
              m = u(317);
            o.exports =
              !h &&
              !f(function () {
                return (
                  Object.defineProperty(m("div"), "a", {
                    get: function () {
                      return 7;
                    },
                  }).a != 7
                );
              });
          },
          8361: (o, l, u) => {
            var h = u(7293),
              f = u(4326),
              m = "".split;
            o.exports = h(function () {
              return !Object("z").propertyIsEnumerable(0);
            })
              ? function (g) {
                  return f(g) == "String" ? m.call(g, "") : Object(g);
                }
              : Object;
          },
          2788: (o, l, u) => {
            var h = u(5465),
              f = Function.toString;
            typeof h.inspectSource != "function" &&
              (h.inspectSource = function (m) {
                return f.call(m);
              }),
              (o.exports = h.inspectSource);
          },
          9909: (o, l, u) => {
            var h = u(8536),
              f = u(7854),
              m = u(111),
              g = u(8880),
              p = u(6656),
              v = u(5465),
              x = u(6200),
              b = u(3501),
              _ = "Object already initialized",
              y = f.WeakMap,
              E,
              M,
              A,
              R = function (W) {
                return A(W) ? M(W) : E(W, {});
              },
              T = function (W) {
                return function (q) {
                  var tt;
                  if (!m(q) || (tt = M(q)).type !== W)
                    throw TypeError(
                      "Incompatible receiver, " + W + " required"
                    );
                  return tt;
                };
              };
            if (h) {
              var B = v.state || (v.state = new y()),
                X = B.get,
                H = B.has,
                O = B.set;
              (E = function (W, q) {
                if (H.call(B, W)) throw new TypeError(_);
                return (q.facade = W), O.call(B, W, q), q;
              }),
                (M = function (W) {
                  return X.call(B, W) || {};
                }),
                (A = function (W) {
                  return H.call(B, W);
                });
            } else {
              var it = x("state");
              (b[it] = !0),
                (E = function (W, q) {
                  if (p(W, it)) throw new TypeError(_);
                  return (q.facade = W), g(W, it, q), q;
                }),
                (M = function (W) {
                  return p(W, it) ? W[it] : {};
                }),
                (A = function (W) {
                  return p(W, it);
                });
            }
            o.exports = { set: E, get: M, has: A, enforce: R, getterFor: T };
          },
          4705: (o, l, u) => {
            var h = u(7293),
              f = /#|\.prototype\./,
              m = function (b, _) {
                var y = p[g(b)];
                return y == x
                  ? !0
                  : y == v
                  ? !1
                  : typeof _ == "function"
                  ? h(_)
                  : !!_;
              },
              g = (m.normalize = function (b) {
                return String(b).replace(f, ".").toLowerCase();
              }),
              p = (m.data = {}),
              v = (m.NATIVE = "N"),
              x = (m.POLYFILL = "P");
            o.exports = m;
          },
          111: (o) => {
            o.exports = function (l) {
              return typeof l == "object" ? l !== null : typeof l == "function";
            };
          },
          1913: (o) => {
            o.exports = !1;
          },
          3383: (o, l, u) => {
            var h = u(7293),
              f = u(9518),
              m = u(8880),
              g = u(6656),
              p = u(5112),
              v = u(1913),
              x = p("iterator"),
              b = !1,
              _ = function () {
                return this;
              },
              y,
              E,
              M;
            [].keys &&
              ((M = [].keys()),
              "next" in M
                ? ((E = f(f(M))), E !== Object.prototype && (y = E))
                : (b = !0));
            var A =
              y == null ||
              h(function () {
                var R = {};
                return y[x].call(R) !== R;
              });
            A && (y = {}),
              (!v || A) && !g(y, x) && m(y, x, _),
              (o.exports = { IteratorPrototype: y, BUGGY_SAFARI_ITERATORS: b });
          },
          7497: (o) => {
            o.exports = {};
          },
          133: (o, l, u) => {
            var h = u(5268),
              f = u(7392),
              m = u(7293);
            o.exports =
              !!Object.getOwnPropertySymbols &&
              !m(function () {
                return !Symbol.sham && (h ? f === 38 : f > 37 && f < 41);
              });
          },
          8536: (o, l, u) => {
            var h = u(7854),
              f = u(2788),
              m = h.WeakMap;
            o.exports = typeof m == "function" && /native code/.test(f(m));
          },
          30: (o, l, u) => {
            var h = u(9670),
              f = u(6048),
              m = u(748),
              g = u(3501),
              p = u(490),
              v = u(317),
              x = u(6200),
              b = ">",
              _ = "<",
              y = "prototype",
              E = "script",
              M = x("IE_PROTO"),
              A = function () {},
              R = function (O) {
                return _ + E + b + O + _ + "/" + E + b;
              },
              T = function (O) {
                O.write(R("")), O.close();
                var it = O.parentWindow.Object;
                return (O = null), it;
              },
              B = function () {
                var O = v("iframe"),
                  it = "java" + E + ":",
                  W;
                return (
                  (O.style.display = "none"),
                  p.appendChild(O),
                  (O.src = String(it)),
                  (W = O.contentWindow.document),
                  W.open(),
                  W.write(R("document.F=Object")),
                  W.close(),
                  W.F
                );
              },
              X,
              H = function () {
                try {
                  X = document.domain && new ActiveXObject("htmlfile");
                } catch {}
                H = X ? T(X) : B();
                for (var O = m.length; O--; ) delete H[y][m[O]];
                return H();
              };
            (g[M] = !0),
              (o.exports =
                Object.create ||
                function (it, W) {
                  var q;
                  return (
                    it !== null
                      ? ((A[y] = h(it)),
                        (q = new A()),
                        (A[y] = null),
                        (q[M] = it))
                      : (q = H()),
                    W === void 0 ? q : f(q, W)
                  );
                });
          },
          6048: (o, l, u) => {
            var h = u(9781),
              f = u(3070),
              m = u(9670),
              g = u(1956);
            o.exports = h
              ? Object.defineProperties
              : function (v, x) {
                  m(v);
                  for (var b = g(x), _ = b.length, y = 0, E; _ > y; )
                    f.f(v, (E = b[y++]), x[E]);
                  return v;
                };
          },
          3070: (o, l, u) => {
            var h = u(9781),
              f = u(4664),
              m = u(9670),
              g = u(7593),
              p = Object.defineProperty;
            l.f = h
              ? p
              : function (x, b, _) {
                  if ((m(x), (b = g(b, !0)), m(_), f))
                    try {
                      return p(x, b, _);
                    } catch {}
                  if ("get" in _ || "set" in _)
                    throw TypeError("Accessors not supported");
                  return "value" in _ && (x[b] = _.value), x;
                };
          },
          1236: (o, l, u) => {
            var h = u(9781),
              f = u(5296),
              m = u(9114),
              g = u(5656),
              p = u(7593),
              v = u(6656),
              x = u(4664),
              b = Object.getOwnPropertyDescriptor;
            l.f = h
              ? b
              : function (y, E) {
                  if (((y = g(y)), (E = p(E, !0)), x))
                    try {
                      return b(y, E);
                    } catch {}
                  if (v(y, E)) return m(!f.f.call(y, E), y[E]);
                };
          },
          8006: (o, l, u) => {
            var h = u(6324),
              f = u(748),
              m = f.concat("length", "prototype");
            l.f =
              Object.getOwnPropertyNames ||
              function (p) {
                return h(p, m);
              };
          },
          5181: (o, l) => {
            l.f = Object.getOwnPropertySymbols;
          },
          9518: (o, l, u) => {
            var h = u(6656),
              f = u(7908),
              m = u(6200),
              g = u(8544),
              p = m("IE_PROTO"),
              v = Object.prototype;
            o.exports = g
              ? Object.getPrototypeOf
              : function (x) {
                  return (
                    (x = f(x)),
                    h(x, p)
                      ? x[p]
                      : typeof x.constructor == "function" &&
                        x instanceof x.constructor
                      ? x.constructor.prototype
                      : x instanceof Object
                      ? v
                      : null
                  );
                };
          },
          6324: (o, l, u) => {
            var h = u(6656),
              f = u(5656),
              m = u(1318).indexOf,
              g = u(3501);
            o.exports = function (p, v) {
              var x = f(p),
                b = 0,
                _ = [],
                y;
              for (y in x) !h(g, y) && h(x, y) && _.push(y);
              for (; v.length > b; )
                h(x, (y = v[b++])) && (~m(_, y) || _.push(y));
              return _;
            };
          },
          1956: (o, l, u) => {
            var h = u(6324),
              f = u(748);
            o.exports =
              Object.keys ||
              function (g) {
                return h(g, f);
              };
          },
          5296: (o, l) => {
            var u = {}.propertyIsEnumerable,
              h = Object.getOwnPropertyDescriptor,
              f = h && !u.call({ 1: 2 }, 1);
            l.f = f
              ? function (g) {
                  var p = h(this, g);
                  return !!p && p.enumerable;
                }
              : u;
          },
          7674: (o, l, u) => {
            var h = u(9670),
              f = u(6077);
            o.exports =
              Object.setPrototypeOf ||
              ("__proto__" in {}
                ? (function () {
                    var m = !1,
                      g = {},
                      p;
                    try {
                      (p = Object.getOwnPropertyDescriptor(
                        Object.prototype,
                        "__proto__"
                      ).set),
                        p.call(g, []),
                        (m = g instanceof Array);
                    } catch {}
                    return function (x, b) {
                      return (
                        h(x), f(b), m ? p.call(x, b) : (x.__proto__ = b), x
                      );
                    };
                  })()
                : void 0);
          },
          3887: (o, l, u) => {
            var h = u(5005),
              f = u(8006),
              m = u(5181),
              g = u(9670);
            o.exports =
              h("Reflect", "ownKeys") ||
              function (v) {
                var x = f.f(g(v)),
                  b = m.f;
                return b ? x.concat(b(v)) : x;
              };
          },
          857: (o, l, u) => {
            var h = u(7854);
            o.exports = h;
          },
          1320: (o, l, u) => {
            var h = u(7854),
              f = u(8880),
              m = u(6656),
              g = u(3505),
              p = u(2788),
              v = u(9909),
              x = v.get,
              b = v.enforce,
              _ = String(String).split("String");
            (o.exports = function (y, E, M, A) {
              var R = A ? !!A.unsafe : !1,
                T = A ? !!A.enumerable : !1,
                B = A ? !!A.noTargetGet : !1,
                X;
              if (
                (typeof M == "function" &&
                  (typeof E == "string" && !m(M, "name") && f(M, "name", E),
                  (X = b(M)),
                  X.source ||
                    (X.source = _.join(typeof E == "string" ? E : ""))),
                y === h)
              ) {
                T ? (y[E] = M) : g(E, M);
                return;
              } else R ? !B && y[E] && (T = !0) : delete y[E];
              T ? (y[E] = M) : f(y, E, M);
            })(Function.prototype, "toString", function () {
              return (typeof this == "function" && x(this).source) || p(this);
            });
          },
          4488: (o) => {
            o.exports = function (l) {
              if (l == null) throw TypeError("Can't call method on " + l);
              return l;
            };
          },
          3505: (o, l, u) => {
            var h = u(7854),
              f = u(8880);
            o.exports = function (m, g) {
              try {
                f(h, m, g);
              } catch {
                h[m] = g;
              }
              return g;
            };
          },
          8003: (o, l, u) => {
            var h = u(3070).f,
              f = u(6656),
              m = u(5112),
              g = m("toStringTag");
            o.exports = function (p, v, x) {
              p &&
                !f((p = x ? p : p.prototype), g) &&
                h(p, g, { configurable: !0, value: v });
            };
          },
          6200: (o, l, u) => {
            var h = u(2309),
              f = u(9711),
              m = h("keys");
            o.exports = function (g) {
              return m[g] || (m[g] = f(g));
            };
          },
          5465: (o, l, u) => {
            var h = u(7854),
              f = u(3505),
              m = "__core-js_shared__",
              g = h[m] || f(m, {});
            o.exports = g;
          },
          2309: (o, l, u) => {
            var h = u(1913),
              f = u(5465);
            (o.exports = function (m, g) {
              return f[m] || (f[m] = g !== void 0 ? g : {});
            })("versions", []).push({
              version: "3.11.1",
              mode: h ? "pure" : "global",
              copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)",
            });
          },
          1400: (o, l, u) => {
            var h = u(9958),
              f = Math.max,
              m = Math.min;
            o.exports = function (g, p) {
              var v = h(g);
              return v < 0 ? f(v + p, 0) : m(v, p);
            };
          },
          5656: (o, l, u) => {
            var h = u(8361),
              f = u(4488);
            o.exports = function (m) {
              return h(f(m));
            };
          },
          9958: (o) => {
            var l = Math.ceil,
              u = Math.floor;
            o.exports = function (h) {
              return isNaN((h = +h)) ? 0 : (h > 0 ? u : l)(h);
            };
          },
          7466: (o, l, u) => {
            var h = u(9958),
              f = Math.min;
            o.exports = function (m) {
              return m > 0 ? f(h(m), 9007199254740991) : 0;
            };
          },
          7908: (o, l, u) => {
            var h = u(4488);
            o.exports = function (f) {
              return Object(h(f));
            };
          },
          7593: (o, l, u) => {
            var h = u(111);
            o.exports = function (f, m) {
              if (!h(f)) return f;
              var g, p;
              if (
                (m &&
                  typeof (g = f.toString) == "function" &&
                  !h((p = g.call(f)))) ||
                (typeof (g = f.valueOf) == "function" && !h((p = g.call(f)))) ||
                (!m &&
                  typeof (g = f.toString) == "function" &&
                  !h((p = g.call(f))))
              )
                return p;
              throw TypeError("Can't convert object to primitive value");
            };
          },
          9711: (o) => {
            var l = 0,
              u = Math.random();
            o.exports = function (h) {
              return (
                "Symbol(" +
                String(h === void 0 ? "" : h) +
                ")_" +
                (++l + u).toString(36)
              );
            };
          },
          3307: (o, l, u) => {
            var h = u(133);
            o.exports = h && !Symbol.sham && typeof Symbol.iterator == "symbol";
          },
          5112: (o, l, u) => {
            var h = u(7854),
              f = u(2309),
              m = u(6656),
              g = u(9711),
              p = u(133),
              v = u(3307),
              x = f("wks"),
              b = h.Symbol,
              _ = v ? b : (b && b.withoutSetter) || g;
            o.exports = function (y) {
              return (
                (!m(x, y) || !(p || typeof x[y] == "string")) &&
                  (p && m(b, y) ? (x[y] = b[y]) : (x[y] = _("Symbol." + y))),
                x[y]
              );
            };
          },
          6992: (o, l, u) => {
            var h = u(5656),
              f = u(1223),
              m = u(7497),
              g = u(9909),
              p = u(654),
              v = "Array Iterator",
              x = g.set,
              b = g.getterFor(v);
            (o.exports = p(
              Array,
              "Array",
              function (_, y) {
                x(this, { type: v, target: h(_), index: 0, kind: y });
              },
              function () {
                var _ = b(this),
                  y = _.target,
                  E = _.kind,
                  M = _.index++;
                return !y || M >= y.length
                  ? ((_.target = void 0), { value: void 0, done: !0 })
                  : E == "keys"
                  ? { value: M, done: !1 }
                  : E == "values"
                  ? { value: y[M], done: !1 }
                  : { value: [M, y[M]], done: !1 };
              },
              "values"
            )),
              (m.Arguments = m.Array),
              f("keys"),
              f("values"),
              f("entries");
          },
          3948: (o, l, u) => {
            var h = u(7854),
              f = u(8324),
              m = u(6992),
              g = u(8880),
              p = u(5112),
              v = p("iterator"),
              x = p("toStringTag"),
              b = m.values;
            for (var _ in f) {
              var y = h[_],
                E = y && y.prototype;
              if (E) {
                if (E[v] !== b)
                  try {
                    g(E, v, b);
                  } catch {
                    E[v] = b;
                  }
                if ((E[x] || g(E, x, _), f[_])) {
                  for (var M in m)
                    if (E[M] !== m[M])
                      try {
                        g(E, M, m[M]);
                      } catch {
                        E[M] = m[M];
                      }
                }
              }
            }
          },
        },
        n = {};
      function i(o) {
        var l = n[o];
        if (l !== void 0) return l.exports;
        var u = (n[o] = { exports: {} });
        return e[o](u, u.exports, i), u.exports;
      }
      (() => {
        i.n = (o) => {
          var l = o && o.__esModule ? () => o.default : () => o;
          return i.d(l, { a: l }), l;
        };
      })(),
        (() => {
          i.d = (o, l) => {
            for (var u in l)
              i.o(l, u) &&
                !i.o(o, u) &&
                Object.defineProperty(o, u, { enumerable: !0, get: l[u] });
          };
        })(),
        (() => {
          i.g = (function () {
            if (typeof globalThis == "object") return globalThis;
            try {
              return this || new Function("return this")();
            } catch {
              if (typeof window == "object") return window;
            }
          })();
        })(),
        (() => {
          i.o = (o, l) => Object.prototype.hasOwnProperty.call(o, l);
        })();
      var r = {};
      return (
        (() => {
          i.d(r, { default: () => Tt });
          var o = i(5336),
            l = i.n(o),
            u = i(4672),
            h = i.n(u);
          function f() {
            if (!(this instanceof f)) return new f();
            (this.size = 0),
              (this.uid = 0),
              (this.selectors = []),
              (this.selectorObjects = {}),
              (this.indexes = Object.create(this.indexes)),
              (this.activeIndexes = []);
          }
          var m = window.document.documentElement,
            g =
              m.matches ||
              m.webkitMatchesSelector ||
              m.mozMatchesSelector ||
              m.oMatchesSelector ||
              m.msMatchesSelector;
          (f.prototype.matchesSelector = function (z, F) {
            return g.call(z, F);
          }),
            (f.prototype.querySelectorAll = function (z, F) {
              return F.querySelectorAll(z);
            }),
            (f.prototype.indexes = []);
          var p = /^#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
          f.prototype.indexes.push({
            name: "ID",
            selector: function (F) {
              var U;
              if ((U = F.match(p))) return U[0].slice(1);
            },
            element: function (F) {
              if (F.id) return [F.id];
            },
          });
          var v = /^\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
          f.prototype.indexes.push({
            name: "CLASS",
            selector: function (F) {
              var U;
              if ((U = F.match(v))) return U[0].slice(1);
            },
            element: function (F) {
              var U = F.className;
              if (U) {
                if (typeof U == "string") return U.split(/\s/);
                if (typeof U == "object" && "baseVal" in U)
                  return U.baseVal.split(/\s/);
              }
            },
          });
          var x = /^((?:[\w\u00c0-\uFFFF\-]|\\.)+)/g;
          f.prototype.indexes.push({
            name: "TAG",
            selector: function (F) {
              var U;
              if ((U = F.match(x))) return U[0].toUpperCase();
            },
            element: function (F) {
              return [F.nodeName.toUpperCase()];
            },
          }),
            (f.prototype.indexes.default = {
              name: "UNIVERSAL",
              selector: function () {
                return !0;
              },
              element: function () {
                return [!0];
              },
            });
          var b;
          typeof window.Map == "function"
            ? (b = window.Map)
            : (b = (function () {
                function z() {
                  this.map = {};
                }
                return (
                  (z.prototype.get = function (F) {
                    return this.map[F + " "];
                  }),
                  (z.prototype.set = function (F, U) {
                    this.map[F + " "] = U;
                  }),
                  z
                );
              })());
          var _ =
            /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g;
          function y(z, F) {
            z = z.slice(0).concat(z.default);
            var U = z.length,
              et,
              dt,
              gt,
              j,
              ot = F,
              ct,
              St,
              xt = [];
            do
              if (
                (_.exec(""), (gt = _.exec(ot)) && ((ot = gt[3]), gt[2] || !ot))
              ) {
                for (et = 0; et < U; et++)
                  if (((St = z[et]), (ct = St.selector(gt[1])))) {
                    for (dt = xt.length, j = !1; dt--; )
                      if (xt[dt].index === St && xt[dt].key === ct) {
                        j = !0;
                        break;
                      }
                    j || xt.push({ index: St, key: ct });
                    break;
                  }
              }
            while (gt);
            return xt;
          }
          function E(z, F) {
            var U, et, dt;
            for (U = 0, et = z.length; U < et; U++)
              if (((dt = z[U]), F.isPrototypeOf(dt))) return dt;
          }
          (f.prototype.logDefaultIndexUsed = function () {}),
            (f.prototype.add = function (z, F) {
              var U,
                et,
                dt,
                gt,
                j,
                ot,
                ct,
                St,
                xt = this.activeIndexes,
                I = this.selectors,
                P = this.selectorObjects;
              if (typeof z == "string") {
                for (
                  U = { id: this.uid++, selector: z, data: F },
                    P[U.id] = U,
                    ct = y(this.indexes, z),
                    et = 0;
                  et < ct.length;
                  et++
                )
                  (St = ct[et]),
                    (gt = St.key),
                    (dt = St.index),
                    (j = E(xt, dt)),
                    j ||
                      ((j = Object.create(dt)), (j.map = new b()), xt.push(j)),
                    dt === this.indexes.default && this.logDefaultIndexUsed(U),
                    (ot = j.map.get(gt)),
                    ot || ((ot = []), j.map.set(gt, ot)),
                    ot.push(U);
                this.size++, I.push(z);
              }
            }),
            (f.prototype.remove = function (z, F) {
              if (typeof z == "string") {
                var U,
                  et,
                  dt,
                  gt,
                  j,
                  ot,
                  ct,
                  St,
                  xt = this.activeIndexes,
                  I = (this.selectors = []),
                  P = this.selectorObjects,
                  lt = {},
                  yt = arguments.length === 1;
                for (U = y(this.indexes, z), dt = 0; dt < U.length; dt++)
                  for (et = U[dt], gt = xt.length; gt--; )
                    if (((ot = xt[gt]), et.index.isPrototypeOf(ot))) {
                      if (((ct = ot.map.get(et.key)), ct))
                        for (j = ct.length; j--; )
                          (St = ct[j]),
                            St.selector === z &&
                              (yt || St.data === F) &&
                              (ct.splice(j, 1), (lt[St.id] = !0));
                      break;
                    }
                for (dt in lt) delete P[dt], this.size--;
                for (dt in P) I.push(P[dt].selector);
              }
            });
          function M(z, F) {
            return z.id - F.id;
          }
          (f.prototype.queryAll = function (z) {
            if (!this.selectors.length) return [];
            var F = {},
              U = [],
              et = this.querySelectorAll(this.selectors.join(", "), z),
              dt,
              gt,
              j,
              ot,
              ct,
              St,
              xt,
              I;
            for (dt = 0, j = et.length; dt < j; dt++)
              for (
                ct = et[dt], St = this.matches(ct), gt = 0, ot = St.length;
                gt < ot;
                gt++
              )
                (I = St[gt]),
                  F[I.id]
                    ? (xt = F[I.id])
                    : ((xt = {
                        id: I.id,
                        selector: I.selector,
                        data: I.data,
                        elements: [],
                      }),
                      (F[I.id] = xt),
                      U.push(xt)),
                  xt.elements.push(ct);
            return U.sort(M);
          }),
            (f.prototype.matches = function (z) {
              if (!z) return [];
              var F,
                U,
                et,
                dt,
                gt,
                j,
                ot,
                ct,
                St,
                xt,
                I,
                P = this.activeIndexes,
                lt = {},
                yt = [];
              for (F = 0, dt = P.length; F < dt; F++)
                if (((ot = P[F]), (ct = ot.element(z)), ct)) {
                  for (U = 0, gt = ct.length; U < gt; U++)
                    if ((St = ot.map.get(ct[U])))
                      for (et = 0, j = St.length; et < j; et++)
                        (xt = St[et]),
                          (I = xt.id),
                          !lt[I] &&
                            this.matchesSelector(z, xt.selector) &&
                            ((lt[I] = !0), yt.push(xt));
                }
              return yt.sort(M);
            });
          const A = {},
            R = {},
            T = ["mouseenter", "mouseleave"];
          function B(z) {
            R[z] === void 0 && (R[z] = []);
          }
          function X(z, F) {
            if (R[z]) for (let U = 0; U < R[z].length; U++) R[z][U](...F);
          }
          function H(z) {
            return typeof z == "string" ? document.querySelectorAll(z) : z;
          }
          function O(z) {
            let F = it(A[z.type], z.target);
            if (F.length)
              for (let U = 0; U < F.length; U++)
                for (let et = 0; et < F[U].stack.length; et++)
                  T.indexOf(z.type) !== -1
                    ? (W(z, F[U].delegatedTarget),
                      z.target === F[U].delegatedTarget &&
                        F[U].stack[et].data(z))
                    : (W(z, F[U].delegatedTarget), F[U].stack[et].data(z));
          }
          function it(z, F) {
            const U = [];
            let et = F;
            do {
              if (et.nodeType !== 1) break;
              const dt = z.matches(et);
              dt.length && U.push({ delegatedTarget: et, stack: dt });
            } while ((et = et.parentElement));
            return U;
          }
          function W(z, F) {
            Object.defineProperty(z, "currentTarget", {
              configurable: !0,
              enumerable: !0,
              get: () => F,
            });
          }
          function q(z) {
            return JSON.parse(JSON.stringify(z));
          }
          class tt {
            bindAll(F, U) {
              U === void 0 &&
                (U = Object.getOwnPropertyNames(Object.getPrototypeOf(F)));
              for (let et = 0; et < U.length; et++) F[U[et]] = F[U[et]].bind(F);
            }
            on(F, U, et, dt) {
              if (typeof U == "function" && et === void 0) {
                B(F), R[F].push(U);
                return;
              }
              const gt = F.split(" ");
              for (let j = 0; j < gt.length; j++) {
                if (
                  (U.nodeType && U.nodeType === 1) ||
                  U === window ||
                  U === document
                ) {
                  U.addEventListener(gt[j], et, dt);
                  continue;
                }
                U = H(U);
                for (let ot = 0; ot < U.length; ot++)
                  U[ot].addEventListener(gt[j], et, dt);
              }
            }
            delegate(F, U, et) {
              const dt = F.split(" ");
              for (let gt = 0; gt < dt.length; gt++) {
                let j = A[dt[gt]];
                j === void 0 &&
                  ((j = new f()),
                  (A[dt[gt]] = j),
                  T.indexOf(dt[gt]) !== -1
                    ? document.addEventListener(dt[gt], O, !0)
                    : document.addEventListener(dt[gt], O)),
                  j.add(U, et);
              }
            }
            off(F, U, et, dt) {
              if (U === void 0) {
                R[F] = [];
                return;
              }
              if (typeof U == "function") {
                B(F);
                for (let j = 0; j < R[F].length; j++)
                  R[F][j] === U && R[F].splice(j, 1);
                return;
              }
              const gt = F.split(" ");
              for (let j = 0; j < gt.length; j++) {
                const ot = A[gt[j]];
                if (ot !== void 0 && (ot.remove(U, et), ot.size === 0)) {
                  delete A[gt[j]], document.removeEventListener(gt[j], O);
                  continue;
                }
                if (U.removeEventListener !== void 0) {
                  U.removeEventListener(gt[j], et, dt);
                  continue;
                }
                U = H(U);
                for (let ct = 0; ct < U.length; ct++)
                  U[ct].removeEventListener(gt[j], et, dt);
              }
            }
            emit(F, ...U) {
              X(F, U);
            }
            debugDelegated() {
              return q(A);
            }
            debugBus() {
              return q(R);
            }
          }
          const V = new tt();
          function Q(z, F, U) {
            return (
              F in z
                ? Object.defineProperty(z, F, {
                    value: U,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                  })
                : (z[F] = U),
              z
            );
          }
          class st {
            constructor(F = {}) {
              Q(this, "onRaf", () => {
                V.emit(st.INTERNALRAF),
                  !this.options.disableRaf && requestAnimationFrame(this.onRaf);
              }),
                (this.options = F),
                this.addEvents();
            }
            addEvents() {
              this.options.disableRaf || requestAnimationFrame(this.onRaf),
                this.options.disableResize ||
                  V.on(
                    "resize",
                    window,
                    l()(() => {
                      this.onResize();
                    }, 150)
                  ),
                this.onScroll(),
                "ontouchstart" in document.documentElement &&
                  ((h().isTouch = !0), this.detectMouse());
            }
            onScroll() {
              V.on(
                "wheel",
                window,
                (F) => {
                  V.emit(st.WHEEL, { event: F });
                },
                { passive: !1 }
              ),
                V.on(
                  "scroll",
                  window,
                  (F) => {
                    V.emit(st.INTERNALSCROLL, { event: F });
                  },
                  { passive: !0 }
                );
            }
            onResize({ width: F, height: U } = {}) {
              (h().window.w = F || window.innerWidth),
                (h().window.h = U || window.innerHeight),
                V.emit(st.RESIZE);
            }
            detectMouse() {
              window.addEventListener("mousemove", function F(U) {
                (Math.abs(U.movementX) > 0 || Math.abs(U.movementY) > 0) &&
                  ((h().isTouch = !1),
                  V.emit(st.MOUSEDETECTED),
                  window.removeEventListener("mousemove", F));
              });
            }
          }
          Q(st, "INTERNALRAF", "raf:internal"),
            Q(st, "EXTERNALRAF", "raf:external"),
            Q(st, "WHEEL", "wheel"),
            Q(st, "INTERNALSCROLL", "scroll:internal"),
            Q(st, "EXTERNALSCROLL", "scroll:external"),
            Q(st, "RESIZE", "resize"),
            Q(st, "MOUSEDETECTED", "mouseDetected"),
            Q(st, "SCROLLEND", "scrollEnd"),
            i(3948);
          function Lt(z, F, U) {
            return (
              F in z
                ? Object.defineProperty(z, F, {
                    value: U,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                  })
                : (z[F] = U),
              z
            );
          }
          class J {
            constructor(F) {
              Lt(this, "onMouseMove", (U) => {
                !this.mouseDown ||
                  ((this.mousePos = U.clientY),
                  (this.position -= this.prevMousePos - this.mousePos),
                  (this.position = Math.min(
                    Math.max(this.position, 0),
                    this.maxY
                  )),
                  (this.prevMousePos = this.mousePos),
                  (this.controller.targetPos =
                    (this.position / this.maxY) * this.controller.maxScroll),
                  this.controller.clamp(),
                  (this.controller.syncScroll = !0),
                  this.transform(),
                  V.emit(st.EXTERNALSCROLL, -this.controller.targetPos));
              }),
                Lt(this, "onMouseDown", (U) => {
                  (this.mousePos = this.prevMousePos = U.clientY),
                    (this.mouseDown = !0),
                    (h().body.style.userSelect = "none"),
                    this.el.classList.add("active");
                }),
                Lt(this, "onMouseUp", () => {
                  (this.mouseDown = !1),
                    h().body.style.removeProperty("user-select"),
                    this.el.classList.remove("active");
                }),
                (this.controller = F),
                this.addHTML(),
                (this.el = document.querySelector(
                  this.controller.options.scrollbarEl
                )),
                (this.handle = document.querySelector(
                  this.controller.options.scrollbarHandleEl
                )),
                (this.position = 0),
                (this.mousePos = 0),
                (this.prevMousePos = 0),
                this.addStyles(),
                this.addEvents();
            }
            transform() {
              let F;
              this.mouseDown
                ? (F = this.position)
                : ((F =
                    (-this.controller.targetPos / -this.controller.maxScroll) *
                    (h().window.h - this.handleHeight)),
                  (this.position = F)),
                (this.handle.style.transform = "translate3d(0, ".concat(
                  F,
                  "px, 0)"
                ));
            }
            show() {
              this.el.classList.add("show");
            }
            hide() {
              this.el.classList.remove("show");
            }
            addEvents() {
              V.on("mousedown", this.handle, this.onMouseDown),
                V.on("mousemove", window, this.onMouseMove),
                V.on("mouseup", window, this.onMouseUp);
            }
            onResize() {
              if (
                ((this.scale =
                  (-this.controller.maxScroll + h().window.h) / h().window.h),
                this.scale <= 1)
              ) {
                this.handle.style.height = 0;
                return;
              }
              (this.trueSize = h().window.h / this.scale),
                (this.handleHeight = Math.max(this.trueSize, 40)),
                (this.handle.style.height = "".concat(this.handleHeight, "px")),
                (this.maxY = h().window.h - this.handleHeight);
            }
            addHTML() {
              if (document.querySelector(this.controller.options.scrollbarEl))
                return;
              const F = document.createElement("div");
              F.classList.add(this.controller.options.scrollbarEl.substring(1)),
                (F.innerHTML = '<div class="'.concat(
                  this.controller.options.scrollbarHandleEl.substring(1),
                  '"><div></div></div>'
                )),
                document.body.appendChild(F);
            }
            addStyles() {
              if (
                !this.controller.options.disableNativeScrollbar &&
                !this.controller.options.scrollbarStyles
              )
                return;
              let F = "";
              this.controller.options.disableNativeScrollbar &&
                (F +=
                  "html{scrollbar-width:none;}body{-ms-overflow-style:none;}body::-webkit-scrollbar{width:0;height:0;}"),
                this.controller.options.scrollbarStyles &&
                  (F += ""
                    .concat(
                      this.controller.options.scrollbarEl,
                      " {position:fixed;top:0;right:0;width:20px;height:100%;z-index:900;}.is-touch "
                    )
                    .concat(
                      this.controller.options.scrollbarEl,
                      " {display:none;}"
                    )
                    .concat(
                      this.controller.options.scrollbarEl,
                      " > div {padding:6px 0;width:10px;height:0;margin:0 auto;visibility:hidden;}"
                    )
                    .concat(
                      this.controller.options.scrollbarEl,
                      " > div > div {width:100%;height:100%;border-radius:10px;opacity:0.3;background-color:#000;}"
                    )
                    .concat(
                      this.controller.options.scrollbarEl,
                      " > div > div:hover {opacity:0.9;}"
                    )
                    .concat(
                      this.controller.options.scrollbarEl,
                      ":hover > div, "
                    )
                    .concat(
                      this.controller.options.scrollbarEl,
                      ".show > div, "
                    )
                    .concat(
                      this.controller.options.scrollbarEl,
                      ".active > div {visibility:visible;}"
                    )
                    .concat(
                      this.controller.options.scrollbarEl,
                      ".active > div > div {opacity:0.9;}"
                    ));
              const U = document.createElement("style");
              U.styleSheet
                ? (U.styleSheet.cssText = F)
                : U.appendChild(document.createTextNode(F)),
                document.getElementsByTagName("head")[0].appendChild(U);
            }
            destroy() {
              V.off("mousedown", this.handle, this.onMouseDown),
                V.off("mousemove", window, this.onMouseMove),
                V.off("mouseup", window, this.onMouseUp);
            }
          }
          function vt(z, F, U) {
            return (
              F in z
                ? Object.defineProperty(z, F, {
                    value: U,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                  })
                : (z[F] = U),
              z
            );
          }
          class zt {
            constructor(F = {}) {
              vt(this, "onScroll", ({ event: U }) => {
                if (
                  (this.scrolling ||
                    (this.options.customScrollbar && this.scrollbar.show(),
                    this.toggleIframes(),
                    (this.scrolling = !0)),
                  !h().isTouch && U.type === "wheel")
                )
                  U.preventDefault(),
                    (this.syncScroll = !0),
                    (this.targetPos += U.deltaY * -1);
                else {
                  if (this.preventResizeScroll) {
                    this.preventResizeScroll = !1;
                    return;
                  }
                  h().isTouch && this.options.touchScrollType === "scrollTop"
                    ? (this.targetPos = this.horizontalScroll
                        ? -this.containerElement.scrollLeft
                        : -this.containerElement.scrollTop)
                    : (this.targetPos = -window.scrollY),
                    h().isTouch &&
                      this.options.touchScrollType !== "transform" &&
                      (this.currentPos = this.targetPos);
                }
                this.clamp(),
                  this.options.customScrollbar && this.scrollbar.transform(),
                  V.emit(st.EXTERNALSCROLL, -this.targetPos);
              }),
                vt(this, "onRAF", () => {
                  if (
                    (this.testFps &&
                      this.options.limitLerpRate &&
                      ((this.time = performance.now() * 0.001),
                      (this.delta = Math.min(
                        (this.time - this.startTime) * 60,
                        1
                      )),
                      (this.startTime = this.time)),
                    !this.render)
                  )
                    return;
                  Math.abs(this.targetPos - this.currentPos) < 0.5
                    ? ((this.currentPos = this.targetPos),
                      this.scrolling &&
                        !this.syncScroll &&
                        ((this.scrolling = !1),
                        this.options.customScrollbar && this.scrollbar.hide(),
                        this.toggleIframes(!0),
                        V.emit(st.SCROLLEND, -this.targetPos)),
                      this.syncScroll &&
                        (window.scrollTo(0, -this.targetPos),
                        (this.syncScroll = !1)))
                    : (this.currentPos +=
                        (this.targetPos - this.currentPos) *
                        this.ease *
                        this.delta);
                  const U = this.horizontalScroll ? this.currentPos : 0,
                    et = this.horizontalScroll ? 0 : this.currentPos;
                  this.applyTransform(U, et),
                    V.emit(st.EXTERNALRAF, {
                      targetPos: -this.targetPos,
                      currentPos: -this.currentPos,
                    });
                }),
                vt(this, "onResize", () => {
                  if (this.scrollElementsLength > 1) {
                    const et =
                        this.scrollElements[this.scrollElementsLength - 1],
                      dt = window.getComputedStyle(et),
                      gt = parseFloat(
                        this.horizontalScroll ? dt.marginRight : dt.marginBottom
                      ),
                      j = et.getBoundingClientRect(),
                      ot = this.horizontalScroll ? j.right : j.bottom;
                    this.scrollLength = ot + gt - this.currentPos;
                  } else
                    this.scrollLength = this.horizontalScroll
                      ? this.scrollElements[0].scrollWidth
                      : this.scrollElements[0].scrollHeight;
                  const U = this.horizontalScroll ? h().window.w : h().window.h;
                  (this.maxScroll =
                    this.scrollLength > U ? -(this.scrollLength - U) : 0),
                    this.clamp(),
                    this.firstResize || (this.preventResizeScroll = !0),
                    (h().body.style.height = this.scrollLength + "px"),
                    this.options.customScrollbar && this.scrollbar.onResize(),
                    (this.firstResize = !1);
                }),
                vt(this, "toggleFixedContainer", () => {
                  this.containerElement.style.position = "static";
                  const U = this.currentPos;
                  this.applyTransform(0, 0),
                    requestAnimationFrame(() => {
                      this.containerElement.style.position = "fixed";
                      const et = this.horizontalScroll ? U : 0,
                        dt = this.horizontalScroll ? 0 : U;
                      this.applyTransform(et, dt);
                    });
                }),
                (this.options = F),
                (this.targetPos =
                  this.currentPos =
                  this.prevScrollPos =
                  this.maxScroll =
                    0),
                (this.enabled = !1),
                (this.render = !1),
                (this.scrolling = !1),
                (this.syncScroll = !1),
                (this.horizontalScroll = !1),
                (this.firstResize = !0),
                (this.preventResizeScroll = !1),
                (this.ease = h().isTouch
                  ? this.options.touchEase
                  : this.options.ease),
                (this.originalScrollbarSetting = this.options.customScrollbar),
                (this.testFps = !0),
                (this.delta = 1),
                (this.time = this.startTime = performance.now()),
                this.setElements(),
                h().isTouch
                  ? ((this.options.customScrollbar = !1),
                    this.options.touchScrollType === "transform"
                      ? this.setupSmoothScroll()
                      : this.options.touchScrollType === "scrollTop" &&
                        (document.documentElement.classList.add(
                          "asscroll-touch"
                        ),
                        this.addTouchStyles(),
                        V.on(
                          "scroll",
                          this.containerElement,
                          (U) => {
                            V.emit(st.INTERNALSCROLL, { event: U });
                          },
                          { passive: !0 }
                        )))
                  : this.setupSmoothScroll(),
                this.addEvents();
            }
            setElements() {
              (this.containerElement =
                typeof this.options.containerElement == "string"
                  ? document.querySelector(this.options.containerElement)
                  : this.options.containerElement),
                this.containerElement === null &&
                  console.error("ASScroll: could not find container element"),
                this.containerElement.setAttribute("asscroll-container", ""),
                (this.scrollElements =
                  typeof this.options.scrollElements == "string"
                    ? document.querySelectorAll(this.options.scrollElements)
                    : this.options.scrollElements),
                this.scrollElements.length &&
                  (this.scrollElements = [...this.scrollElements]),
                (this.scrollElements = this.scrollElements.length
                  ? this.scrollElements
                  : [this.containerElement.firstElementChild]),
                (this.scrollElementsLength = this.scrollElements.length),
                this.scrollElements.forEach((F) =>
                  F.setAttribute("asscroll", "")
                );
            }
            setupSmoothScroll() {
              Object.assign(this.containerElement.style, {
                position: "fixed",
                top: "0px",
                left: "0px",
                width: "100%",
                height: "100%",
                contain: "content",
              }),
                this.options.customScrollbar && (this.scrollbar = new J(this)),
                V.on(st.INTERNALRAF, this.onRAF),
                V.on(st.RESIZE, this.onResize),
                this.options.limitLerpRate &&
                  setTimeout(() => {
                    (this.testFps = !1),
                      (this.delta = Math.round(this.delta * 10) * 0.1);
                  }, 2e3);
            }
            applyTransform(F, U) {
              for (let et = 0; et < this.scrollElementsLength; et++)
                this.scrollElements[et].style.transform = "translate3d("
                  .concat(F, "px, ")
                  .concat(U, "px, 0px)");
            }
            enable({
              newScrollElements: F = !1,
              reset: U = !1,
              restore: et = !1,
              horizontalScroll: dt = !1,
            } = {}) {
              this.enabled ||
                ((this.enabled = !0),
                (this.render = !0),
                (this.horizontalScroll = dt),
                F &&
                  ((this.scrollElements = F.length ? [...F] : [F]),
                  (this.scrollElementsLength = this.scrollElements.length),
                  this.scrollElements.forEach((gt) =>
                    gt.setAttribute("asscroll", "")
                  )),
                (this.iframes =
                  this.containerElement.querySelectorAll("iframe")),
                h().isTouch && this.options.touchScrollType !== "transform"
                  ? (h().body.style.removeProperty("height"),
                    (this.maxScroll = -this.containerElement.scrollHeight),
                    U &&
                      ((this.targetPos = this.currentPos = 0),
                      this.scrollTo(0, !1)))
                  : ((this.firstResize = !0),
                    U &&
                      ((this.targetPos = this.currentPos = 0),
                      this.applyTransform(0, 0)),
                    this.onResize()),
                et && this.scrollTo(this.prevScrollPos, !1),
                V.on(st.WHEEL, this.onScroll),
                V.on(st.INTERNALSCROLL, this.onScroll));
            }
            disable({ inputOnly: F = !1 } = {}) {
              !this.enabled ||
                ((this.enabled = !1),
                F || (this.render = !1),
                V.off(st.WHEEL, this.onScroll),
                V.off(st.INTERNALSCROLL, this.onScroll),
                (this.prevScrollPos = this.targetPos),
                (h().body.style.height = "0px"));
            }
            clamp() {
              this.targetPos = Math.max(
                Math.min(this.targetPos, 0),
                this.maxScroll
              );
            }
            scrollTo(F, U = !0) {
              (this.targetPos = F),
                h().isTouch &&
                  this.options.touchScrollType !== "transform" &&
                  (this.horizontalScroll
                    ? this.containerElement.scrollTo(-this.targetPos, 0)
                    : this.containerElement.scrollTo(0, -this.targetPos)),
                this.clamp(),
                (this.syncScroll = !0),
                U && V.emit(st.EXTERNALSCROLL, -this.targetPos);
            }
            toggleIframes(F) {
              for (let U = 0; U < this.iframes.length; U++)
                this.iframes[U].style.pointerEvents = F ? "auto" : "none";
            }
            blockScrollEvent(F) {
              F.stopPropagation();
            }
            addEvents() {
              V.on(st.MOUSEDETECTED, () => {
                this.options.touchScrollType !== "transform" &&
                  ((this.options.customScrollbar =
                    this.originalScrollbarSetting),
                  (this.ease = this.options.ease),
                  this.setupSmoothScroll(),
                  this.onResize());
              }),
                h().isTouch ||
                  (V.on("mouseleave", document, () => {
                    window.scrollTo(0, -this.targetPos);
                  }),
                  V.on("keydown", window, (F) => {
                    (F.key === "ArrowUp" ||
                      F.key === "ArrowDown" ||
                      F.key === "PageUp" ||
                      F.key === "PageDown" ||
                      F.key === "Home" ||
                      F.key === "End" ||
                      F.key === "Tab") &&
                      window.scrollTo(0, -this.targetPos),
                      F.key === "Tab" && this.toggleFixedContainer();
                  }),
                  V.delegate(
                    "click",
                    'a[href^="#"]',
                    this.toggleFixedContainer
                  ),
                  V.delegate(
                    "wheel",
                    this.options.blockScrollClass,
                    this.blockScrollEvent
                  ));
            }
            addTouchStyles() {
              const F =
                  ".asscroll-touch [asscroll-container] {position:absolute;top:0;left:0;right:0;bottom:-0.1px;overflow-y: auto;} .asscroll-touch [asscroll] {margin-bottom:0.1px;}",
                U = document.createElement("style");
              U.styleSheet
                ? (U.styleSheet.cssText = F)
                : U.appendChild(document.createTextNode(F)),
                document.getElementsByTagName("head")[0].appendChild(U);
            }
          }
          function ft(z, F, U) {
            return (
              F in z
                ? Object.defineProperty(z, F, {
                    value: U,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                  })
                : (z[F] = U),
              z
            );
          }
          class Mt {
            constructor(F = {}) {
              ft(this, "update", () => {
                this.events.onRaf();
              }),
                ft(this, "resize", (At) => {
                  this.events.onResize(At);
                });
              const {
                containerElement: U = "[asscroll-container]",
                scrollElements: et = "[asscroll]",
                ease: dt = 0.075,
                touchEase: gt = 1,
                touchScrollType: j = "none",
                scrollbarEl: ot = ".asscrollbar",
                scrollbarHandleEl: ct = ".asscrollbar__handle",
                customScrollbar: St = !0,
                scrollbarStyles: xt = !0,
                disableNativeScrollbar: I = !0,
                disableRaf: P = !1,
                disableResize: lt = !1,
                limitLerpRate: yt = !0,
                blockScrollClass: wt = ".asscroll-block",
              } = F;
              (this.events = new st({ disableRaf: P, disableResize: lt })),
                (this.controller = new zt({
                  containerElement: U,
                  scrollElements: et,
                  ease: dt,
                  touchEase: gt,
                  customScrollbar: St,
                  scrollbarEl: ot,
                  scrollbarHandleEl: ct,
                  scrollbarStyles: xt,
                  disableNativeScrollbar: I,
                  touchScrollType: j,
                  limitLerpRate: yt,
                  blockScrollClass: wt,
                }));
            }
            enable(F) {
              F !== void 0 &&
                typeof F != "object" &&
                console.warn(
                  "ASScroll: Please pass an object with your parameters. Since 2.0"
                ),
                this.controller.enable(F);
            }
            disable(F) {
              F !== void 0 &&
                typeof F != "object" &&
                console.warn(
                  "ASScroll: Please pass an object with your parameters. Since 2.0"
                ),
                this.controller.disable(F);
            }
            on(F, U) {
              if (typeof U != "function") {
                console.error(
                  "ASScroll: Function not provided as second parameter"
                );
                return;
              }
              if (F === "scroll") {
                V.on(st.EXTERNALSCROLL, U);
                return;
              }
              if (F === "update") {
                V.on(st.EXTERNALRAF, U);
                return;
              }
              if (F === "scrollEnd") {
                V.on(st.SCROLLEND, U);
                return;
              }
              console.warn('ASScroll: "'.concat(F, '" is not a valid event'));
            }
            off(F, U) {
              if (typeof U != "function") {
                console.error(
                  "ASScroll: Function not provided as second parameter"
                );
                return;
              }
              if (F === "scroll") {
                V.off(st.EXTERNALSCROLL, U);
                return;
              }
              if (F === "update") {
                V.off(st.EXTERNALRAF, U);
                return;
              }
              if (F === "scrollEnd") {
                V.off(st.SCROLLEND, U);
                return;
              }
              console.warn('ASScroll: "'.concat(F, '" is not a valid event'));
            }
            scrollTo(F, U = !0) {
              this.controller.scrollTo(-F, U);
            }
            get targetPos() {
              return -this.controller.targetPos;
            }
            get currentPos() {
              return -this.controller.currentPos;
            }
            set currentPos(F) {
              this.controller.targetPos = this.controller.currentPos = -F;
            }
            get maxScroll() {
              return -this.controller.maxScroll;
            }
            get containerElement() {
              return this.controller.containerElement;
            }
            get scrollElements() {
              return this.controller.scrollElements;
            }
            get isHorizontal() {
              return this.controller.horizontalScroll;
            }
            get scrollPos() {}
            get smoothScrollPos() {}
            onRaf() {}
            onResize() {}
          }
          const Tt = Mt;
        })(),
        (r = r.default),
        r
      );
    })();
  });
})(Ry);
var fF = zE(Ry.exports);
export {
  fF as A,
  cF as C,
  aF as E,
  El as G,
  ti as M,
  ei as P,
  uF as R,
  Dx as S,
  CD as T,
  Et as V,
  Le as W,
  lF as a,
  hy as b,
  eo as c,
  tp as d,
  ke as e,
  tL as g,
  hF as i,
  g_ as l,
};
